<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_RingTheory_IntegralDomain - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_RingTheory_IntegralDomain
      </nav>
      <h1>IntegralDomain</h1>
<p>üìÅ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean">Mathlib/RingTheory/IntegralDomain.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#Fintype-divisionRingOfIsDomain"><code>divisionRingOfIsDomain</code></a>, <a href="#Fintype-fieldOfDomain"><code>fieldOfDomain</code></a>, <a href="#Fintype-groupWithZeroOfCancel"><code>groupWithZeroOfCancel</code></a></details></td><td>3</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#Finite-isField_of_domain"><code>isField_of_domain</code></a>, <a href="#Finset-exists_eq_pow_of_mul_eq_pow_of_coprime"><code>exists_eq_pow_of_mul_eq_pow_of_coprime</code></a>, <a href="#Polynomial-div_eq_quo_add_rem_div"><code>div_eq_quo_add_rem_div</code></a>, <a href="#card_nthRoots_subgroup_units"><code>card_nthRoots_subgroup_units</code></a>, <a href="#exists_eq_pow_of_mul_eq_pow_of_coprime"><code>exists_eq_pow_of_mul_eq_pow_of_coprime</code></a>, <a href="#instIsCyclicUnitsOfFinite"><code>instIsCyclicUnitsOfFinite</code></a>, <a href="#isCyclic_of_subgroup_isDomain"><code>isCyclic_of_subgroup_isDomain</code></a>, <a href="#mul_left_bijective_of_finite‚ÇÄ"><code>mul_left_bijective_of_finite‚ÇÄ</code></a>, <a href="#mul_right_bijective_of_finite‚ÇÄ"><code>mul_right_bijective_of_finite‚ÇÄ</code></a>, <a href="#subgroup_units_cyclic"><code>subgroup_units_cyclic</code></a>, <a href="#sum_hom_units"><code>sum_hom_units</code></a>, <a href="#sum_hom_units_eq_zero"><code>sum_hom_units_eq_zero</code></a></details></td><td>12</td></tr>
<tr><td><strong>Total</strong></td><td><strong>15</strong></td></tr>
</table>
<h2>Finite</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L109" id="Finite-isField_of_domain"><code>isField_of_domain</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Finite.isField_of_domain" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#IsField"><code>IsField</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a></td><td>‚Äî</td><td><a href="#nonempty_fintype"><code>nonempty_fintype</code></a><br><a href="#Field-toIsField"><code>Field.toIsField</code></a></td></tr>
</table>
<h2>Finset</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L74" id="Finset-exists_eq_pow_of_mul_eq_pow_of_coprime"><code>exists_eq_pow_of_mul_eq_pow_of_coprime</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Finset.exists_eq_pow_of_mul_eq_pow_of_coprime" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#IsCoprime"><code>IsCoprime</code></a><br><a href="#Finset-prod"><code>prod</code></a><br><a href="#CommSemiring-toCommMonoid"><code>CommSemiring.toCommMonoid</code></a><br><a href="#Monoid-toNatPow"><code>Monoid.toNatPow</code></a><br><a href="#MonoidWithZero-toMonoid"><code>MonoidWithZero.toMonoid</code></a><br><a href="#Semiring-toMonoidWithZero"><code>Semiring.toMonoidWithZero</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#SetLike-instMembership"><code>SetLike.instMembership</code></a><br><a href="#Finset-instSetLike"><code>instSetLike</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#exists_eq_pow_of_mul_eq_pow_of_coprime"><code>exists_eq_pow_of_mul_eq_pow_of_coprime</code></a><br><a href="#IsCoprime-prod_right"><code>IsCoprime.prod_right</code></a><br><a href="#Finset-erase_subset"><code>erase_subset</code></a><br><a href="#Finset-notMem_erase"><code>notMem_erase</code></a><br><a href="#Finset-prod_insert"><code>prod_insert</code></a><br><a href="#Finset-insert_erase"><code>insert_erase</code></a></td></tr>
</table>
<h2>Fintype</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L95" id="Fintype-divisionRingOfIsDomain"><code>divisionRingOfIsDomain</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Fintype.divisionRingOfIsDomain" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L106" id="Fintype-fieldOfDomain"><code>fieldOfDomain</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Fintype.fieldOfDomain" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L54" id="Fintype-groupWithZeroOfCancel"><code>groupWithZeroOfCancel</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Fintype.groupWithZeroOfCancel" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
</table>
<h2>Polynomial</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L159" id="Polynomial-div_eq_quo_add_rem_div"><code>div_eq_quo_add_rem_div</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#Polynomial.div_eq_quo_add_rem_div" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Polynomial-Monic"><code>Monic</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a></td><td><a href="#WithBot"><code>WithBot</code></a><br><a href="#Preorder-toLT"><code>Preorder.toLT</code></a><br><a href="#WithBot-instPreorder"><code>WithBot.instPreorder</code></a><br><a href="#Nat-instPreorder"><code>Nat.instPreorder</code></a><br><a href="#Polynomial-degree"><code>degree</code></a><br><a href="#DivInvMonoid-toDiv"><code>DivInvMonoid.toDiv</code></a><br><a href="#DivisionRing-toDivInvMonoid"><code>DivisionRing.toDivInvMonoid</code></a><br><a href="#Field-toDivisionRing"><code>Field.toDivisionRing</code></a><br><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#RingHom"><code>RingHom</code></a><br><a href="#Polynomial"><code>Polynomial</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#Polynomial-commSemiring"><code>commSemiring</code></a><br><a href="#DivisionSemiring-toSemiring"><code>DivisionSemiring.toSemiring</code></a><br><a href="#Semifield-toDivisionSemiring"><code>Semifield.toDivisionSemiring</code></a><br><a href="#Field-toSemifield"><code>Field.toSemifield</code></a><br><a href="#RingHom-instFunLike"><code>RingHom.instFunLike</code></a><br><a href="#algebraMap"><code>algebraMap</code></a><br><a href="#Distrib-toAdd"><code>Distrib.toAdd</code></a><br><a href="#NonUnitalNonAssocSemiring-toDistrib"><code>NonUnitalNonAssocSemiring.toDistrib</code></a><br><a href="#NonUnitalNonAssocRing-toNonUnitalNonAssocSemiring"><code>NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring</code></a><br><a href="#NonUnitalNonAssocCommRing-toNonUnitalNonAssocRing"><code>NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing</code></a><br><a href="#NonUnitalCommRing-toNonUnitalNonAssocCommRing"><code>NonUnitalCommRing.toNonUnitalNonAssocCommRing</code></a><br><a href="#CommRing-toNonUnitalCommRing"><code>CommRing.toNonUnitalCommRing</code></a><br><a href="#Field-toCommRing"><code>Field.toCommRing</code></a></td><td>‚Äî</td><td><a href="#Polynomial-degree_modByMonic_lt"><code>degree_modByMonic_lt</code></a><br><a href="#IsDomain-toNontrivial"><code>IsDomain.toNontrivial</code></a><br><a href="#map_ne_zero_iff"><code>map_ne_zero_iff</code></a><br><a href="#MonoidWithZeroHomClass-toZeroHomClass"><code>MonoidWithZeroHomClass.toZeroHomClass</code></a><br><a href="#RingHomClass-toMonoidWithZeroHomClass"><code>RingHomClass.toMonoidWithZeroHomClass</code></a><br><a href="#RingHom-instRingHomClass"><code>RingHom.instRingHomClass</code></a><br><a href="#IsFractionRing-injective"><code>IsFractionRing.injective</code></a><br><a href="#Polynomial-Monic-ne_zero"><code>Monic.ne_zero</code></a><br><a href="#Mathlib-Tactic-FieldSimp-eq_eq_cancel_eq"><code>Mathlib.Tactic.FieldSimp.eq_eq_cancel_eq</code></a><br><a href="#IsCancelMulZero-toIsLeftCancelMulZero"><code>IsCancelMulZero.toIsLeftCancelMulZero</code></a><br><a href="#instIsCancelMulZero"><code>instIsCancelMulZero</code></a><br><a href="#Mathlib-Tactic-FieldSimp-eq_mul_of_eq_eq_eq_mul"><code>Mathlib.Tactic.FieldSimp.eq_mul_of_eq_eq_eq_mul</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-div_eq_eval"><code>Mathlib.Tactic.FieldSimp.NF.div_eq_eval</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-atom_eq_eval"><code>Mathlib.Tactic.FieldSimp.NF.atom_eq_eval</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-div_eq_eval‚ÇÉ"><code>Mathlib.Tactic.FieldSimp.NF.div_eq_eval‚ÇÉ</code></a><br><a href="#div_one"><code>div_one</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-eval_cons_mul_eval"><code>Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-eval_mul_eval_cons"><code>Mathlib.Tactic.FieldSimp.NF.eval_mul_eval_cons</code></a><br><a href="#one_mul"><code>one_mul</code></a><br><a href="#Mathlib-Tactic-FieldSimp-eq_div_of_eq_one_of_subst"><code>Mathlib.Tactic.FieldSimp.eq_div_of_eq_one_of_subst</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-cons_eq_div_of_eq_div"><code>Mathlib.Tactic.FieldSimp.NF.cons_eq_div_of_eq_div</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-eval_cons"><code>Mathlib.Tactic.FieldSimp.NF.eval_cons</code></a><br><a href="#Mathlib-Tactic-FieldSimp-zpow'_one"><code>Mathlib.Tactic.FieldSimp.zpow'_one</code></a><br><a href="#Mathlib-Tactic-FieldSimp-subst_add"><code>Mathlib.Tactic.FieldSimp.subst_add</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-eval_cons_mul_eval_cons_neg"><code>Mathlib.Tactic.FieldSimp.NF.eval_cons_mul_eval_cons_neg</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-div_eq_eval‚ÇÅ"><code>Mathlib.Tactic.FieldSimp.NF.div_eq_eval‚ÇÅ</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-one_div_eq_eval"><code>Mathlib.Tactic.FieldSimp.NF.one_div_eq_eval</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-mul_eq_eval‚ÇÉ"><code>Mathlib.Tactic.FieldSimp.NF.mul_eq_eval‚ÇÉ</code></a><br><a href="#mul_one"><code>mul_one</code></a><br><a href="#Mathlib-Tactic-FieldSimp-NF-cons_ne_zero"><code>Mathlib.Tactic.FieldSimp.NF.cons_ne_zero</code></a><br><a href="#one_ne_zero"><code>one_ne_zero</code></a><br><a href="#NeZero-one"><code>NeZero.one</code></a><br><a href="#GroupWithZero-toNontrivial"><code>GroupWithZero.toNontrivial</code></a><br><a href="#add_comm"><code>add_comm</code></a><br><a href="#map_mul"><code>map_mul</code></a><br><a href="#NonUnitalRingHomClass-toMulHomClass"><code>NonUnitalRingHomClass.toMulHomClass</code></a><br><a href="#RingHomClass-toNonUnitalRingHomClass"><code>RingHomClass.toNonUnitalRingHomClass</code></a><br><a href="#map_add"><code>map_add</code></a><br><a href="#AddMonoidHomClass-toAddHomClass"><code>AddMonoidHomClass.toAddHomClass</code></a><br><a href="#RingHomClass-toAddMonoidHomClass"><code>RingHomClass.toAddMonoidHomClass</code></a><br><a href="#Polynomial-modByMonic_add_div"><code>modByMonic_add_div</code></a></td></tr>
</table>
<h2>(root)</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L118" id="card_nthRoots_subgroup_units"><code>card_nthRoots_subgroup_units</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#card_nthRoots_subgroup_units" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#MonoidHom"><code>MonoidHom</code></a><br><a href="#MulOneClass-toMulOne"><code>MulOneClass.toMulOne</code></a><br><a href="#Monoid-toMulOneClass"><code>Monoid.toMulOneClass</code></a><br><a href="#DivInvMonoid-toMonoid"><code>DivInvMonoid.toMonoid</code></a><br><a href="#Group-toDivInvMonoid"><code>Group.toDivInvMonoid</code></a><br><a href="#MulZeroOneClass-toMulOneClass"><code>MulZeroOneClass.toMulOneClass</code></a><br><a href="#NonAssocSemiring-toMulZeroOneClass"><code>NonAssocSemiring.toMulZeroOneClass</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#MonoidHom-instFunLike"><code>MonoidHom.instFunLike</code></a></td><td><a href="#Finset-card"><code>Finset.card</code></a><br><a href="#Finset-filter"><code>Finset.filter</code></a><br><a href="#Monoid-toNatPow"><code>Monoid.toNatPow</code></a><br><a href="#Finset-univ"><code>Finset.univ</code></a><br><a href="#Multiset-card"><code>Multiset.card</code></a><br><a href="#Polynomial-nthRoots"><code>Polynomial.nthRoots</code></a></td><td>‚Äî</td><td><a href="#Finset-card_le_card_of_injOn"><code>Finset.card_le_card_of_injOn</code></a><br><a href="#map_pow"><code>map_pow</code></a><br><a href="#MonoidHom-instMonoidHomClass"><code>MonoidHom.instMonoidHomClass</code></a><br><a href="#Finset-coe_filter"><code>Finset.coe_filter</code></a><br><a href="#Function-Injective-injOn"><code>Function.Injective.injOn</code></a><br><a href="#Multiset-toFinset_card_le"><code>Multiset.toFinset_card_le</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L64" id="exists_eq_pow_of_mul_eq_pow_of_coprime"><code>exists_eq_pow_of_mul_eq_pow_of_coprime</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#exists_eq_pow_of_mul_eq_pow_of_coprime" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#IsCoprime"><code>IsCoprime</code></a><br><a href="#Distrib-toMul"><code>Distrib.toMul</code></a><br><a href="#NonUnitalNonAssocSemiring-toDistrib"><code>NonUnitalNonAssocSemiring.toDistrib</code></a><br><a href="#NonAssocSemiring-toNonUnitalNonAssocSemiring"><code>NonAssocSemiring.toNonUnitalNonAssocSemiring</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Monoid-toNatPow"><code>Monoid.toNatPow</code></a><br><a href="#MonoidWithZero-toMonoid"><code>MonoidWithZero.toMonoid</code></a><br><a href="#Semiring-toMonoidWithZero"><code>Semiring.toMonoidWithZero</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#exists_eq_pow_of_mul_eq_pow"><code>exists_eq_pow_of_mul_eq_pow</code></a><br><a href="#isUnit_of_dvd_one"><code>isUnit_of_dvd_one</code></a><br><a href="#dvd_add"><code>dvd_add</code></a><br><a href="#Distrib-leftDistribClass"><code>Distrib.leftDistribClass</code></a><br><a href="#dvd_mul_of_dvd_right"><code>dvd_mul_of_dvd_right</code></a><br><a href="#GCDMonoid-gcd_dvd_left"><code>GCDMonoid.gcd_dvd_left</code></a><br><a href="#GCDMonoid-gcd_dvd_right"><code>GCDMonoid.gcd_dvd_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L139" id="instIsCyclicUnitsOfFinite"><code>instIsCyclicUnitsOfFinite</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#instIsCyclicUnitsOfFinite" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#IsCyclic"><code>IsCyclic</code></a><br><a href="#Units"><code>Units</code></a><br><a href="#MonoidWithZero-toMonoid"><code>MonoidWithZero.toMonoid</code></a><br><a href="#Semiring-toMonoidWithZero"><code>Semiring.toMonoidWithZero</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#DivInvMonoid-toZPow"><code>DivInvMonoid.toZPow</code></a><br><a href="#Units-instDivInvMonoid"><code>Units.instDivInvMonoid</code></a></td><td>‚Äî</td><td><a href="#isCyclic_of_subgroup_isDomain"><code>isCyclic_of_subgroup_isDomain</code></a><br><a href="#Units-val_injective"><code>Units.val_injective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L128" id="isCyclic_of_subgroup_isDomain"><code>isCyclic_of_subgroup_isDomain</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#isCyclic_of_subgroup_isDomain" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#MonoidHom"><code>MonoidHom</code></a><br><a href="#MulOneClass-toMulOne"><code>MulOneClass.toMulOne</code></a><br><a href="#Monoid-toMulOneClass"><code>Monoid.toMulOneClass</code></a><br><a href="#DivInvMonoid-toMonoid"><code>DivInvMonoid.toMonoid</code></a><br><a href="#Group-toDivInvMonoid"><code>Group.toDivInvMonoid</code></a><br><a href="#MulZeroOneClass-toMulOneClass"><code>MulZeroOneClass.toMulOneClass</code></a><br><a href="#NonAssocSemiring-toMulZeroOneClass"><code>NonAssocSemiring.toMulZeroOneClass</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#MonoidHom-instFunLike"><code>MonoidHom.instFunLike</code></a></td><td><a href="#IsCyclic"><code>IsCyclic</code></a><br><a href="#DivInvMonoid-toZPow"><code>DivInvMonoid.toZPow</code></a></td><td>‚Äî</td><td><a href="#nonempty_fintype"><code>nonempty_fintype</code></a><br><a href="#isCyclic_of_card_pow_eq_one_le"><code>isCyclic_of_card_pow_eq_one_le</code></a><br><a href="#le_trans"><code>le_trans</code></a><br><a href="#card_nthRoots_subgroup_units"><code>card_nthRoots_subgroup_units</code></a><br><a href="#Polynomial-card_nthRoots"><code>Polynomial.card_nthRoots</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L49" id="mul_left_bijective_of_finite‚ÇÄ"><code>mul_left_bijective_of_finite‚ÇÄ</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#mul_left_bijective_of_finite‚ÇÄ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#Function-Bijective"><code>Function.Bijective</code></a><br><a href="#MulZeroClass-toMul"><code>MulZeroClass.toMul</code></a><br><a href="#MulZeroOneClass-toMulZeroClass"><code>MulZeroOneClass.toMulZeroClass</code></a><br><a href="#MonoidWithZero-toMulZeroOneClass"><code>MonoidWithZero.toMulZeroOneClass</code></a></td><td>‚Äî</td><td><a href="#Finite-injective_iff_bijective"><code>Finite.injective_iff_bijective</code></a><br><a href="#mul_left_injective‚ÇÄ"><code>mul_left_injective‚ÇÄ</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L45" id="mul_right_bijective_of_finite‚ÇÄ"><code>mul_right_bijective_of_finite‚ÇÄ</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#mul_right_bijective_of_finite‚ÇÄ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#Function-Bijective"><code>Function.Bijective</code></a><br><a href="#MulZeroClass-toMul"><code>MulZeroClass.toMul</code></a><br><a href="#MulZeroOneClass-toMulZeroClass"><code>MulZeroOneClass.toMulZeroClass</code></a><br><a href="#MonoidWithZero-toMulZeroOneClass"><code>MonoidWithZero.toMulZeroOneClass</code></a></td><td>‚Äî</td><td><a href="#Finite-injective_iff_bijective"><code>Finite.injective_iff_bijective</code></a><br><a href="#mul_right_injective‚ÇÄ"><code>mul_right_injective‚ÇÄ</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L147" id="subgroup_units_cyclic"><code>subgroup_units_cyclic</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#subgroup_units_cyclic" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#IsCyclic"><code>IsCyclic</code></a><br><a href="#Units"><code>Units</code></a><br><a href="#MonoidWithZero-toMonoid"><code>MonoidWithZero.toMonoid</code></a><br><a href="#Semiring-toMonoidWithZero"><code>Semiring.toMonoidWithZero</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#Subgroup"><code>Subgroup</code></a><br><a href="#Units-instGroup"><code>Units.instGroup</code></a><br><a href="#SetLike-instMembership"><code>SetLike.instMembership</code></a><br><a href="#Subgroup-instSetLike"><code>Subgroup.instSetLike</code></a><br><a href="#Subgroup-zpow"><code>Subgroup.zpow</code></a></td><td>‚Äî</td><td><a href="#isCyclic_of_subgroup_isDomain"><code>isCyclic_of_subgroup_isDomain</code></a><br><a href="#Units-val_injective"><code>Units.val_injective</code></a><br><a href="#Subtype-val_injective"><code>Subtype.val_injective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L235" id="sum_hom_units"><code>sum_hom_units</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#sum_hom_units" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#Finset-sum"><code>Finset.sum</code></a><br><a href="#NonUnitalNonAssocSemiring-toAddCommMonoid"><code>NonUnitalNonAssocSemiring.toAddCommMonoid</code></a><br><a href="#NonUnitalNonAssocRing-toNonUnitalNonAssocSemiring"><code>NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring</code></a><br><a href="#NonUnitalNonAssocCommRing-toNonUnitalNonAssocRing"><code>NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing</code></a><br><a href="#NonUnitalCommRing-toNonUnitalNonAssocCommRing"><code>NonUnitalCommRing.toNonUnitalNonAssocCommRing</code></a><br><a href="#CommRing-toNonUnitalCommRing"><code>CommRing.toNonUnitalCommRing</code></a><br><a href="#Finset-univ"><code>Finset.univ</code></a><br><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#MonoidHom"><code>MonoidHom</code></a><br><a href="#MulOneClass-toMulOne"><code>MulOneClass.toMulOne</code></a><br><a href="#Monoid-toMulOneClass"><code>Monoid.toMulOneClass</code></a><br><a href="#DivInvMonoid-toMonoid"><code>DivInvMonoid.toMonoid</code></a><br><a href="#Group-toDivInvMonoid"><code>Group.toDivInvMonoid</code></a><br><a href="#MulZeroOneClass-toMulOneClass"><code>MulZeroOneClass.toMulOneClass</code></a><br><a href="#NonAssocSemiring-toMulZeroOneClass"><code>NonAssocSemiring.toMulZeroOneClass</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#MonoidHom-instFunLike"><code>MonoidHom.instFunLike</code></a><br><a href="#AddMonoidWithOne-toNatCast"><code>AddMonoidWithOne.toNatCast</code></a><br><a href="#AddGroupWithOne-toAddMonoidWithOne"><code>AddGroupWithOne.toAddMonoidWithOne</code></a><br><a href="#Ring-toAddGroupWithOne"><code>Ring.toAddGroupWithOne</code></a><br><a href="#CommRing-toRing"><code>CommRing.toRing</code></a><br><a href="#instOneMonoidHom"><code>instOneMonoidHom</code></a><br><a href="#Fintype-card"><code>Fintype.card</code></a></td><td>‚Äî</td><td><a href="#Finset-sum_congr"><code>Finset.sum_congr</code></a><br><a href="#Finset-sum_const"><code>Finset.sum_const</code></a><br><a href="#nsmul_eq_mul"><code>nsmul_eq_mul</code></a><br><a href="#mul_one"><code>mul_one</code></a><br><a href="#Nat-cast_zero"><code>Nat.cast_zero</code></a><br><a href="#sum_hom_units_eq_zero"><code>sum_hom_units_eq_zero</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/IntegralDomain.lean#L178" id="sum_hom_units_eq_zero"><code>sum_hom_units_eq_zero</code></a> <a href="../api/Mathlib/RingTheory/IntegralDomain.html#sum_hom_units_eq_zero" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#Finset-sum"><code>Finset.sum</code></a><br><a href="#NonUnitalNonAssocSemiring-toAddCommMonoid"><code>NonUnitalNonAssocSemiring.toAddCommMonoid</code></a><br><a href="#NonUnitalNonAssocRing-toNonUnitalNonAssocSemiring"><code>NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring</code></a><br><a href="#NonUnitalNonAssocCommRing-toNonUnitalNonAssocRing"><code>NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing</code></a><br><a href="#NonUnitalCommRing-toNonUnitalNonAssocCommRing"><code>NonUnitalCommRing.toNonUnitalNonAssocCommRing</code></a><br><a href="#CommRing-toNonUnitalCommRing"><code>CommRing.toNonUnitalCommRing</code></a><br><a href="#Finset-univ"><code>Finset.univ</code></a><br><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#MonoidHom"><code>MonoidHom</code></a><br><a href="#MulOneClass-toMulOne"><code>MulOneClass.toMulOne</code></a><br><a href="#Monoid-toMulOneClass"><code>Monoid.toMulOneClass</code></a><br><a href="#DivInvMonoid-toMonoid"><code>DivInvMonoid.toMonoid</code></a><br><a href="#Group-toDivInvMonoid"><code>Group.toDivInvMonoid</code></a><br><a href="#MulZeroOneClass-toMulOneClass"><code>MulZeroOneClass.toMulOneClass</code></a><br><a href="#NonAssocSemiring-toMulZeroOneClass"><code>NonAssocSemiring.toMulZeroOneClass</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#MonoidHom-instFunLike"><code>MonoidHom.instFunLike</code></a><br><a href="#MulZeroClass-toZero"><code>MulZeroClass.toZero</code></a><br><a href="#NonUnitalNonAssocSemiring-toMulZeroClass"><code>NonUnitalNonAssocSemiring.toMulZeroClass</code></a></td><td>‚Äî</td><td><a href="#IsCyclic-exists_monoid_generator"><code>IsCyclic.exists_monoid_generator</code></a><br><a href="#Finite-of_fintype"><code>Finite.of_fintype</code></a><br><a href="#subgroup_units_cyclic"><code>subgroup_units_cyclic</code></a><br><a href="#MonoidHom-ext"><code>MonoidHom.ext</code></a><br><a href="#MonoidHom-one_apply"><code>MonoidHom.one_apply</code></a><br><a href="#one_pow"><code>one_pow</code></a><br><a href="#MonoidHom-coe_toHomUnits"><code>MonoidHom.coe_toHomUnits</code></a><br><a href="#Units-ext_iff"><code>Units.ext_iff</code></a><br><a href="#Units-ext"><code>Units.ext</code></a><br><a href="#sub_eq_zero"><code>sub_eq_zero</code></a><br><a href="#Finset-sum_comp"><code>Finset.sum_comp</code></a><br><a href="#Finset-sum_congr"><code>Finset.sum_congr</code></a><br><a href="#MonoidHom-card_fiber_eq_of_mem_range"><code>MonoidHom.card_fiber_eq_of_mem_range</code></a><br><a href="#MonoidHom-instMonoidHomClass"><code>MonoidHom.instMonoidHomClass</code></a><br><a href="#MonoidHom-map_one"><code>MonoidHom.map_one</code></a><br><a href="#Finset-sum_subtype"><code>Finset.sum_subtype</code></a><br><a href="#Finset-smul_sum"><code>Finset.smul_sum</code></a><br><a href="#Finset-sum_nbij"><code>Finset.sum_nbij</code></a><br><a href="#Finset-coe_range"><code>Finset.coe_range</code></a><br><a href="#pow_injOn_Iio_orderOf"><code>pow_injOn_Iio_orderOf</code></a><br><a href="#Finset-mem_range"><code>Finset.mem_range</code></a><br><a href="#orderOf_pos"><code>orderOf_pos</code></a><br><a href="#pow_mod_orderOf"><code>pow_mod_orderOf</code></a><br><a href="#mul_left_inj'"><code>mul_left_inj'</code></a><br><a href="#IsCancelMulZero-toIsRightCancelMulZero"><code>IsCancelMulZero.toIsRightCancelMulZero</code></a><br><a href="#IsDomain-toIsCancelMulZero"><code>IsDomain.toIsCancelMulZero</code></a><br><a href="#MulZeroClass-zero_mul"><code>MulZeroClass.zero_mul</code></a><br><a href="#geom_sum_mul"><code>geom_sum_mul</code></a><br><a href="#SubgroupClass-toSubmonoidClass"><code>SubgroupClass.toSubmonoidClass</code></a><br><a href="#Subgroup-instSubgroupClass"><code>Subgroup.instSubgroupClass</code></a><br><a href="#Nat-cast_one"><code>Nat.cast_one</code></a><br><a href="#Nat-cast_zero"><code>Nat.cast_zero</code></a><br><a href="#pow_orderOf_eq_one"><code>pow_orderOf_eq_one</code></a><br><a href="#sub_self"><code>sub_self</code></a><br><a href="#smul_zero"><code>smul_zero</code></a></td></tr>
</table>
<p>---</p>
<p><a href="index.html">‚Üê Back to Index</a></p>
    </div>
  </main>
</body>
</html>