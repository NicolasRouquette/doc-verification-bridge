<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_CategoryTheory_Comma_StructuredArrow_Basic - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_CategoryTheory_Comma_StructuredArrow_Basic
      </nav>
      <h1>Basic</h1>
<p>üìÅ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean">Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#CategoryTheory-CostructuredArrow-IsUniversal"><code>IsUniversal</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta"><code>eta</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk"><code>isoMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇIsoPreEquivalenceInverseCompProj"><code>map‚ÇÇIsoPreEquivalenceInverseCompProj</code></a>, <a href="#CategoryTheory-CostructuredArrow-mk"><code>mk</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkIdTerminal"><code>mkIdTerminal</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a>, <a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a>, <a href="#CategoryTheory-CostructuredArrow-postIsoMap‚ÇÇ"><code>postIsoMap‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence"><code>preEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj"><code>proj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow"><code>toStructuredArrow</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'"><code>toStructuredArrow'</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow"><code>toCostructuredArrow</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrowCompProj"><code>toCostructuredArrowCompProj</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow"><code>toStructuredArrow</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrowCompProj"><code>toStructuredArrowCompProj</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal"><code>IsUniversal</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-desc"><code>desc</code></a>, <a href="#CategoryTheory-StructuredArrow-eta"><code>eta</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a>, <a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIsoMap‚ÇÇ"><code>mapIsoMap‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇCompMap‚ÇÇIso"><code>map‚ÇÇCompMap‚ÇÇIso</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇIsoPreEquivalenceInverseCompProj"><code>map‚ÇÇIsoPreEquivalenceInverseCompProj</code></a>, <a href="#CategoryTheory-StructuredArrow-mk"><code>mk</code></a>, <a href="#CategoryTheory-StructuredArrow-mkIdInitial"><code>mkIdInitial</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a>, <a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a>, <a href="#CategoryTheory-StructuredArrow-postIsoMap‚ÇÇ"><code>postIsoMap‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preIsoMap‚ÇÇ"><code>preIsoMap‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a>, <a href="#CategoryTheory-StructuredArrow-proj"><code>proj</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow"><code>toCostructuredArrow</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'"><code>toCostructuredArrow'</code></a>, <a href="#CategoryTheory-costructuredArrowOpEquivalence"><code>costructuredArrowOpEquivalence</code></a>, <a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a>, <a href="#CategoryTheory-instCategoryStructuredArrow"><code>instCategoryStructuredArrow</code></a>, <a href="#CategoryTheory-structuredArrowOpEquivalence"><code>structuredArrowOpEquivalence</code></a></details></td><td>62</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#CategoryTheory-CostructuredArrow-IsUniversal-existsUnique"><code>existsUnique</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-fac"><code>fac</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-fac_assoc"><code>fac_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-uniq"><code>uniq</code></a>, <a href="#CategoryTheory-CostructuredArrow-comp_left"><code>comp_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_of_epi_left"><code>epi_of_epi_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-eq_mk"><code>eq_mk</code></a>, <a href="#CategoryTheory-CostructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta_hom_left"><code>eta_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta_inv_left"><code>eta_inv_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ext"><code>ext</code></a>, <a href="#CategoryTheory-CostructuredArrow-ext_iff"><code>ext_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_comp"><code>homMk'_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_id"><code>homMk'_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_left"><code>homMk'_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_right"><code>homMk'_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk_left"><code>homMk_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-CostructuredArrow-hom_eq_iff"><code>hom_eq_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-hom_ext"><code>hom_ext</code></a>, <a href="#CategoryTheory-CostructuredArrow-hom_ext_iff"><code>hom_ext_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-id_left"><code>id_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompObjPostOfFull"><code>instEssSurjCompObjPostOfFull</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompObjPost"><code>instFaithfulCompObjPost</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompObjPostOfFaithful"><code>instFullCompObjPostOfFaithful</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompPre"><code>instFullCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_hom_left"><code>isoMk_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_inv_left"><code>isoMk_inv_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_hom_app_left"><code>mapIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_inv_app_left"><code>mapIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_hom_app_left"><code>mapIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_inv_app_left"><code>mapIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_hom_app_left"><code>mapNatIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_inv_app_left"><code>mapNatIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_hom_app_left"><code>mapNatIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_inv_app_left"><code>mapNatIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_comp"><code>map_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_id"><code>map_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_mk"><code>map_mk</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_comp"><code>mkPrecomp_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_id"><code>mkPrecomp_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_left"><code>mkPrecomp_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_right"><code>mkPrecomp_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mk_hom_eq_self"><code>mk_hom_eq_self</code></a>, <a href="#CategoryTheory-CostructuredArrow-mk_left"><code>mk_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mk_right"><code>mk_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mk_surjective"><code>mk_surjective</code></a>, <a href="#CategoryTheory-CostructuredArrow-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-mono_of_mono_left"><code>mono_of_mono_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-obj_ext"><code>obj_ext</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_map_left"><code>functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_left"><code>functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_hom_left"><code>inverse_obj_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_left"><code>pre_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_right"><code>pre_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_left"><code>pre_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_right"><code>pre_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_map"><code>prodInverse_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_map"><code>proj_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_obj"><code>proj_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-CostructuredArrow-right_eq_id"><code>right_eq_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>toStructuredArrow'_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>toStructuredArrow'_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>toStructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-w"><code>w</code></a>, <a href="#CategoryTheory-CostructuredArrow-w_assoc"><code>w_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-w_prod_fst"><code>w_prod_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-w_prod_fst_assoc"><code>w_prod_fst_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-w_prod_snd"><code>w_prod_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-w_prod_snd_assoc"><code>w_prod_snd_assoc</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_comp_proj"><code>toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>toStructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_map"><code>toStructuredArrow_map</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-existsUnique"><code>existsUnique</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-fac"><code>fac</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-fac_assoc"><code>fac_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-uniq"><code>uniq</code></a>, <a href="#CategoryTheory-StructuredArrow-comp_right"><code>comp_right</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_of_epi_right"><code>epi_of_epi_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eq_mk"><code>eq_mk</code></a>, <a href="#CategoryTheory-StructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_hom_right"><code>eta_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_inv_right"><code>eta_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ext"><code>ext</code></a>, <a href="#CategoryTheory-StructuredArrow-ext_iff"><code>ext_iff</code></a>, <a href="#CategoryTheory-StructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_comp"><code>homMk'_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_id"><code>homMk'_id</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_left"><code>homMk'_left</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_right"><code>homMk'_right</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk_right"><code>homMk_right</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-StructuredArrow-hom_eq_iff"><code>hom_eq_iff</code></a>, <a href="#CategoryTheory-StructuredArrow-hom_ext"><code>hom_ext</code></a>, <a href="#CategoryTheory-StructuredArrow-hom_ext_iff"><code>hom_ext_iff</code></a>, <a href="#CategoryTheory-StructuredArrow-id_right"><code>id_right</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>instEssSurjObjCompPostOfFull</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>instFaithfulObjCompPost</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullCompPre"><code>instFullCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>instFullObjCompPostOfFaithful</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_hom_right"><code>isoMk_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_inv_right"><code>isoMk_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-left_eq_id"><code>left_eq_id</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_hom_app_right"><code>mapIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_inv_app_right"><code>mapIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_hom_app_right"><code>mapIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_inv_app_right"><code>mapIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_hom_app_right"><code>mapNatIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_inv_app_right"><code>mapNatIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_hom_app_right"><code>mapNatIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_inv_app_right"><code>mapNatIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map_comp"><code>map_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-map_id"><code>map_id</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map_mk"><code>map_mk</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_comp"><code>mkPostcomp_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_id"><code>mkPostcomp_id</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_left"><code>mkPostcomp_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_right"><code>mkPostcomp_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mk_hom_eq_self"><code>mk_hom_eq_self</code></a>, <a href="#CategoryTheory-StructuredArrow-mk_left"><code>mk_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mk_right"><code>mk_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mk_surjective"><code>mk_surjective</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_of_mono_right"><code>mono_of_mono_right</code></a>, <a href="#CategoryTheory-StructuredArrow-obj_ext"><code>obj_ext</code></a>, <a href="#CategoryTheory-StructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-StructuredArrow-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>preEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>preEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>preEquivalenceFunctor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>preEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>preEquivalenceInverse_obj_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>preEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>preEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>preEquivalenceInverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>preEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>preEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_left"><code>pre_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_right"><code>pre_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_left"><code>pre_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_right"><code>pre_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_map"><code>prodInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_map"><code>proj_map</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_obj"><code>proj_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>toCostructuredArrow'_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a>, <a href="#CategoryTheory-StructuredArrow-w_assoc"><code>w_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-w_prod_fst"><code>w_prod_fst</code></a>, <a href="#CategoryTheory-StructuredArrow-w_prod_fst_assoc"><code>w_prod_fst_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-w_prod_snd"><code>w_prod_snd</code></a>, <a href="#CategoryTheory-StructuredArrow-w_prod_snd_assoc"><code>w_prod_snd_assoc</code></a></details></td><td>276</td></tr>
<tr><td><strong>Total</strong></td><td><strong>338</strong></td></tr>
</table>
<h2>CategoryTheory</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L888" id="CategoryTheory-costructuredArrowOpEquivalence"><code>costructuredArrowOpEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.costructuredArrowOpEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L408" id="CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.instCategoryCostructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>434 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-homMk'_id"><code>CostructuredArrow.homMk'_id</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_map_hom"><code>Functor.LeftExtension.coconeAtFunctor_map_hom</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_hom_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_hom_right</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_map"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_isColimit"><code>Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_isColimit</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_hom</code></a>, <a href="#CategoryTheory-ObjectProperty-ColimitOfShape-toCostructuredArrow_obj"><code>ObjectProperty.ColimitOfShape.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_iff_lan_preservesFiniteLimits"><code>preservesFiniteLimits_iff_lan_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact"><code>TwoSquare.instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact</code></a>, <a href="#LightProfinite-Extend-functorOp_obj"><code>LightProfinite.Extend.functorOp_obj</code></a>, <a href="#LightCondensed-lanPresheafIso_hom"><code>LightCondensed.lanPresheafIso_hom</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceInverseœÄ_hom_app"><code>CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_comp"><code>CostructuredArrow.map_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_left"><code>CostructuredArrow.toOver_obj_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-costructuredArrowPresheafToOver_map"><code>OverPresheafAux.costructuredArrowPresheafToOver_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalence_functor"><code>CategoryOfElements.costructuredArrowYonedaEquivalence_functor</code></a>, <a href="#CategoryTheory-OverPresheafAux-unitAux_hom"><code>OverPresheafAux.unitAux_hom</code></a>, <a href="#Profinite-Extend-cocone_pt"><code>Profinite.Extend.cocone_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_reflectsIsomorphisms"><code>CostructuredArrow.proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_unitIso"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>CostructuredArrow.ofDiagEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-NonemptyParallelPairPresentationAux-hf"><code>NonemptyParallelPairPresentationAux.hf</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_Œπ_app"><code>Limits.Cocone.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>lan_preservesFiniteLimits_of_flat</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_hom"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_hom</code></a>, <a href="#Profinite-Extend-functorOp_map"><code>Profinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-small_proj_preimage_of_locallySmall"><code>CostructuredArrow.small_proj_preimage_of_locallySmall</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>CostructuredArrow.prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_pre"><code>CostructuredArrow.isEquivalence_pre</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYoneda_map"><code>OverPresheafAux.restrictedYoneda_map</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_inverse"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_right_as"><code>CostructuredArrow.preEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_hom"><code>CostructuredArrow.pre_obj_hom</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_obj_left_map"><code>Functor.RightExtension.postcompose‚ÇÇ_obj_left_map</code></a>, <a href="#CategoryTheory-Limits-IsIndObject-isFiltered"><code>Limits.IsIndObject.isFiltered</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYoneda_obj"><code>OverPresheafAux.restrictedYoneda_obj</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_obj_right"><code>Functor.RightExtension.postcompose‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_id"><code>CostructuredArrow.mkPrecomp_id</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom"><code>Functor.leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-mapCone_raiseCone"><code>CostructuredArrow.CreatesConnected.mapCone_raiseCone</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_left"><code>CostructuredArrow.mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_hom"><code>CostructuredArrow.mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-functor_obj"><code>CostructuredArrow.functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_right"><code>CostructuredArrow.toOver_obj_right</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_left</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-instFinalICostructuredArrowFunctorOppositeTypeYonedaToCostructuredArrow"><code>Limits.IndObjectPresentation.instFinalICostructuredArrowFunctorOppositeTypeYonedaToCostructuredArrow</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_proj"><code>Limits.Cocone.toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalenceMap‚ÇÇ"><code>CostructuredArrow.isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-Limits-Cone-fromCostructuredArrow_map_hom"><code>Limits.Cone.fromCostructuredArrow_map_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-toCostructuredArrow_obj"><code>Limits.Cone.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_right_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_inv"><code>Functor.Œπ_leftKanExtensionObjIsoColimit_inv</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact"><code>TwoSquare.instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_right"><code>CostructuredArrow.mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_toOver_comp_forget"><code>Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget</code></a>, <a href="#CategoryTheory-CostructuredArrow-unop_left_comp_ofMkLEMk_unop"><code>CostructuredArrow.unop_left_comp_ofMkLEMk_unop</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_obj_left_map"><code>Functor.RightExtension.postcomp‚ÇÅ_obj_left_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_obj"><code>CostructuredArrow.post_obj</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_map_right"><code>Functor.RightExtension.postcomp‚ÇÅ_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_map"><code>Limits.Cocone.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_inv_app_left"><code>CostructuredArrow.mapNatIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-hasTerminal"><code>CostructuredArrow.hasTerminal</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_map"><code>CostructuredArrow.prodFunctor_map</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_right</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_unitIso"><code>TwoSquare.equivalenceJ_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_right"><code>CostructuredArrow.map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_hom_app_left"><code>CostructuredArrow.mapIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_right"><code>CostructuredArrow.toOver_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_hom"><code>CostructuredArrow.map_obj_hom</code></a>, <a href="#LightProfinite-Extend-cocone_Œπ_app"><code>LightProfinite.Extend.cocone_Œπ_app</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-functorToInterchangeIso_inv_app_app"><code>Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_inv_app_app</code></a>, <a href="#Condensed-lanPresheafExt_inv"><code>Condensed.lanPresheafExt_inv</code></a>, <a href="#CategoryTheory-Functor-costructuredArrowMapCocone_pt"><code>Functor.costructuredArrowMapCocone_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_hom"><code>CostructuredArrow.toOver_obj_hom</code></a>, <a href="#CategoryTheory-Functor-Œπ_colimitIsoColimitGrothendieck_inv_assoc"><code>Functor.Œπ_colimitIsoColimitGrothendieck_inv_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullOverToOver"><code>CostructuredArrow.instFullOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_id"><code>CostructuredArrow.homMk'_mk_id</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromCostructuredArrow_Œπ_app"><code>Limits.Cocone.fromCostructuredArrow_Œπ_app</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_inv_hom"><code>Functor.LeftExtension.coconeAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-Functor-RightExtension-precomp_map_left"><code>Functor.RightExtension.precomp_map_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompProj_hom_app"><code>Limits.Cocone.toCostructuredArrowCompProj_hom_app</code></a>, <a href="#CategoryTheory-Limits-Cone-fromCostructuredArrow_obj_œÄ"><code>Limits.Cone.fromCostructuredArrow_obj_œÄ</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_inv_assoc"><code>Functor.Œπ_leftKanExtensionObjIsoColimit_inv_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitForward_naturality‚ÇÅ"><code>OverPresheafAux.counitForward_naturality‚ÇÅ</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_right"><code>CostructuredArrow.mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_Œπ_app"><code>Limits.colimit.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>CostructuredArrow.costructuredArrowToOverEquivalence.functor_map</code></a>, <a href="#CategoryTheory-isLeftAdjoint_iff_hasTerminal_costructuredArrow"><code>isLeftAdjoint_iff_hasTerminal_costructuredArrow</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowRightwards_map"><code>TwoSquare.costructuredArrowRightwards_map</code></a>, <a href="#Profinite-Extend-functorOp_obj"><code>Profinite.Extend.functorOp_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_left"><code>CostructuredArrow.mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulOverToOver"><code>CostructuredArrow.instFaithfulOverToOver</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowOverToOver"><code>instInitialCostructuredArrowOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_left"><code>CostructuredArrow.pre_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_map"><code>CostructuredArrow.post_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_inv_app_left"><code>CostructuredArrow.mapIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-essSurj_map‚ÇÇ"><code>CostructuredArrow.essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_right"><code>CostructuredArrow.map_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-isSeparating_inverseImage_proj"><code>CostructuredArrow.isSeparating_inverseImage_proj</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_obj"><code>CostructuredArrow.proj_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_obj"><code>Functor.pointwiseLeftKanExtension_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_map"><code>Functor.pointwiseLeftKanExtension_map</code></a>, <a href="#CategoryTheory-IsCardinalAccessibleCategory-final_toCostructuredArrow"><code>IsCardinalAccessibleCategory.final_toCostructuredArrow</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_hom"><code>CostructuredArrow.preEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>CostructuredArrow.ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_left"><code>CostructuredArrow.mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-Functor-Initial-out"><code>Functor.Initial.out</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-map‚ÇÇ_snd"><code>OverPresheafAux.YonedaCollection.map‚ÇÇ_snd</code></a>, <a href="#CategoryTheory-Limits-Cone-equivCostructuredArrow_inverse"><code>Limits.Cone.equivCostructuredArrow_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_left"><code>CostructuredArrow.map_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta_hom_left"><code>CostructuredArrow.eta_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompPre"><code>CostructuredArrow.instEssSurjCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_counitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_inv_app"><code>Limits.Cocone.toCostructuredArrowCompToOverCompForget_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>CostructuredArrow.toStructuredArrow'_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_obj"><code>CostructuredArrow.prodInverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjOverToOver"><code>CostructuredArrow.instEssSurjOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitForward_val_snd"><code>OverPresheafAux.counitForward_val_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_post"><code>CostructuredArrow.initial_post</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-Functor-instIsEquivalenceRightExtensionPostcomp‚ÇÅOfIsIso"><code>Functor.instIsEquivalenceRightExtensionPostcomp‚ÇÅOfIsIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-hasColimitsOfSize"><code>CostructuredArrow.hasColimitsOfSize</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_counitIso"><code>TwoSquare.equivalenceJ_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-id_left"><code>CostructuredArrow.id_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_inverse"><code>CostructuredArrow.prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-OverPresheafAux-yonedaCollectionFunctor_obj"><code>OverPresheafAux.yonedaCollectionFunctor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_obj"><code>Functor.RightExtension.coneAtFunctor_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_hom"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_right"><code>CostructuredArrow.map_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-closedUnderLimitsOfShape_discrete_empty"><code>CostructuredArrow.closedUnderLimitsOfShape_discrete_empty</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-toCostructuredArrow_obj_right_as"><code>Limits.IndObjectPresentation.toCostructuredArrow_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_left</code></a>, <a href="#CategoryTheory-IsFinitelyAccessibleCategory-instIsFilteredCostructuredArrowFullSubcategoryIsFinitelyPresentableŒπ"><code>IsFinitelyAccessibleCategory.instIsFilteredCostructuredArrowFullSubcategoryIsFinitelyPresentableŒπ</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_obj_left_obj"><code>Functor.RightExtension.postcomp‚ÇÅ_obj_left_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_hom"><code>CostructuredArrow.mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-natTransInCostructuredArrow_app"><code>CostructuredArrow.CreatesConnected.natTransInCostructuredArrow_app</code></a>, <a href="#CategoryTheory-isCofiltered_costructuredArrow_of_isCofiltered_of_exists"><code>isCofiltered_costructuredArrow_of_isCofiltered_of_exists</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalence_counitIso"><code>CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_comp_proj"><code>Functor.toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalence_inverse"><code>CategoryOfElements.costructuredArrowYonedaEquivalence_inverse</code></a>, <a href="#CategoryTheory-Limits-isIndObject_iff"><code>Limits.isIndObject_iff</code></a>, <a href="#CategoryTheory-Presheaf-final_toCostructuredArrow_comp_pre"><code>Presheaf.final_toCostructuredArrow_comp_pre</code></a>, <a href="#CategoryTheory-TwoSquare-instFinalCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact"><code>TwoSquare.instFinalCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>CostructuredArrow.proj_faithful</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_inv_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_inv_app_left"><code>CostructuredArrow.mapNatIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitAuxAux_inv"><code>OverPresheafAux.counitAuxAux_inv</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtensionUnit_app"><code>Functor.pointwiseLeftKanExtensionUnit_app</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>RepresentablyCoflat.filtered</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_hom_app_left"><code>CostructuredArrow.mapIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-Limits-IsIndObject-finallySmall"><code>Limits.IsIndObject.finallySmall</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYonedaObj_map"><code>OverPresheafAux.restrictedYonedaObj_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_homMk"><code>CostructuredArrow.epi_homMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_inv_app"><code>CostructuredArrow.mapCompŒπCompGrothendieckProj_inv_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_functor_obj"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompPre"><code>CostructuredArrow.instFullCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-isSeparating_proj_preimage"><code>CostructuredArrow.isSeparating_proj_preimage</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_left"><code>CostructuredArrow.toOver_map_left</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone'_pt"><code>Presheaf.tautologicalCocone'_pt</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_preservesFiniteLimits"><code>lan_preservesFiniteLimits_of_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta_inv_left"><code>CostructuredArrow.eta_inv_left</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-functorToInterchangeIso_hom_app_app"><code>Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_hom_app_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompObjPost"><code>CostructuredArrow.instFaithfulCompObjPost</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_obj"><code>TwoSquare.costructuredArrowDownwardsPrecomp_obj</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromCostructuredArrow_obj_snd"><code>CategoryOfElements.fromCostructuredArrow_obj_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-faithful_map‚ÇÇ"><code>CostructuredArrow.faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_right"><code>CostructuredArrow.mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-functor_map"><code>CostructuredArrow.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>StructuredArrow.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitBackward_counitForward"><code>OverPresheafAux.counitBackward_counitForward</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_functor_map"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_left"><code>CostructuredArrow.mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>CostructuredArrow.costructuredArrowToOverEquivalence.functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_right"><code>CostructuredArrow.map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-toCostructuredArrow_obj_left"><code>Limits.IndObjectPresentation.toCostructuredArrow_obj_left</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_inverse"><code>TwoSquare.equivalenceJ_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_pt"><code>Limits.Cocone.toOver_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_right"><code>CostructuredArrow.pre_obj_right</code></a>, <a href="#CategoryTheory-Limits-isFiltered_costructuredArrow_yoneda_of_preservesFiniteLimits"><code>Limits.isFiltered_costructuredArrow_yoneda_of_preservesFiniteLimits</code></a>, <a href="#Condensed-lanPresheafNatIso_hom_app"><code>Condensed.lanPresheafNatIso_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-raiseCone_pt"><code>CostructuredArrow.CreatesConnected.raiseCone_pt</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-toCostructuredArrow_map_left"><code>Limits.IndObjectPresentation.toCostructuredArrow_map_left</code></a>, <a href="#CategoryTheory-Functor-RightExtension-precomp_obj_right"><code>Functor.RightExtension.precomp_obj_right</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-isoAux_hom_app"><code>Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.isoAux_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>CostructuredArrow.toStructuredArrow'_map</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_hom_assoc"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom_assoc</code></a>, <a href="#CategoryTheory-Limits-Cone-toCostructuredArrow_map"><code>Limits.Cone.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_inv_assoc"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>CostructuredArrow.prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-full_map‚ÇÇ"><code>CostructuredArrow.full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_Œπ_app"><code>Limits.Cocone.toCostructuredArrowCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Limits-isFiltered_costructuredArrow_yoneda_iff_nonempty_preservesFiniteLimits"><code>Limits.isFiltered_costructuredArrow_yoneda_iff_nonempty_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-Functor-initial_iff_isCofiltered_costructuredArrow"><code>Functor.initial_iff_isCofiltered_costructuredArrow</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_hom"><code>CostructuredArrow.mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_map_left_app"><code>Functor.RightExtension.postcomp‚ÇÅ_map_left_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_of_epi_left"><code>CostructuredArrow.epi_of_epi_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mono_of_mono_left"><code>CostructuredArrow.mono_of_mono_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>CostructuredArrow.ofCommaFstEquivalence_functor</code></a>, <a href="#Condensed-instFinalOppositeDiscreteQuotientCarrierToTopTotallyDisconnectedSpaceCostructuredArrowFintypeCatProfiniteOpToProfiniteOpPtAsLimitConeFunctorOp"><code>Condensed.instFinalOppositeDiscreteQuotientCarrierToTopTotallyDisconnectedSpaceCostructuredArrowFintypeCatProfiniteOpToProfiniteOpPtAsLimitConeFunctorOp</code></a>, <a href="#CategoryTheory-Functor-isDenseAt_iff"><code>Functor.isDenseAt_iff</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_obj"><code>Functor.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_counitIso"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_obj"><code>Functor.LeftExtension.coconeAtFunctor_obj</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-toCostructuredArrow_obj_hom"><code>Limits.IndObjectPresentation.toCostructuredArrow_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_obj"><code>CostructuredArrow.prodFunctor_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_hom_hom"><code>Functor.LeftExtension.coconeAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitAux_hom"><code>OverPresheafAux.counitAux_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_hom_app_left"><code>CostructuredArrow.mapNatIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromCostructuredArrow_map_coe"><code>CategoryOfElements.fromCostructuredArrow_map_coe</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_map"><code>CostructuredArrow.proj_map</code></a>, <a href="#CategoryTheory-TwoSquare-GuitartExact-isConnected_rightwards"><code>TwoSquare.GuitartExact.isConnected_rightwards</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_map_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_map_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_left</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-flipFunctorToInterchange_inv_app_app"><code>Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_inv_app_app</code></a>, <a href="#LightProfinite-Extend-functorOp_map"><code>LightProfinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-comp_left"><code>CostructuredArrow.comp_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-unitAuxAux_inv_app_fst"><code>OverPresheafAux.unitAuxAux_inv_app_fst</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowCompPreOfRepresentablyCoflat"><code>instInitialCostructuredArrowCompPreOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-OverPresheafAux-unitAuxAux_inv_app_snd_coe"><code>OverPresheafAux.unitAuxAux_inv_app_snd_coe</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompObjPostOfFull"><code>CostructuredArrow.instEssSurjCompObjPostOfFull</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_comp"><code>CostructuredArrow.homMk'_mk_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-preFunctor_app"><code>CostructuredArrow.preFunctor_app</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_unitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_map"><code>CostructuredArrow.prodInverse_map</code></a>, <a href="#CategoryTheory-Limits-Cone-equivCostructuredArrow_functor"><code>Limits.Cone.equivCostructuredArrow_functor</code></a>, <a href="#CategoryTheory-Functor-PreservesPointwiseRightKanExtensionAt-preserves"><code>Functor.PreservesPointwiseRightKanExtensionAt.preserves</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompPre"><code>CostructuredArrow.instFaithfulCompPre</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrow_yoneda_equivalence_naturality"><code>CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>CostructuredArrow.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromCostructuredArrow_pt"><code>Limits.Cocone.fromCostructuredArrow_pt</code></a>, <a href="#CategoryTheory-instIsFilteredCostructuredArrowCompOfRepresentablyCoflat"><code>instIsFilteredCostructuredArrowCompOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYonedaObj_obj"><code>OverPresheafAux.restrictedYonedaObj_obj</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsCostructuredArrowCostructuredArrowObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsCostructuredArrowCostructuredArrowObjOfRespectsIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-raiseCone_œÄ_app"><code>CostructuredArrow.CreatesConnected.raiseCone_œÄ_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalence_unitIso"><code>CategoryOfElements.costructuredArrowYonedaEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_left"><code>CostructuredArrow.mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_inv_left"><code>CostructuredArrow.isoMk_inv_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYonedaObjMap‚ÇÅ_app"><code>OverPresheafAux.restrictedYonedaObjMap‚ÇÅ_app</code></a>, <a href="#CategoryTheory-flat_iff_lan_flat"><code>flat_iff_lan_flat</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_obj_right"><code>Functor.RightExtension.postcomp‚ÇÅ_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>CostructuredArrow.ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom"><code>Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-hasLimitsOfShape_of_isConnected"><code>CostructuredArrow.hasLimitsOfShape_of_isConnected</code></a>, <a href="#CategoryTheory-CategoryOfElements-toCostructuredArrow_obj"><code>CategoryOfElements.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-OverPresheafAux-yonedaCollectionFunctor_map"><code>OverPresheafAux.yonedaCollectionFunctor_map</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_map"><code>TwoSquare.costructuredArrowDownwardsPrecomp_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-isConnected"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.isConnected</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-mk_snd"><code>OverPresheafAux.YonedaCollection.mk_snd</code></a>, <a href="#CategoryTheory-lan_flat_of_flat"><code>lan_flat_of_flat</code></a>, <a href="#CategoryTheory-Limits-Cone-equivCostructuredArrow_counitIso"><code>Limits.Cone.equivCostructuredArrow_counitIso</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_hom_app"><code>Limits.Cocone.toCostructuredArrowCompToOverCompForget_hom_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_obj_hom_app"><code>Functor.RightExtension.postcompose‚ÇÇ_obj_hom_app</code></a>, <a href="#CategoryTheory-ObjectProperty-ColimitOfShape-toCostructuredArrow_map"><code>ObjectProperty.ColimitOfShape.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-Functor-RightExtension-precomp_obj_hom_app"><code>Functor.RightExtension.precomp_obj_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_right"><code>CostructuredArrow.mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Functor-RightExtension-precomp_map_right"><code>Functor.RightExtension.precomp_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_left"><code>CostructuredArrow.map_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_left"><code>CostructuredArrow.map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceFunctorProj_hom_app"><code>CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇObjMkIso_inv_left_app"><code>Functor.RightExtension.postcompose‚ÇÇObjMkIso_inv_left_app</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-map‚ÇÅ_comp"><code>OverPresheafAux.YonedaCollection.map‚ÇÅ_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_left"><code>CostructuredArrow.preEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_map_left_app"><code>Functor.RightExtension.postcompose‚ÇÇ_map_left_app</code></a>, <a href="#Profinite-Extend-functorOp_final"><code>Profinite.Extend.functorOp_final</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_obj_left_obj"><code>Functor.RightExtension.postcompose‚ÇÇ_obj_left_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_mk"><code>CostructuredArrow.map_mk</code></a>, <a href="#LightCondensed-lanPresheafNatIso_hom_app"><code>LightCondensed.lanPresheafNatIso_hom_app</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_obj"><code>TwoSquare.EquivalenceJ.functor_obj</code></a>, <a href="#CategoryTheory-TwoSquare-isConnected_rightwards_iff_downwards"><code>TwoSquare.isConnected_rightwards_iff_downwards</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_inverse_obj"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_inverse_obj</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇ_map_right"><code>Functor.RightExtension.postcompose‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-Limits-Cone-fromCostructuredArrow_obj_pt"><code>Limits.Cone.fromCostructuredArrow_obj_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-essentiallySmall"><code>CostructuredArrow.essentiallySmall</code></a>, <a href="#LightProfinite-Extend-cocone_pt"><code>LightProfinite.Extend.cocone_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_hom_app_left"><code>CostructuredArrow.mapNatIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_obj"><code>Limits.Cocone.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-comp_homEquiv_symm"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.comp_homEquiv_symm</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_inv_hom"><code>Limits.Cocone.mapCoconeToOver_inv_hom</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAt_pt"><code>Functor.LeftExtension.coconeAt_pt</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_map"><code>Functor.toCostructuredArrow_map</code></a>, <a href="#Profinite-Extend-cocone_Œπ_app"><code>Profinite.Extend.cocone_Œπ_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_map_hom"><code>Functor.RightExtension.coneAtFunctor_map_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompObjPostOfFaithful"><code>CostructuredArrow.instFullCompObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_hom_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_functor"><code>CostructuredArrow.prodEquivalence_functor</code></a>, <a href="#CategoryTheory-ObjectProperty-isFiltered_costructuredArrow_colimitsCardinalClosure_Œπ"><code>ObjectProperty.isFiltered_costructuredArrow_colimitsCardinalClosure_Œπ</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_comp"><code>CostructuredArrow.homMk'_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>CostructuredArrow.ofDiagEquivalence.inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_hom_app"><code>CostructuredArrow.mapCompŒπCompGrothendieckProj_hom_app</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-map‚ÇÅ_id"><code>OverPresheafAux.YonedaCollection.map‚ÇÅ_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>CostructuredArrow.eqToHom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_right"><code>CostructuredArrow.mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-hasColimit"><code>CostructuredArrow.hasColimit</code></a>, <a href="#LightCondensed-lanPresheafExt_inv"><code>LightCondensed.lanPresheafExt_inv</code></a>, <a href="#Condensed-lanPresheafExt_hom"><code>Condensed.lanPresheafExt_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_left"><code>CostructuredArrow.mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_isConnected_rightwards"><code>TwoSquare.guitartExact_iff_isConnected_rightwards</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left"><code>Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone_Œπ_app"><code>Presheaf.tautologicalCocone_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_right"><code>CostructuredArrow.pre_map_right</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone'_Œπ_app"><code>Presheaf.tautologicalCocone'_Œπ_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceInverseœÄ_inv_app"><code>CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-hasColimitsOfShape"><code>CostructuredArrow.hasColimitsOfShape</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>CostructuredArrow.ofCommaFstEquivalence_unitIso</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>CostructuredArrow.costructuredArrowToOverEquivalence.inverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompProj_inv_app"><code>Limits.Cocone.toCostructuredArrowCompProj_inv_app</code></a>, <a href="#LightCondensed-instFinalNatCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteOpPtAsLimitConeFunctorOp"><code>LightCondensed.instFinalNatCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteOpPtAsLimitConeFunctorOp</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_inv"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv</code></a>, <a href="#CategoryTheory-Limits-Cone-equivCostructuredArrow_unitIso"><code>Limits.Cone.equivCostructuredArrow_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_right"><code>CostructuredArrow.mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mono_homMk"><code>CostructuredArrow.mono_homMk</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromCostructuredArrow_obj_mk"><code>CategoryOfElements.fromCostructuredArrow_obj_mk</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_functor"><code>TwoSquare.equivalenceJ_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_hom_left"><code>CostructuredArrow.preEquivalence.inverse_obj_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_map_left"><code>CostructuredArrow.preEquivalence.functor_map_left</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcomp‚ÇÅ_obj_hom_app"><code>Functor.RightExtension.postcomp‚ÇÅ_obj_hom_app</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_hom"><code>Functor.Œπ_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_toOver"><code>CostructuredArrow.isEquivalence_toOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-isClosedUnderColimitsOfShape"><code>CostructuredArrow.isClosedUnderColimitsOfShape</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_naturality_right_assoc"><code>Presheaf.restrictedULiftYonedaHomEquiv'_symm_naturality_right_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_right_as"><code>CostructuredArrow.preEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_pt"><code>Limits.Cocone.toCostructuredArrowCocone_pt</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAt_Œπ_app"><code>Functor.LeftExtension.coconeAt_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-IsUniversal-uniq"><code>CostructuredArrow.IsUniversal.uniq</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_final"><code>TwoSquare.guitartExact_iff_final</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-isFiltered"><code>Limits.IndizationClosedUnderFilteredColimitsAux.isFiltered</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_obj"><code>TwoSquare.EquivalenceJ.inverse_obj</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc"><code>Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>CostructuredArrow.preEquivalence.inverse_map_left_left</code></a>, <a href="#LightCondensed-instHasColimitsOfShapeCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteType"><code>LightCondensed.instHasColimitsOfShapeCostructuredArrowOppositeFintypeCatLightProfiniteOpToLightProfiniteType</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitForward_counitBackward"><code>OverPresheafAux.counitForward_counitBackward</code></a>, <a href="#CategoryTheory-OverPresheafAux-costructuredArrowPresheafToOver_obj"><code>OverPresheafAux.costructuredArrowPresheafToOver_obj</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_colimit"><code>Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_colimit</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_map‚ÇÇ_id"><code>CostructuredArrow.initial_map‚ÇÇ_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_left"><code>CostructuredArrow.pre_map_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_hom_hom"><code>Limits.Cocone.mapCoconeToOver_hom_hom</code></a>, <a href="#CategoryTheory-Functor-SmallCategories-instPreservesFiniteLimitsSheafSheafPullbackOfRepresentablyFlat"><code>Functor.SmallCategories.instPreservesFiniteLimitsSheafSheafPullbackOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_obj"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_obj</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-flipFunctorToInterchange_hom_app_app"><code>Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_hom_app_app</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-map‚ÇÅ_snd"><code>OverPresheafAux.YonedaCollection.map‚ÇÅ_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_right"><code>CostructuredArrow.mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc"><code>Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_hom"><code>CostructuredArrow.mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_comp"><code>CostructuredArrow.mkPrecomp_comp</code></a>, <a href="#CategoryTheory-IsCardinalAccessibleCategory-instIsCardinalFilteredCostructuredArrowFullSubcategoryIsCardinalPresentableŒπ"><code>IsCardinalAccessibleCategory.instIsCardinalFilteredCostructuredArrowFullSubcategoryIsCardinalPresentableŒπ</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_isConnected_downwards"><code>TwoSquare.guitartExact_iff_isConnected_downwards</code></a>, <a href="#LightCondensed-lanPresheafExt_hom"><code>LightCondensed.lanPresheafExt_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_iff_epi_left"><code>CostructuredArrow.epi_iff_epi_left</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>StructuredArrow.toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-Limits-colimit-toCostructuredArrow_map"><code>Limits.colimit.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_right_as"><code>CostructuredArrow.preEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_proj_of_isCofiltered"><code>CostructuredArrow.initial_proj_of_isCofiltered</code></a>, <a href="#CategoryTheory-CostructuredArrow-unop_left_comp_underlyingIso_hom_unop"><code>CostructuredArrow.unop_left_comp_underlyingIso_hom_unop</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_right"><code>CostructuredArrow.mapIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>StructuredArrow.toCostructuredArrow'_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-instIsCofilteredCostructuredArrowProdDiagOfIsCofilteredOrEmpty"><code>instIsCofilteredCostructuredArrowProdDiagOfIsCofilteredOrEmpty</code></a>, <a href="#CategoryTheory-Limits-colimit-toCostructuredArrow_obj"><code>Limits.colimit.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-well_copowered_costructuredArrow"><code>CostructuredArrow.well_copowered_costructuredArrow</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_id"><code>CostructuredArrow.map_id</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone_pt"><code>Presheaf.tautologicalCocone_pt</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_functor"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_functor</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_hom_assoc"><code>Functor.Œπ_leftKanExtensionObjIsoColimit_hom_assoc</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_pt"><code>Limits.colimit.toOver_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_left"><code>CostructuredArrow.mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-map_mkPrecomp_eqToHom"><code>OverPresheafAux.map_mkPrecomp_eqToHom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_hom"><code>CostructuredArrow.map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_desc_app"><code>Functor.pointwiseLeftKanExtension_desc_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_inverse_map"><code>CategoryOfElements.costructuredArrowULiftYonedaEquivalence_inverse_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_left"><code>CostructuredArrow.map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowRightwards_obj"><code>TwoSquare.costructuredArrowRightwards_obj</code></a>, <a href="#CategoryTheory-ObjectProperty-isCardinalFiltered_costructuredArrow_colimitsCardinalClosure_Œπ"><code>ObjectProperty.isCardinalFiltered_costructuredArrow_colimitsCardinalClosure_Œπ</code></a>, <a href="#CategoryTheory-Functor-Œπ_colimitIsoColimitGrothendieck_inv"><code>Functor.Œπ_colimitIsoColimitGrothendieck_inv</code></a>, <a href="#CategoryTheory-NonemptyParallelPairPresentationAux-hg"><code>NonemptyParallelPairPresentationAux.hg</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitAuxAux_hom"><code>OverPresheafAux.counitAuxAux_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_pre"><code>CostructuredArrow.initial_pre</code></a>, <a href="#CategoryTheory-Functor-RightExtension-postcompose‚ÇÇObjMkIso_hom_left_app"><code>Functor.RightExtension.postcompose‚ÇÇObjMkIso_hom_left_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-projectQuotient_mk"><code>CostructuredArrow.projectQuotient_mk</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_naturality_right"><code>Presheaf.restrictedULiftYonedaHomEquiv'_symm_naturality_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_left"><code>CostructuredArrow.preEquivalence.functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>CostructuredArrow.toStructuredArrow_map</code></a>, <a href="#LightProfinite-Extend-functorOp_final"><code>LightProfinite.Extend.functorOp_final</code></a>, <a href="#Condensed-lanPresheafIso_hom"><code>Condensed.lanPresheafIso_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_post"><code>CostructuredArrow.isEquivalence_post</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromCostructuredArrow_obj_fst"><code>CategoryOfElements.fromCostructuredArrow_obj_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>CostructuredArrow.costructuredArrowToOverEquivalence.inverse_map</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_left_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_left_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_inv_app_left"><code>CostructuredArrow.mapIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_hom_left"><code>CostructuredArrow.isoMk_hom_left</code></a>, <a href="#CategoryTheory-Functor-costructuredArrowMapCocone_Œπ_app"><code>Functor.costructuredArrowMapCocone_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-instPreservesLimitsOfShapeProjOfIsConnected"><code>CostructuredArrow.instPreservesLimitsOfShapeProjOfIsConnected</code></a>, <a href="#CategoryTheory-CategoryOfElements-toCostructuredArrow_map"><code>CategoryOfElements.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceFunctorProj_inv_app"><code>CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>StructuredArrow.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-comp_homEquiv_symm_assoc"><code>Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.comp_homEquiv_symm_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_hom"><code>CostructuredArrow.preEquivalence.inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-small_inverseImage_proj_of_locallySmall"><code>CostructuredArrow.small_inverseImage_proj_of_locallySmall</code></a>, <a href="#CategoryTheory-CostructuredArrow-locallySmall"><code>CostructuredArrow.locallySmall</code></a>, <a href="#CategoryTheory-Functor-RightExtension-precomp_obj_left"><code>Functor.RightExtension.precomp_obj_left</code></a>, <a href="#CategoryTheory-Functor-instIsEquivalenceRightExtensionCompPrecomp"><code>Functor.instIsEquivalenceRightExtensionCompPrecomp</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_left"><code>CostructuredArrow.mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-OverPresheafAux-counitForward_naturality‚ÇÇ"><code>OverPresheafAux.counitForward_naturality‚ÇÇ</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L44" id="CategoryTheory-instCategoryStructuredArrow"><code>instCategoryStructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.instCategoryStructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>381 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_map_hom"><code>Functor.LeftExtension.coconeAtFunctor_map_hom</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_hom_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_hom_right</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_map"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map</code></a>, <a href="#CategoryTheory-TwoSquare-instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact"><code>TwoSquare.instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_pt"><code>Limits.Cone.toUnder_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-final_pre"><code>StructuredArrow.final_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-projectSubobject_mk"><code>StructuredArrow.projectSubobject_mk</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>StructuredArrow.instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_right"><code>StructuredArrow.map_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_inv_right"><code>StructuredArrow.isoMk_inv_right</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact"><code>TwoSquare.instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-StructuredArrow-map_comp"><code>StructuredArrow.map_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_obj"><code>Functor.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_functor_map_left"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_functor_map_left</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_obj_hom_app"><code>Functor.LeftExtension.precomp‚ÇÇ_obj_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-Limits-limit-toStructuredArrow_obj"><code>Limits.limit.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_right"><code>StructuredArrow.map_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_left"><code>StructuredArrow.mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromStructuredArrow_map"><code>CategoryOfElements.fromStructuredArrow_map</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-whiskering_map"><code>Bicategory.LeftLift.whiskering_map</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_map_right"><code>Functor.LeftExtension.precomp‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_map"><code>StructuredArrow.commaMapEquivalenceInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>StructuredArrow.ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_hom"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_hom</code></a>, <a href="#Profinite-Extend-functorOp_map"><code>Profinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_comp"><code>StructuredArrow.homMk'_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>StructuredArrow.ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map"><code>StructuredArrow.final_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_functor"><code>CategoryOfElements.structuredArrowEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimit"><code>StructuredArrow.hasLimit</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_inverse"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_hom"><code>StructuredArrow.mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>StructuredArrow.toUnder_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-uniq"><code>StructuredArrow.IsUniversal.uniq</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_lift_app"><code>Functor.pointwiseRightKanExtension_lift_app</code></a>, <a href="#CondensedMod-isDiscrete_tfae"><code>CondensedMod.isDiscrete_tfae</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_map_right_app"><code>Functor.LeftExtension.postcomp‚ÇÅ_map_right_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_right"><code>StructuredArrow.map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_left_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_hom_app_left_right</code></a>, <a href="#Profinite-Extend-cone_œÄ_app"><code>Profinite.Extend.cone_œÄ_app</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_left"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_left</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_right"><code>StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_pt"><code>Functor.RightExtension.coneAt_pt</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_obj_left"><code>Functor.LeftExtension.postcomp‚ÇÅ_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_right"><code>StructuredArrow.map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_right_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>StructuredArrow.preEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact"><code>TwoSquare.instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp_map_right"><code>Functor.LeftExtension.precomp_map_right</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_obj_left"><code>Functor.LeftExtension.precomp‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>StructuredArrow.proj_faithful</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_œÄ_app"><code>Functor.RightExtension.coneAt_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_right"><code>StructuredArrow.mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_hom_right"><code>StructuredArrow.eta_hom_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_right</code></a>, <a href="#CategoryTheory-Limits-limit-toStructuredArrow_map"><code>Limits.limit.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_unitIso"><code>TwoSquare.equivalenceJ_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_reflectsIsomorphisms"><code>StructuredArrow.proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_map"><code>StructuredArrow.prodInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_inv_right"><code>StructuredArrow.eta_inv_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_inv_app"><code>Limits.Cone.toStructuredArrowCompProj_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>StructuredArrow.instEssSurjCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_right</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp_obj_hom_app"><code>Functor.LeftExtension.precomp_obj_hom_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-to_comma_map_right"><code>CategoryOfElements.to_comma_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>StructuredArrow.instEssSurjObjCompPostOfFull</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_initial"><code>TwoSquare.guitartExact_iff_initial</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_inv_hom"><code>Functor.LeftExtension.coconeAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_œÄ_app"><code>Limits.Cone.fromStructuredArrow_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-id_right"><code>StructuredArrow.id_right</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map‚ÇÇ_id"><code>StructuredArrow.final_map‚ÇÇ_id</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>StructuredArrow.preEquivalenceFunctor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_left"><code>StructuredArrow.map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>StructuredArrow.preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_counitIso"><code>CategoryOfElements.structuredArrowEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_obj_right_map"><code>Functor.LeftExtension.postcompose‚ÇÇ_obj_right_map</code></a>, <a href="#CategoryTheory-StructuredArrow-functor_map"><code>StructuredArrow.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>StructuredArrow.ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_left"><code>StructuredArrow.map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>StructuredArrow.ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-whiskering_map"><code>Bicategory.LeftExtension.whiskering_map</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_pre"><code>StructuredArrow.isEquivalence_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_map"><code>StructuredArrow.prodFunctor_map</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_inverse_map_left"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_inverse_map_left</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-final_post"><code>StructuredArrow.final_post</code></a>, <a href="#CategoryTheory-Functor-Final-out"><code>Functor.Final.out</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>StructuredArrow.prodEquivalence_functor</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_left"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_hom"><code>StructuredArrow.mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_right"><code>StructuredArrow.mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_right"><code>StructuredArrow.mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>StructuredArrow.prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-full_map‚ÇÇ"><code>StructuredArrow.full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-isFiltered_structuredArrow_of_isFiltered_of_exists"><code>isFiltered_structuredArrow_of_isFiltered_of_exists</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_right"><code>StructuredArrow.mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_left"><code>StructuredArrow.mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_counitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CategoryOfElements-toStructuredArrow_obj"><code>CategoryOfElements.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>StructuredArrow.preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>StructuredArrow.preEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>CostructuredArrow.toStructuredArrow'_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_pt"><code>Limits.Cone.fromStructuredArrow_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_comp"><code>StructuredArrow.homMk'_mk_comp</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇObjMkIso_inv_right_app"><code>Functor.LeftExtension.postcompose‚ÇÇObjMkIso_inv_right_app</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_counitIso"><code>TwoSquare.equivalenceJ_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_hom_app_right"><code>StructuredArrow.mapNatIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>StructuredArrow.eqToHom_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_obj"><code>Functor.RightExtension.coneAtFunctor_obj</code></a>, <a href="#CategoryTheory-Bicategory-Lan-CommuteWith-lanCompIsoWhisker_hom_right"><code>Bicategory.Lan.CommuteWith.lanCompIsoWhisker_hom_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_map"><code>Functor.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_map_right_app"><code>Functor.LeftExtension.postcompose‚ÇÇ_map_right_app</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>StructuredArrow.instFaithfulObjCompPost</code></a>, <a href="#CategoryTheory-StructuredArrow-small_inverseImage_proj_of_locallySmall"><code>StructuredArrow.small_inverseImage_proj_of_locallySmall</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_œÄ_app"><code>Limits.Cone.toStructuredArrowCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_iff_mono_right"><code>StructuredArrow.mono_iff_mono_right</code></a>, <a href="#CategoryTheory-Functor-instIsEquivalenceLeftExtensionPostcomp‚ÇÅOfIsIso"><code>Functor.instIsEquivalenceLeftExtensionPostcomp‚ÇÅOfIsIso</code></a>, <a href="#CategoryTheory-Limits-Cocone-toStructuredArrow_obj"><code>Limits.Cocone.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_homMk"><code>StructuredArrow.epi_homMk</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_obj_hom_app"><code>Functor.LeftExtension.postcompose‚ÇÇ_obj_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>StructuredArrow.isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-instFinalStructuredArrowCompPreOfRepresentablyFlat"><code>instFinalStructuredArrowCompPreOfRepresentablyFlat</code></a>, <a href="#LightProfinite-Extend-functor_map"><code>LightProfinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_inv_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_obj_hom_app"><code>Functor.LeftExtension.postcomp‚ÇÅ_obj_hom_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromStructuredArrow_obj"><code>CategoryOfElements.fromStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_unitIso"><code>Limits.Cocone.equivStructuredArrow_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_comp"><code>StructuredArrow.mkPostcomp_comp</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_inverse_map_right"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_hom_right"><code>StructuredArrow.isoMk_hom_right</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_obj"><code>TwoSquare.costructuredArrowDownwardsPrecomp_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_obj_right_obj"><code>Functor.LeftExtension.postcompose‚ÇÇ_obj_right_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>StructuredArrow.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimitsOfShape"><code>StructuredArrow.hasLimitsOfShape</code></a>, <a href="#CategoryTheory-Functor-final_iff_isFiltered_structuredArrow"><code>Functor.final_iff_isFiltered_structuredArrow</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>StructuredArrow.toUnder_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_inverse"><code>TwoSquare.equivalenceJ_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalenceMap‚ÇÇ"><code>StructuredArrow.isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_obj_pt"><code>Limits.Cocone.fromStructuredArrow_obj_pt</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-IsKan-uniqueUpToIso_hom_right"><code>Bicategory.LeftExtension.IsKan.uniqueUpToIso_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_post"><code>StructuredArrow.isEquivalence_post</code></a>, <a href="#CategoryTheory-Bicategory-HasLeftKanLift-hasInitial"><code>Bicategory.HasLeftKanLift.hasInitial</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ_assoc"><code>Functor.ranObjObjIsoLimit_inv_œÄ_assoc</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_inverse"><code>CategoryOfElements.structuredArrowEquivalence_inverse</code></a>, <a href="#Profinite-Extend-functor_obj"><code>Profinite.Extend.functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>CostructuredArrow.toStructuredArrow'_map</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_right"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_right</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsStructuredArrowStructuredArrowObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsStructuredArrowStructuredArrowObjOfRespectsIso</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_obj"><code>StructuredArrow.commaMapEquivalenceInverse_obj</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÇ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_id"><code>StructuredArrow.homMk'_id</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_counitIso_inv_app_right_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_counitIso_inv_app_right_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>StructuredArrow.preEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>StructuredArrow.preEquivalenceInverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimitsOfSize"><code>StructuredArrow.hasLimitsOfSize</code></a>, <a href="#CategoryTheory-Bicategory-Lan-CommuteWith-lanCompIsoWhisker_inv_right"><code>Bicategory.Lan.CommuteWith.lanCompIsoWhisker_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_hom"><code>StructuredArrow.mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇObjMkIso_hom_right_app"><code>Functor.LeftExtension.postcompose‚ÇÇObjMkIso_hom_right_app</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_left"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-post_map"><code>StructuredArrow.post_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_left"><code>StructuredArrow.commaMapEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>StructuredArrow.instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_obj_right_map"><code>Functor.LeftExtension.postcomp‚ÇÅ_obj_right_map</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ_assoc"><code>Functor.ranObjObjIsoLimit_hom_œÄ_assoc</code></a>, <a href="#CategoryTheory-Functor-PreservesPointwiseLeftKanExtensionAt-preserves"><code>Functor.PreservesPointwiseLeftKanExtensionAt.preserves</code></a>, <a href="#CategoryTheory-isRightAdjoint_iff_hasInitial_structuredArrow"><code>isRightAdjoint_iff_hasInitial_structuredArrow</code></a>, <a href="#CategoryTheory-StructuredArrow-faithful_map‚ÇÇ"><code>StructuredArrow.faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_obj"><code>Functor.LeftExtension.coconeAtFunctor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_left"><code>StructuredArrow.pre_map_left</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_hom_hom"><code>Functor.LeftExtension.coconeAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-Functor-instIsEquivalenceLeftExtensionCompPrecomp"><code>Functor.instIsEquivalenceLeftExtensionCompPrecomp</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_hom_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_inverse_obj_hom_app</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÉ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÉ</code></a>, <a href="#CategoryTheory-TwoSquare-GuitartExact-isConnected_rightwards"><code>TwoSquare.GuitartExact.isConnected_rightwards</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_left"><code>StructuredArrow.map_map_left</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_map_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_map_left_right</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp_obj_right"><code>Functor.LeftExtension.precomp_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_right"><code>StructuredArrow.mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_inv_app_right"><code>StructuredArrow.mapIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_obj"><code>StructuredArrow.prodFunctor_obj</code></a>, <a href="#LightProfinite-Extend-functorOp_map"><code>LightProfinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_map"><code>StructuredArrow.proj_map</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_obj_left"><code>Functor.LeftExtension.postcompose‚ÇÇ_obj_left</code></a>, <a href="#Alexandrov-lowerCone_œÄ_app"><code>Alexandrov.lowerCone_œÄ_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp_obj_left"><code>Functor.LeftExtension.precomp_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_left"><code>StructuredArrow.mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_hom_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_unitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-comp_right"><code>StructuredArrow.comp_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_right"><code>StructuredArrow.commaMapEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-essentiallySmall"><code>StructuredArrow.essentiallySmall</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_hom_app"><code>Limits.Cone.toStructuredArrowCompProj_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_left"><code>StructuredArrow.map_obj_left</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtensionCounit_app"><code>Functor.pointwiseRightKanExtensionCounit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>CostructuredArrow.toStructuredArrow_obj</code></a>, <a href="#CondensedSet-isDiscrete_tfae"><code>CondensedSet.isDiscrete_tfae</code></a>, <a href="#CategoryTheory-Bicategory-instHasInitialLeftExtensionOfHasLeftKanExtension"><code>Bicategory.instHasInitialLeftExtensionOfHasLeftKanExtension</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-IsKan-uniqueUpToIso_inv_right"><code>Bicategory.LeftExtension.IsKan.uniqueUpToIso_inv_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_map_hom"><code>Limits.Cocone.fromStructuredArrow_map_hom</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_obj"><code>Functor.pointwiseRightKanExtension_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_hom_app_right"><code>StructuredArrow.mapNatIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_map"><code>TwoSquare.costructuredArrowDownwardsPrecomp_map</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-isConnected"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.isConnected</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcompose‚ÇÇ_map_left"><code>Functor.LeftExtension.postcompose‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_obj_right_obj"><code>Functor.LeftExtension.postcomp‚ÇÅ_obj_right_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>StructuredArrow.toUnder_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_right_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map_mk"><code>StructuredArrow.map_mk</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_obj"><code>Limits.Cone.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_homMk"><code>StructuredArrow.mono_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-whiskerOfIdCompIsoSelf_hom_right"><code>Bicategory.LeftLift.whiskerOfIdCompIsoSelf_hom_right</code></a>, <a href="#CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-Bicategory-HasLeftKanExtension-hasInitial"><code>Bicategory.HasLeftKanExtension.hasInitial</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>StructuredArrow.preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-Functor-Final-zigzag_of_eqvGen_colimitTypeRel"><code>Functor.Final.zigzag_of_eqvGen_colimitTypeRel</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_obj"><code>TwoSquare.EquivalenceJ.functor_obj</code></a>, <a href="#CategoryTheory-TwoSquare-isConnected_rightwards_iff_downwards"><code>TwoSquare.isConnected_rightwards_iff_downwards</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_hom_app_right"><code>StructuredArrow.mapIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ_assoc"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ_assoc</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp_map_left"><code>Functor.LeftExtension.precomp_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_right"><code>StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_inverse"><code>Limits.Cocone.equivStructuredArrow_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_right"><code>StructuredArrow.pre_map_right</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_obj_right"><code>Functor.LeftExtension.precomp‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_hom"><code>StructuredArrow.mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_inv_app_right"><code>StructuredArrow.mapNatIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ"><code>Functor.ranObjObjIsoLimit_hom_œÄ</code></a>, <a href="#Alexandrov-projSup_obj"><code>Alexandrov.projSup_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>StructuredArrow.instFaithfulCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-functor_obj"><code>StructuredArrow.functor_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_map"><code>Functor.pointwiseRightKanExtension_map</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-postcomp‚ÇÅ_map_left"><code>Functor.LeftExtension.postcomp‚ÇÅ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_of_mono_right"><code>StructuredArrow.mono_of_mono_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_map_hom"><code>Functor.RightExtension.coneAtFunctor_map_hom</code></a>, <a href="#Alexandrov-lowerCone_pt"><code>Alexandrov.lowerCone_pt</code></a>, <a href="#CategoryTheory-Limits-WalkingParallelPair-instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair"><code>Limits.WalkingParallelPair.instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_hom_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_right"><code>StructuredArrow.mapIso_inverse_map_right</code></a>, <a href="#Profinite-Extend-cone_pt"><code>Profinite.Extend.cone_pt</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_map"><code>TwoSquare.structuredArrowDownwards_map</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-whiskerOfCompIdIsoSelf_hom_right"><code>Bicategory.LeftExtension.whiskerOfCompIdIsoSelf_hom_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_unitIso"><code>CategoryOfElements.structuredArrowEquivalence_unitIso</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-IsKan-uniqueUpToIso_hom_right"><code>Bicategory.LeftLift.IsKan.uniqueUpToIso_hom_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_obj"><code>TwoSquare.structuredArrowDownwards_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_unitIso_hom_app_right_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_unitIso_hom_app_right_app</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_isConnected_rightwards"><code>TwoSquare.guitartExact_iff_isConnected_rightwards</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>StructuredArrow.prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_left"><code>StructuredArrow.mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_left"><code>StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>StructuredArrow.preEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_proj"><code>Limits.Cone.toStructuredArrow_comp_proj</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÅ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÅ</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>StructuredArrow.preEquivalenceInverse_obj_hom_right</code></a>, <a href="#CategoryTheory-Bicategory-instHasInitialLeftLiftOfHasLeftKanLift"><code>Bicategory.instHasInitialLeftLiftOfHasLeftKanLift</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#LightProfinite-Extend-functor_initial"><code>LightProfinite.Extend.functor_initial</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ"><code>Functor.ranObjObjIsoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_left"><code>StructuredArrow.mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_left"><code>StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_right"><code>StructuredArrow.mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_pt"><code>Functor.structuredArrowMapCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>StructuredArrow.ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_hom"><code>StructuredArrow.pre_obj_hom</code></a>, <a href="#CategoryTheory-Limits-Cocone-toStructuredArrow_map"><code>Limits.Cocone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-Bicategory-LanLift-CommuteWith-lanLiftCompIsoWhisker_inv_right"><code>Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker_inv_right</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_functor"><code>TwoSquare.equivalenceJ_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>StructuredArrow.toUnder_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_obj"><code>StructuredArrow.prodInverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_map"><code>Limits.Cone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>StructuredArrow.preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>StructuredArrow.preEquivalenceInverse_obj_left_as</code></a>, <a href="#LightProfinite-Extend-functor_obj"><code>LightProfinite.Extend.functor_obj</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-whiskerOfCompIdIsoSelf_inv_right"><code>Bicategory.LeftExtension.whiskerOfCompIdIsoSelf_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>StructuredArrow.preEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_obj"><code>StructuredArrow.proj_obj</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-IsKan-uniqueUpToIso_inv_right"><code>Bicategory.LeftLift.IsKan.uniqueUpToIso_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-essSurj_map‚ÇÇ"><code>StructuredArrow.essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_obj"><code>TwoSquare.EquivalenceJ.inverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_proj_preimage"><code>StructuredArrow.isCoseparating_proj_preimage</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_hom"><code>StructuredArrow.map_obj_hom</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_map_left"><code>Functor.LeftExtension.precomp‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-whiskering_obj"><code>Bicategory.LeftLift.whiskering_obj</code></a>, <a href="#CategoryTheory-ObjectProperty-LimitOfShape-toStructuredArrow_obj"><code>ObjectProperty.LimitOfShape.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>StructuredArrow.prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_left"><code>StructuredArrow.mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>StructuredArrow.instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_obj"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map_id"><code>StructuredArrow.map_id</code></a>, <a href="#CategoryTheory-ObjectProperty-LimitOfShape-toStructuredArrow_map"><code>ObjectProperty.LimitOfShape.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-locallySmall"><code>StructuredArrow.locallySmall</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullCompPre"><code>StructuredArrow.instFullCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-wellPowered_structuredArrow"><code>StructuredArrow.wellPowered_structuredArrow</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_isConnected_downwards"><code>TwoSquare.guitartExact_iff_isConnected_downwards</code></a>, <a href="#CategoryTheory-Bicategory-LeftExtension-whiskering_obj"><code>Bicategory.LeftExtension.whiskering_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>StructuredArrow.toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-StructuredArrow-post_obj"><code>StructuredArrow.post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>StructuredArrow.toCostructuredArrow'_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_counitIso_hom_app_right_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_counitIso_hom_app_right_app</code></a>, <a href="#CategoryTheory-Bicategory-LeftLift-whiskerOfIdCompIsoSelf_inv_right"><code>Bicategory.LeftLift.whiskerOfIdCompIsoSelf_inv_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_functor"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_functor</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_functor"><code>Limits.Cocone.equivStructuredArrow_functor</code></a>, <a href="#CategoryTheory-instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty"><code>instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_left"><code>StructuredArrow.mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_obj_Œπ"><code>Limits.Cocone.fromStructuredArrow_obj_Œπ</code></a>, <a href="#Profinite-Extend-functor_initial"><code>Profinite.Extend.functor_initial</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_counitIso"><code>Limits.Cocone.equivStructuredArrow_counitIso</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_pt"><code>Limits.Cone.toStructuredArrowCone_pt</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ_assoc"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>StructuredArrow.instFullObjCompPostOfFaithful</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_left_as</code></a>, <a href="#Profinite-Extend-functor_map"><code>Profinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>StructuredArrow.toUnder_obj_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>Functor.toStructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_left_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_inv_app_left_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_left"><code>StructuredArrow.mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_hom"><code>StructuredArrow.map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_inv_app_right"><code>StructuredArrow.mapNatIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_right"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_functor_map_right"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_inverseImage_proj"><code>StructuredArrow.isCoseparating_inverseImage_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>CostructuredArrow.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_unitIso_inv_app_right_app"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_unitIso_inv_app_right_app</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_id"><code>StructuredArrow.homMk'_mk_id</code></a>, <a href="#Alexandrov-projSup_map"><code>Alexandrov.projSup_map</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_left"><code>StructuredArrow.pre_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_of_epi_right"><code>StructuredArrow.epi_of_epi_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_left_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_id"><code>StructuredArrow.mkPostcomp_id</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_right_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_hom_app_right"><code>StructuredArrow.mapIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>StructuredArrow.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-final_proj_of_isFiltered"><code>StructuredArrow.final_proj_of_isFiltered</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_right"><code>StructuredArrow.mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>StructuredArrow.preEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_inv_app_right"><code>StructuredArrow.mapIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-Bicategory-LanLift-CommuteWith-lanLiftCompIsoWhisker_hom_right"><code>Bicategory.LanLift.CommuteWith.lanLiftCompIsoWhisker_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_hom"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_right"><code>StructuredArrow.pre_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-small_proj_preimage_of_locallySmall"><code>StructuredArrow.small_proj_preimage_of_locallySmall</code></a>, <a href="#CategoryTheory-Functor-leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_right"><code>Functor.leftExtensionEquivalenceOfIso‚ÇÅ_functor_obj_right</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_œÄ_app"><code>Functor.structuredArrowMapCone_œÄ_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L868" id="CategoryTheory-structuredArrowOpEquivalence"><code>structuredArrowOpEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.structuredArrowOpEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L702" id="CategoryTheory-CostructuredArrow-IsUniversal"><code>IsUniversal</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-IsRightKanExtension-nonempty_isUniversal"><code>CategoryTheory.Functor.IsRightKanExtension.nonempty_isUniversal</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L558" id="CategoryTheory-CostructuredArrow-eta"><code>eta</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.eta" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-eta_hom_left"><code>eta_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-eta_inv_left"><code>eta_inv_left</code></a>, <a href="#CategoryTheory-Limits-Cone-equivCostructuredArrow_counitIso"><code>CategoryTheory.Limits.Cone.equivCostructuredArrow_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L468" id="CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>33 math</summary><strong>math:</strong> <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_map"><code>CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map</code></a>, <a href="#CategoryTheory-OverPresheafAux-costructuredArrowPresheafToOver_map"><code>CategoryTheory.OverPresheafAux.costructuredArrowPresheafToOver_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_unitIso"><code>CategoryTheory.CategoryOfElements.costructuredArrowULiftYonedaEquivalence_unitIso</code></a>, <a href="#Profinite-Extend-functorOp_map"><code>Profinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_map"><code>CategoryTheory.Limits.Cocone.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-commaToGrothendieckPrecompFunctor_map_fiber"><code>commaToGrothendieckPrecompFunctor_map_fiber</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>costructuredArrowToOverEquivalence.functor_map</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowRightwards_map"><code>CategoryTheory.TwoSquare.costructuredArrowRightwards_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>CategoryTheory.StructuredArrow.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_functor_map"><code>CategoryTheory.CategoryOfElements.costructuredArrowULiftYonedaEquivalence_functor_map</code></a>, <a href="#CategoryTheory-Limits-Cone-toCostructuredArrow_map"><code>CategoryTheory.Limits.Cone.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_Œπ_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_Œπ_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_counitIso"><code>CategoryTheory.CategoryOfElements.costructuredArrowULiftYonedaEquivalence_counitIso</code></a>, <a href="#LightProfinite-Extend-functorOp_map"><code>LightProfinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk_left"><code>homMk_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_map"><code>prodInverse_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-raiseCone_œÄ_app"><code>CreatesConnected.raiseCone_œÄ_app</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_map"><code>CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_map</code></a>, <a href="#CategoryTheory-ObjectProperty-ColimitOfShape-toCostructuredArrow_map"><code>CategoryTheory.ObjectProperty.ColimitOfShape.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_map"><code>CategoryTheory.Functor.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_obj"><code>CategoryTheory.TwoSquare.EquivalenceJ.inverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>preEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>CategoryTheory.StructuredArrow.toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-Limits-colimit-toCostructuredArrow_map"><code>CategoryTheory.Limits.colimit.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>costructuredArrowToOverEquivalence.inverse_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-toCostructuredArrow_map"><code>CategoryTheory.CategoryOfElements.toCostructuredArrow_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L481" id="CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-homMk'_id"><code>homMk'_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_right"><code>homMk'_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_left"><code>homMk'_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a>, <a href="#CategoryTheory-CostructuredArrow-homMk'_comp"><code>homMk'_comp</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L517" id="CategoryTheory-CostructuredArrow-isoMk"><code>isoMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isoMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalence_counitIso"><code>CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowULiftYonedaEquivalence_counitIso"><code>CategoryTheory.CategoryOfElements.costructuredArrowULiftYonedaEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_inv_left"><code>isoMk_inv_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-isoMk_hom_left"><code>isoMk_hom_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L574" id="CategoryTheory-CostructuredArrow-map"><code>map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>20 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-map_comp"><code>map_comp</code></a>, <a href="#CategoryTheory-NonemptyParallelPairPresentationAux-hf"><code>CategoryTheory.NonemptyParallelPairPresentationAux.hf</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_map"><code>CategoryTheory.Functor.pointwiseLeftKanExtension_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_inv_app"><code>mapCompŒπCompGrothendieckProj_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-functor_map"><code>functor_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_Œπ_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-grothendieckProj_map"><code>grothendieckProj_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrow_yoneda_equivalence_naturality"><code>CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_mk"><code>map_mk</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_hom_app"><code>mapCompŒπCompGrothendieckProj_hom_app</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_pt"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_pt</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-map_id"><code>map_id</code></a>, <a href="#CategoryTheory-NonemptyParallelPairPresentationAux-hg"><code>CategoryTheory.NonemptyParallelPairPresentationAux.hg</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L595" id="CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>14 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_hom_app_left"><code>mapIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_unitIso_inv_app_left"><code>mapIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_hom_app_left"><code>mapIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_counitIso_inv_app_left"><code>mapIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L601" id="CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>14 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_inv_app_left"><code>mapNatIso_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_inv_app_left"><code>mapNatIso_counitIso_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_unitIso_hom_app_left"><code>mapNatIso_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_counitIso_hom_app_left"><code>mapNatIso_counitIso_hom_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L673" id="CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>10 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_map‚ÇÇ_id"><code>initial_map‚ÇÇ_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L986" id="CategoryTheory-CostructuredArrow-map‚ÇÇIsoPreEquivalenceInverseCompProj"><code>map‚ÇÇIsoPreEquivalenceInverseCompProj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇIsoPreEquivalenceInverseCompProj" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L428" id="CategoryTheory-CostructuredArrow-mk"><code>mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L615" id="CategoryTheory-CostructuredArrow-mkIdTerminal"><code>mkIdTerminal</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkIdTerminal" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L503" id="CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkPrecomp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_id"><code>mkPrecomp_id</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_left"><code>mkPrecomp_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_right"><code>mkPrecomp_right</code></a>, <a href="#CategoryTheory-OverPresheafAux-YonedaCollection-map‚ÇÇ_snd"><code>CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-mkPrecomp_comp"><code>mkPrecomp_comp</code></a>, <a href="#CategoryTheory-OverPresheafAux-map_mkPrecomp_eqToHom"><code>CategoryTheory.OverPresheafAux.map_mkPrecomp_eqToHom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L647" id="CategoryTheory-CostructuredArrow-post"><code>post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.post" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>9 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_post"><code>initial_post</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompObjPost"><code>instFaithfulCompObjPost</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompObjPostOfFull"><code>instEssSurjCompObjPostOfFull</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_obj"><code>CategoryTheory.TwoSquare.EquivalenceJ.functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompObjPostOfFaithful"><code>instFullCompObjPostOfFaithful</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L697" id="CategoryTheory-CostructuredArrow-postIsoMap‚ÇÇ"><code>postIsoMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.postIsoMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L627" id="CategoryTheory-CostructuredArrow-pre"><code>pre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>29 math</summary><strong>math:</strong> <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_hom_right"><code>CategoryTheory.TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_hom_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_right_as"><code>preEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowRightwards_map"><code>CategoryTheory.TwoSquare.costructuredArrowRightwards_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_left"><code>pre_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_hom"><code>preEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a>, <a href="#CategoryTheory-Presheaf-final_toCostructuredArrow_comp_pre"><code>CategoryTheory.Presheaf.final_toCostructuredArrow_comp_pre</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullCompPre"><code>instFullCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_obj_right"><code>pre_obj_right</code></a>, <a href="#CategoryTheory-Limits-IndObjectPresentation-toCostructuredArrow_map_left"><code>CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_map_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_Œπ_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_Œπ_app</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowCompPreOfRepresentablyCoflat"><code>CategoryTheory.instInitialCostructuredArrowCompPreOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-CostructuredArrow-preFunctor_app"><code>preFunctor_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_left"><code>preEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_right"><code>pre_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_hom_left"><code>preEquivalence.inverse_obj_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_map_left"><code>preEquivalence.functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_right_as"><code>preEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCocone_pt"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>preEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-pre_map_left"><code>pre_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_right_as"><code>preEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowRightwards_obj"><code>CategoryTheory.TwoSquare.costructuredArrowRightwards_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_pre"><code>initial_pre</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_left"><code>preEquivalence.functor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_hom"><code>preEquivalence.inverse_obj_left_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L975" id="CategoryTheory-CostructuredArrow-preEquivalence"><code>preEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1075" id="CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1058" id="CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1067" id="CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodInverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-prodInverse_map"><code>prodInverse_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L414" id="CategoryTheory-CostructuredArrow-proj"><code>proj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>107 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_map_hom"><code>CategoryTheory.Functor.LeftExtension.coconeAtFunctor_map_hom</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_iff_lan_preservesFiniteLimits"><code>CategoryTheory.preservesFiniteLimits_iff_lan_preservesFiniteLimits</code></a>, <a href="#LightCondensed-lanPresheafIso_hom"><code>LightCondensed.lanPresheafIso_hom</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceInverseœÄ_hom_app"><code>CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_hom_app</code></a>, <a href="#Profinite-Extend-cocone_pt"><code>Profinite.Extend.cocone_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>ofDiagEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>CategoryTheory.lan_preservesFiniteLimits_of_flat</code></a>, <a href="#CategoryTheory-CostructuredArrow-small_proj_preimage_of_locallySmall"><code>small_proj_preimage_of_locallySmall</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom"><code>CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-mapCone_raiseCone"><code>CreatesConnected.mapCone_raiseCone</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>ofCostructuredArrowProjEquivalence.inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_proj"><code>CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_inv"><code>CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_inv</code></a>, <a href="#LightProfinite-Extend-cocone_Œπ_app"><code>LightProfinite.Extend.cocone_Œπ_app</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-functorToInterchangeIso_inv_app_app"><code>CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_inv_app_app</code></a>, <a href="#Condensed-lanPresheafExt_inv"><code>Condensed.lanPresheafExt_inv</code></a>, <a href="#CategoryTheory-Functor-costructuredArrowMapCocone_pt"><code>CategoryTheory.Functor.costructuredArrowMapCocone_pt</code></a>, <a href="#CategoryTheory-Functor-Œπ_colimitIsoColimitGrothendieck_inv_assoc"><code>CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_inv_assoc</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromCostructuredArrow_Œπ_app"><code>CategoryTheory.Limits.Cocone.fromCostructuredArrow_Œπ_app</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_inv_hom"><code>CategoryTheory.Functor.LeftExtension.coconeAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompProj_hom_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompProj_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>ofCostructuredArrowProjEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_inv_assoc"><code>CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_inv_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ŒπCompGrothendieckProj_inv_app"><code>ŒπCompGrothendieckProj_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>ofCostructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-isSeparating_inverseImage_proj"><code>isSeparating_inverseImage_proj</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_obj"><code>proj_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_obj"><code>CategoryTheory.Functor.pointwiseLeftKanExtension_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_map"><code>CategoryTheory.Functor.pointwiseLeftKanExtension_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>ofCostructuredArrowProjEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_hom"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ŒπCompGrothendieckPrecompFunctorToCommaCompFst_inv_app"><code>ŒπCompGrothendieckPrecompFunctorToCommaCompFst_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-natTransInCostructuredArrow_app"><code>CreatesConnected.natTransInCostructuredArrow_app</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_comp_proj"><code>CategoryTheory.Functor.toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtensionUnit_app"><code>CategoryTheory.Functor.pointwiseLeftKanExtensionUnit_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_inv_app"><code>mapCompŒπCompGrothendieckProj_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-isSeparating_proj_preimage"><code>isSeparating_proj_preimage</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone'_pt"><code>CategoryTheory.Presheaf.tautologicalCocone'_pt</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_preservesFiniteLimits"><code>CategoryTheory.lan_preservesFiniteLimits_of_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-functorToInterchangeIso_hom_app_app"><code>CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_hom_app_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>ofCostructuredArrowProjEquivalence.functor_obj_left_right_as</code></a>, <a href="#Condensed-lanPresheafNatIso_hom_app"><code>Condensed.lanPresheafNatIso_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-raiseCone_pt"><code>CreatesConnected.raiseCone_pt</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-isoAux_hom_app"><code>CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.isoAux_hom_app</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_hom_assoc"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>ofCostructuredArrowProjEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_inv_assoc"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>ofCostructuredArrowProjEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-Functor-isDenseAt_iff"><code>CategoryTheory.Functor.isDenseAt_iff</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtFunctor_obj"><code>CategoryTheory.Functor.LeftExtension.coconeAtFunctor_obj</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAtWhiskerRightIso_hom_hom"><code>CategoryTheory.Functor.LeftExtension.coconeAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-proj_map"><code>proj_map</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-flipFunctorToInterchange_inv_app_app"><code>CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_inv_app_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>ofCostructuredArrowProjEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromCostructuredArrow_pt"><code>CategoryTheory.Limits.Cocone.fromCostructuredArrow_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>ofCostructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-CreatesConnected-raiseCone_œÄ_app"><code>CreatesConnected.raiseCone_œÄ_app</code></a>, <a href="#CategoryTheory-flat_iff_lan_flat"><code>CategoryTheory.flat_iff_lan_flat</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom"><code>CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-lan_flat_of_flat"><code>CategoryTheory.lan_flat_of_flat</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceFunctorProj_hom_app"><code>CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>ofCostructuredArrowProjEquivalence.functor_obj_left_left</code></a>, <a href="#LightCondensed-lanPresheafNatIso_hom_app"><code>LightCondensed.lanPresheafNatIso_hom_app</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionIsoFiberwiseColimit_hom_app"><code>CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_hom_app</code></a>, <a href="#LightProfinite-Extend-cocone_pt"><code>LightProfinite.Extend.cocone_pt</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-comp_homEquiv_symm"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.comp_homEquiv_symm</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAt_pt"><code>CategoryTheory.Functor.LeftExtension.coconeAt_pt</code></a>, <a href="#Profinite-Extend-cocone_Œπ_app"><code>Profinite.Extend.cocone_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>ofDiagEquivalence.inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-mapCompŒπCompGrothendieckProj_hom_app"><code>mapCompŒπCompGrothendieckProj_hom_app</code></a>, <a href="#LightCondensed-lanPresheafExt_inv"><code>LightCondensed.lanPresheafExt_inv</code></a>, <a href="#Condensed-lanPresheafExt_hom"><code>Condensed.lanPresheafExt_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ŒπCompGrothendieckPrecompFunctorToCommaCompFst_hom_app"><code>ŒπCompGrothendieckPrecompFunctorToCommaCompFst_hom_app</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone_Œπ_app"><code>CategoryTheory.Presheaf.tautologicalCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone'_Œπ_app"><code>CategoryTheory.Presheaf.tautologicalCocone'_Œπ_app</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceInverseœÄ_inv_app"><code>CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_inv_app</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompProj_inv_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompProj_inv_app</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-Œπ_isoColimit_inv"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_hom"><code>CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_naturality_right_assoc"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_naturality_right_assoc</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-coconeAt_Œπ_app"><code>CategoryTheory.Functor.LeftExtension.coconeAt_Œπ_app</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_app_naturality_left_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ŒπCompGrothendieckProj_hom_app"><code>ŒπCompGrothendieckProj_hom_app</code></a>, <a href="#CategoryTheory-Functor-SmallCategories-instPreservesFiniteLimitsSheafSheafPullbackOfRepresentablyFlat"><code>CategoryTheory.Functor.SmallCategories.instPreservesFiniteLimitsSheafSheafPullbackOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux-flipFunctorToInterchange_hom_app_app"><code>CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_hom_app_app</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc"><code>CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc</code></a>, <a href="#LightCondensed-lanPresheafExt_hom"><code>LightCondensed.lanPresheafExt_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-initial_proj_of_isCofiltered"><code>initial_proj_of_isCofiltered</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>ofCostructuredArrowProjEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-Presheaf-tautologicalCocone_pt"><code>CategoryTheory.Presheaf.tautologicalCocone_pt</code></a>, <a href="#CategoryTheory-Functor-Œπ_leftKanExtensionObjIsoColimit_hom_assoc"><code>CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_hom_assoc</code></a>, <a href="#CategoryTheory-Functor-pointwiseLeftKanExtension_desc_app"><code>CategoryTheory.Functor.pointwiseLeftKanExtension_desc_app</code></a>, <a href="#CategoryTheory-Functor-Œπ_colimitIsoColimitGrothendieck_inv"><code>CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_inv</code></a>, <a href="#CategoryTheory-MonoidalCategory-DayFunctor-Œ∑_comp_isoPointwiseLeftKanExtension_hom"><code>CategoryTheory.MonoidalCategory.DayFunctor.Œ∑_comp_isoPointwiseLeftKanExtension_hom</code></a>, <a href="#CategoryTheory-Functor-leftKanExtensionIsoFiberwiseColimit_inv_app"><code>CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_inv_app</code></a>, <a href="#CategoryTheory-Presheaf-restrictedULiftYonedaHomEquiv'_symm_naturality_right"><code>CategoryTheory.Presheaf.restrictedULiftYonedaHomEquiv'_symm_naturality_right</code></a>, <a href="#Condensed-lanPresheafIso_hom"><code>Condensed.lanPresheafIso_hom</code></a>, <a href="#CategoryTheory-MonoidalCategory-DayFunctor-Œπ_comp_isoPointwiseLeftKanExtension_inv"><code>CategoryTheory.MonoidalCategory.DayFunctor.Œπ_comp_isoPointwiseLeftKanExtension_inv</code></a>, <a href="#CategoryTheory-Functor-costructuredArrowMapCocone_Œπ_app"><code>CategoryTheory.Functor.costructuredArrowMapCocone_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-instPreservesLimitsOfShapeProjOfIsConnected"><code>instPreservesLimitsOfShapeProjOfIsConnected</code></a>, <a href="#CategoryTheory-CategoryOfElements-costructuredArrowYonedaEquivalenceFunctorProj_inv_app"><code>CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-IsPointwiseLeftKanExtensionAt-comp_homEquiv_symm_assoc"><code>CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.comp_homEquiv_symm_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-small_inverseImage_proj_of_locallySmall"><code>small_inverseImage_proj_of_locallySmall</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L840" id="CategoryTheory-CostructuredArrow-toStructuredArrow"><code>toStructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>toStructuredArrow_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L851" id="CategoryTheory-CostructuredArrow-toStructuredArrow'"><code>toStructuredArrow'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow'" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>toStructuredArrow'_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>toStructuredArrow'_map</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L448" id="CategoryTheory-CostructuredArrow-comp_left"><code>comp_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.comp_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L547" id="CategoryTheory-CostructuredArrow-epi_homMk"><code>epi_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.epi_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L540" id="CategoryTheory-CostructuredArrow-epi_of_epi_left"><code>epi_of_epi_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.epi_of_epi_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L455" id="CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.eqToHom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L553" id="CategoryTheory-CostructuredArrow-eq_mk"><code>eq_mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.eq_mk" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L684" id="CategoryTheory-CostructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.essSurj_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-essSurj_map"><code>CategoryTheory.Comma.essSurj_map</code></a><br><a href="#CategoryTheory-Functor-instEssSurjId"><code>CategoryTheory.Functor.instEssSurjId</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L557" id="CategoryTheory-CostructuredArrow-eta_hom_left"><code>eta_hom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.eta_hom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-eta"><code>eta</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L557" id="CategoryTheory-CostructuredArrow-eta_inv_left"><code>eta_inv_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.eta_inv_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-eta"><code>eta</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L528" id="CategoryTheory-CostructuredArrow-ext"><code>ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-ext"><code>CategoryTheory.CommaMorphism.ext</code></a><br><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L531" id="CategoryTheory-CostructuredArrow-ext_iff"><code>ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-ext"><code>ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L676" id="CategoryTheory-CostructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.faithful_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-faithful_map"><code>CategoryTheory.Comma.faithful_map</code></a><br><a href="#CategoryTheory-Functor-Faithful-id"><code>CategoryTheory.Functor.Faithful.id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L680" id="CategoryTheory-CostructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.full_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-full_map"><code>CategoryTheory.Comma.full_map</code></a><br><a href="#CategoryTheory-Functor-Full-id"><code>CategoryTheory.Functor.Full.id</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L493" id="CategoryTheory-CostructuredArrow-homMk'_comp"><code>homMk'_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L486" id="CategoryTheory-CostructuredArrow-homMk'_id"><code>homMk'_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L480" id="CategoryTheory-CostructuredArrow-homMk'_left"><code>homMk'_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L497" id="CategoryTheory-CostructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_mk_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'_comp"><code>homMk'_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L489" id="CategoryTheory-CostructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_mk_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk'_id"><code>homMk'_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L480" id="CategoryTheory-CostructuredArrow-homMk'_right"><code>homMk'_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk'_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L467" id="CategoryTheory-CostructuredArrow-homMk_left"><code>homMk_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L473" id="CategoryTheory-CostructuredArrow-homMk_surjective"><code>homMk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.homMk_surjective" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L424" id="CategoryTheory-CostructuredArrow-hom_eq_iff"><code>hom_eq_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.hom_eq_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L420" id="CategoryTheory-CostructuredArrow-hom_ext"><code>hom_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.hom_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-ext"><code>CategoryTheory.CommaMorphism.ext</code></a><br><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L419" id="CategoryTheory-CostructuredArrow-hom_ext_iff"><code>hom_ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.hom_ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L452" id="CategoryTheory-CostructuredArrow-id_left"><code>id_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.id_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L658" id="CategoryTheory-CostructuredArrow-instEssSurjCompObjPostOfFull"><code>instEssSurjCompObjPostOfFull</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instEssSurjCompObjPostOfFull" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_id"><code>CategoryTheory.Functor.map_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#CategoryTheory-Functor-map_preimage"><code>CategoryTheory.Functor.map_preimage</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L636" id="CategoryTheory-CostructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instEssSurjCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instEssSurjCompPreLeft"><code>CategoryTheory.Comma.instEssSurjCompPreLeft</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L652" id="CategoryTheory-CostructuredArrow-instFaithfulCompObjPost"><code>instFaithfulCompObjPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instFaithfulCompObjPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L630" id="CategoryTheory-CostructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instFaithfulCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instFaithfulCompPreLeft"><code>CategoryTheory.Comma.instFaithfulCompPreLeft</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L655" id="CategoryTheory-CostructuredArrow-instFullCompObjPostOfFaithful"><code>instFullCompObjPostOfFaithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instFullCompObjPostOfFaithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a><br><a href="#CategoryTheory-Functor-map_comp"><code>CategoryTheory.Functor.map_comp</code></a><br><a href="#CategoryTheory-Discrete-functor_map_id"><code>CategoryTheory.Discrete.functor_map_id</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L633" id="CategoryTheory-CostructuredArrow-instFullCompPre"><code>instFullCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.instFullCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instFullCompPreLeft"><code>CategoryTheory.Comma.instFullCompPreLeft</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L688" id="CategoryTheory-CostructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isEquivalenceMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-isEquivalenceMap"><code>CategoryTheory.Comma.isEquivalenceMap</code></a><br><a href="#CategoryTheory-Functor-isEquivalence_refl"><code>CategoryTheory.Functor.isEquivalence_refl</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L662" id="CategoryTheory-CostructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isEquivalence_post" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-instFaithfulCompObjPost"><code>instFaithfulCompObjPost</code></a><br><a href="#CategoryTheory-CostructuredArrow-instFullCompObjPostOfFaithful"><code>instFullCompObjPostOfFaithful</code></a><br><a href="#CategoryTheory-CostructuredArrow-instEssSurjCompObjPostOfFull"><code>instEssSurjCompObjPostOfFull</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L640" id="CategoryTheory-CostructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isEquivalence_pre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-isEquivalence_preLeft"><code>CategoryTheory.Comma.isEquivalence_preLeft</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L516" id="CategoryTheory-CostructuredArrow-isoMk_hom_left"><code>isoMk_hom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isoMk_hom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L516" id="CategoryTheory-CostructuredArrow-isoMk_inv_left"><code>isoMk_inv_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.isoMk_inv_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_counitIso_hom_app_left"><code>mapIso_counitIso_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_counitIso_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_counitIso_inv_app_left"><code>mapIso_counitIso_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_counitIso_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_functor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_functor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_functor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_functor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_inverse_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_inverse_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_inverse_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_inverse_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_unitIso_hom_app_left"><code>mapIso_unitIso_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_unitIso_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L594" id="CategoryTheory-CostructuredArrow-mapIso_unitIso_inv_app_left"><code>mapIso_unitIso_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapIso_unitIso_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_counitIso_hom_app_left"><code>mapNatIso_counitIso_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_counitIso_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_counitIso_inv_app_left"><code>mapNatIso_counitIso_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_counitIso_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_functor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_functor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_functor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_functor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_inverse_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_inverse_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_inverse_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_inverse_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_unitIso_hom_app_left"><code>mapNatIso_unitIso_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_unitIso_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L600" id="CategoryTheory-CostructuredArrow-mapNatIso_unitIso_inv_app_left"><code>mapNatIso_unitIso_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mapNatIso_unitIso_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L587" id="CategoryTheory-CostructuredArrow-map_comp"><code>map_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L582" id="CategoryTheory-CostructuredArrow-map_id"><code>map_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L573" id="CategoryTheory-CostructuredArrow-map_map_left"><code>map_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L573" id="CategoryTheory-CostructuredArrow-map_map_right"><code>map_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L578" id="CategoryTheory-CostructuredArrow-map_mk"><code>map_mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_mk" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L573" id="CategoryTheory-CostructuredArrow-map_obj_hom"><code>map_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L573" id="CategoryTheory-CostructuredArrow-map_obj_left"><code>map_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L573" id="CategoryTheory-CostructuredArrow-map_obj_right"><code>map_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L672" id="CategoryTheory-CostructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete-natTrans"><code>CategoryTheory.Discrete.natTrans</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L672" id="CategoryTheory-CostructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete-natTrans"><code>CategoryTheory.Discrete.natTrans</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L672" id="CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L672" id="CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L672" id="CategoryTheory-CostructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L508" id="CategoryTheory-CostructuredArrow-mkPrecomp_comp"><code>mkPrecomp_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkPrecomp_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L507" id="CategoryTheory-CostructuredArrow-mkPrecomp_id"><code>mkPrecomp_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkPrecomp_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>eqToHom_left</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L502" id="CategoryTheory-CostructuredArrow-mkPrecomp_left"><code>mkPrecomp_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkPrecomp_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L502" id="CategoryTheory-CostructuredArrow-mkPrecomp_right"><code>mkPrecomp_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mkPrecomp_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-mkPrecomp"><code>mkPrecomp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L440" id="CategoryTheory-CostructuredArrow-mk_hom_eq_self"><code>mk_hom_eq_self</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk_hom_eq_self" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L432" id="CategoryTheory-CostructuredArrow-mk_left"><code>mk_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L436" id="CategoryTheory-CostructuredArrow-mk_right"><code>mk_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L561" id="CategoryTheory-CostructuredArrow-mk_surjective"><code>mk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mk_surjective" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L543" id="CategoryTheory-CostructuredArrow-mono_homMk"><code>mono_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mono_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L536" id="CategoryTheory-CostructuredArrow-mono_of_mono_left"><code>mono_of_mono_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.mono_of_mono_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L521" id="CategoryTheory-CostructuredArrow-obj_ext"><code>obj_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.obj_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_id"><code>CategoryTheory.Functor.map_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L646" id="CategoryTheory-CostructuredArrow-post_map"><code>post_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.post_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L646" id="CategoryTheory-CostructuredArrow-post_obj"><code>post_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.post_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-post"><code>post</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L626" id="CategoryTheory-CostructuredArrow-pre_map_left"><code>pre_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L626" id="CategoryTheory-CostructuredArrow-pre_map_right"><code>pre_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L626" id="CategoryTheory-CostructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L626" id="CategoryTheory-CostructuredArrow-pre_obj_left"><code>pre_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L626" id="CategoryTheory-CostructuredArrow-pre_obj_right"><code>pre_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.pre_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1074" id="CategoryTheory-CostructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodEquivalence_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1074" id="CategoryTheory-CostructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodEquivalence_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1074" id="CategoryTheory-CostructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodEquivalence_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1074" id="CategoryTheory-CostructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodEquivalence_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1057" id="CategoryTheory-CostructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodFunctor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1057" id="CategoryTheory-CostructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodFunctor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1066" id="CategoryTheory-CostructuredArrow-prodInverse_map"><code>prodInverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodInverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1066" id="CategoryTheory-CostructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.prodInverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-CostructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L534" id="CategoryTheory-CostructuredArrow-proj_faithful"><code>proj_faithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj_faithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>proj</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-ext"><code>ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L413" id="CategoryTheory-CostructuredArrow-proj_map"><code>proj_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>proj</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L413" id="CategoryTheory-CostructuredArrow-proj_obj"><code>proj_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>proj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L605" id="CategoryTheory-CostructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.proj_reflectsIsomorphisms" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ReflectsIsomorphisms"><code>CategoryTheory.Functor.ReflectsIsomorphisms</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>proj</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_isIso"><code>CategoryTheory.Functor.map_isIso</code></a><br><a href="#CategoryTheory-Functor-map_inv"><code>CategoryTheory.Functor.map_inv</code></a><br><a href="#CategoryTheory-IsIso-inv_comp_eq"><code>CategoryTheory.IsIso.inv_comp_eq</code></a><br><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-CostructuredArrow-hom_ext"><code>hom_ext</code></a><br><a href="#CategoryTheory-IsIso-hom_inv_id"><code>CategoryTheory.IsIso.hom_inv_id</code></a><br><a href="#CategoryTheory-IsIso-inv_hom_id"><code>CategoryTheory.IsIso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L461" id="CategoryTheory-CostructuredArrow-right_eq_id"><code>right_eq_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.right_eq_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L850" id="CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>toStructuredArrow'_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow'_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'"><code>toStructuredArrow'</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>CategoryTheory.StructuredArrow.homMk</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L850" id="CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>toStructuredArrow'_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow'_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'"><code>toStructuredArrow'</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L839" id="CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>toStructuredArrow_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-toStructuredArrow"><code>toStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>CategoryTheory.StructuredArrow.homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L839" id="CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.toStructuredArrow_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-toStructuredArrow"><code>toStructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L445" id="CategoryTheory-CostructuredArrow-w"><code>w</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L444" id="CategoryTheory-CostructuredArrow-w_assoc"><code>w_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-CostructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1046" id="CategoryTheory-CostructuredArrow-w_prod_fst"><code>w_prod_fst</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w_prod_fst" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1045" id="CategoryTheory-CostructuredArrow-w_prod_fst_assoc"><code>w_prod_fst_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w_prod_fst_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-CostructuredArrow-w_prod_fst"><code>w_prod_fst</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1051" id="CategoryTheory-CostructuredArrow-w_prod_snd"><code>w_prod_snd</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w_prod_snd" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1050" id="CategoryTheory-CostructuredArrow-w_prod_snd_assoc"><code>w_prod_snd_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.w_prod_snd_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-CostructuredArrow-w_prod_snd"><code>w_prod_snd</code></a></td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow.IsUniversal</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L734" id="CategoryTheory-CostructuredArrow-IsUniversal-existsUnique"><code>existsUnique</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.existsUnique" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#ExistsUnique"><code>ExistsUnique</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-IsUniversal-fac"><code>fac</code></a><br><a href="#CategoryTheory-CostructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L717" id="CategoryTheory-CostructuredArrow-IsUniversal-fac"><code>fac</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.fac" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-IsUniversal-lift"><code>lift</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L716" id="CategoryTheory-CostructuredArrow-IsUniversal-fac_assoc"><code>fac_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.fac_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-IsUniversal-lift"><code>lift</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-CostructuredArrow-IsUniversal-fac"><code>fac</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L721" id="CategoryTheory-CostructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.hom_desc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-IsUniversal-lift"><code>lift</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsTerminal-hom_ext"><code>CategoryTheory.Limits.IsTerminal.hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L729" id="CategoryTheory-CostructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.hom_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L708" id="CategoryTheory-CostructuredArrow-IsUniversal-uniq"><code>uniq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.IsUniversal.uniq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsTerminal-hom_ext"><code>CategoryTheory.Limits.IsTerminal.hom_ext</code></a></td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow.preEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L953" id="CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_map_left"><code>functor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_left"><code>functor_obj_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L965" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_hom_left"><code>inverse_obj_hom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L952" id="CategoryTheory-CostructuredArrow-preEquivalence-functor_map_left"><code>functor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.functor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L952" id="CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L952" id="CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_left"><code>functor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L952" id="CategoryTheory-CostructuredArrow-preEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_hom_left"><code>inverse_obj_hom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_hom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L964" id="CategoryTheory-CostructuredArrow-preEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CategoryTheory.CostructuredArrow.pre</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow-preEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Functor</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L778" id="CategoryTheory-Functor-toCostructuredArrow"><code>toCostructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toCostructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_comp_proj"><code>toCostructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L785" id="CategoryTheory-Functor-toCostructuredArrowCompProj"><code>toCostructuredArrowCompProj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toCostructuredArrowCompProj" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L753" id="CategoryTheory-Functor-toStructuredArrow"><code>toStructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toStructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_map"><code>toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>toStructuredArrow_comp_proj</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L760" id="CategoryTheory-Functor-toStructuredArrowCompProj"><code>toStructuredArrowCompProj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toStructuredArrowCompProj" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L791" id="CategoryTheory-Functor-toCostructuredArrow_comp_proj"><code>toCostructuredArrow_comp_proj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toCostructuredArrow_comp_proj" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Functor-comp"><code>comp</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toCostructuredArrow"><code>toCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L777" id="CategoryTheory-Functor-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toCostructuredArrow_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toCostructuredArrow"><code>toCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L777" id="CategoryTheory-Functor-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toCostructuredArrow_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toCostructuredArrow"><code>toCostructuredArrow</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L766" id="CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>toStructuredArrow_comp_proj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toStructuredArrow_comp_proj" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Functor-comp"><code>comp</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toStructuredArrow"><code>toStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L752" id="CategoryTheory-Functor-toStructuredArrow_map"><code>toStructuredArrow_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toStructuredArrow_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toStructuredArrow"><code>toStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>CategoryTheory.StructuredArrow.homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L752" id="CategoryTheory-Functor-toStructuredArrow_obj"><code>toStructuredArrow_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.Functor.toStructuredArrow_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toStructuredArrow"><code>toStructuredArrow</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.StructuredArrow</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L359" id="CategoryTheory-StructuredArrow-IsUniversal"><code>IsUniversal</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-IsLeftKanExtension-nonempty_isUniversal"><code>CategoryTheory.Functor.IsLeftKanExtension.nonempty_isUniversal</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L198" id="CategoryTheory-StructuredArrow-eta"><code>eta</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.eta" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-eta_hom_right"><code>eta_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_inv_right"><code>eta_inv_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_counitIso"><code>CategoryTheory.Limits.Cocone.equivStructuredArrow_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L105" id="CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>31 math</summary><strong>math:</strong> <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_map"><code>CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_map"><code>commaMapEquivalenceInverse_map</code></a>, <a href="#Profinite-Extend-functorOp_map"><code>Profinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-Limits-limit-toStructuredArrow_map"><code>CategoryTheory.Limits.limit.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_map"><code>prodInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_map"><code>CategoryTheory.Functor.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_œÄ_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_homMk"><code>epi_homMk</code></a>, <a href="#LightProfinite-Extend-functor_map"><code>LightProfinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk_right"><code>homMk_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>CategoryTheory.CostructuredArrow.toStructuredArrow'_map</code></a>, <a href="#CategoryTheory-StructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_left"><code>commaMapEquivalenceFunctor_map_left</code></a>, <a href="#LightProfinite-Extend-functorOp_map"><code>LightProfinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_right"><code>commaMapEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_map"><code>CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_obj"><code>CategoryTheory.TwoSquare.EquivalenceJ.functor_obj</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_map"><code>CategoryTheory.TwoSquare.structuredArrowDownwards_map</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-toStructuredArrow_map"><code>CategoryTheory.Limits.Cocone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_map"><code>CategoryTheory.Limits.Cone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_obj"><code>CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_obj</code></a>, <a href="#CategoryTheory-ObjectProperty-LimitOfShape-toStructuredArrow_map"><code>CategoryTheory.ObjectProperty.LimitOfShape.toStructuredArrow_map</code></a>, <a href="#Profinite-Extend-functor_map"><code>Profinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>CategoryTheory.CostructuredArrow.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_hom"><code>commaMapEquivalenceFunctor_obj_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L121" id="CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-homMk'_comp"><code>homMk'_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_left"><code>homMk'_left</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_id"><code>homMk'_id</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_right"><code>homMk'_right</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L155" id="CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isoMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-isoMk_inv_right"><code>isoMk_inv_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_hom_right"><code>isoMk_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L214" id="CategoryTheory-StructuredArrow-map"><code>map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>15 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map_comp"><code>map_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_map_right"><code>CategoryTheory.Functor.LeftExtension.precomp‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map"><code>final_map</code></a>, <a href="#CategoryTheory-StructuredArrow-functor_map"><code>functor_map</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_œÄ_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map_mk"><code>map_mk</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_map"><code>CategoryTheory.Functor.pointwiseRightKanExtension_map</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-Functor-LeftExtension-precomp‚ÇÇ_map_left"><code>CategoryTheory.Functor.LeftExtension.precomp‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map_id"><code>map_id</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_pt"><code>CategoryTheory.Limits.Cone.toStructuredArrowCone_pt</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L234" id="CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>14 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_inv_app_right"><code>mapIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_hom_app_right"><code>mapIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_hom_app_right"><code>mapIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_inv_app_right"><code>mapIso_counitIso_inv_app_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L350" id="CategoryTheory-StructuredArrow-mapIsoMap‚ÇÇ"><code>mapIsoMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIsoMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L240" id="CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>14 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_hom_app_right"><code>mapNatIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_hom_app_right"><code>mapNatIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_inv_app_right"><code>mapNatIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_inv_app_right"><code>mapNatIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L312" id="CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>25 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_map"><code>commaMapEquivalenceInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_left_right"><code>commaMapEquivalenceCounitIso_hom_app_left_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_right"><code>commaMapEquivalenceUnitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map‚ÇÇ_id"><code>final_map‚ÇÇ_id</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_obj"><code>commaMapEquivalenceInverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_left"><code>commaMapEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_left"><code>commaMapEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_right"><code>commaMapEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_right_right"><code>commaMapEquivalenceCounitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_right"><code>commaMapEquivalenceUnitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_left"><code>commaMapEquivalenceUnitIso_hom_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_left"><code>commaMapEquivalenceUnitIso_inv_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_left_right"><code>commaMapEquivalenceCounitIso_inv_app_left_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_right"><code>commaMapEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_right_right"><code>commaMapEquivalenceCounitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_hom"><code>commaMapEquivalenceFunctor_obj_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L333" id="CategoryTheory-StructuredArrow-map‚ÇÇCompMap‚ÇÇIso"><code>map‚ÇÇCompMap‚ÇÇIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇCompMap‚ÇÇIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L945" id="CategoryTheory-StructuredArrow-map‚ÇÇIsoPreEquivalenceInverseCompProj"><code>map‚ÇÇIsoPreEquivalenceInverseCompProj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇIsoPreEquivalenceInverseCompProj" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L65" id="CategoryTheory-StructuredArrow-mk"><code>mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L254" id="CategoryTheory-StructuredArrow-mkIdInitial"><code>mkIdInitial</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkIdInitial" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L141" id="CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkPostcomp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-mkPostcomp_left"><code>mkPostcomp_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_comp"><code>mkPostcomp_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_right"><code>mkPostcomp_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_id"><code>mkPostcomp_id</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L286" id="CategoryTheory-StructuredArrow-post"><code>post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.post" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>9 math</summary><strong>math:</strong> <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>CategoryTheory.TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>instEssSurjObjCompPostOfFull</code></a>, <a href="#CategoryTheory-StructuredArrow-final_post"><code>final_post</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>instFaithfulObjCompPost</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a>, <a href="#CategoryTheory-StructuredArrow-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_obj"><code>CategoryTheory.TwoSquare.EquivalenceJ.inverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>instFullObjCompPostOfFaithful</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L345" id="CategoryTheory-StructuredArrow-postIsoMap‚ÇÇ"><code>postIsoMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.postIsoMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L266" id="CategoryTheory-StructuredArrow-pre"><code>pre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>29 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-final_pre"><code>final_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>preEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>preEquivalenceFunctor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>preEquivalence_functor</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_œÄ_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCone_œÄ_app</code></a>, <a href="#CategoryTheory-instFinalStructuredArrowCompPreOfRepresentablyFlat"><code>CategoryTheory.instFinalStructuredArrowCompPreOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>preEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>preEquivalenceInverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_left"><code>pre_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_right"><code>pre_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_map"><code>CategoryTheory.TwoSquare.structuredArrowDownwards_map</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_obj"><code>CategoryTheory.TwoSquare.structuredArrowDownwards_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>preEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>preEquivalenceInverse_obj_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>preEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>preEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullCompPre"><code>instFullCompPre</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_pt"><code>CategoryTheory.Limits.Cone.toStructuredArrowCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_left"><code>pre_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>preEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_right"><code>pre_obj_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L935" id="CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>preEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L909" id="CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>7 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>preEquivalenceFunctor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>preEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>preEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>preEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>preEquivalenceFunctor_obj_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L921" id="CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>9 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>preEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>preEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>preEquivalenceInverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>preEquivalenceInverse_obj_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>preEquivalenceInverse_obj_left_as</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L354" id="CategoryTheory-StructuredArrow-preIsoMap‚ÇÇ"><code>preIsoMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preIsoMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1031" id="CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1014" id="CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1023" id="CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodInverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-prodInverse_map"><code>prodInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L51" id="CategoryTheory-StructuredArrow-proj"><code>proj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>56 math</summary><strong>math:</strong> <a href="#CategoryTheory-Functor-IsDenseSubsite-instIsIsoSheafAppCounitSheafAdjunctionCocontinuous"><code>CategoryTheory.Functor.IsDenseSubsite.instIsIsoSheafAppCounitSheafAdjunctionCocontinuous</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_lift_app"><code>CategoryTheory.Functor.pointwiseRightKanExtension_lift_app</code></a>, <a href="#Profinite-Extend-cone_œÄ_app"><code>Profinite.Extend.cone_œÄ_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_pt"><code>CategoryTheory.Functor.RightExtension.coneAt_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_œÄ_app"><code>CategoryTheory.Functor.RightExtension.coneAt_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_inv_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompProj_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_œÄ_app"><code>CategoryTheory.Limits.Cone.fromStructuredArrow_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_pt"><code>CategoryTheory.Limits.Cone.fromStructuredArrow_pt</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_obj"><code>CategoryTheory.Functor.RightExtension.coneAtFunctor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-small_inverseImage_proj_of_locallySmall"><code>small_inverseImage_proj_of_locallySmall</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_inv_hom"><code>CategoryTheory.Functor.RightExtension.coneAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ_assoc"><code>CategoryTheory.Functor.ranObjObjIsoLimit_inv_œÄ_assoc</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÇ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ_assoc"><code>CategoryTheory.Functor.ranObjObjIsoLimit_hom_œÄ_assoc</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÉ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÉ</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_map"><code>proj_map</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ"><code>CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_hom_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompProj_hom_app</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtensionCounit_app"><code>CategoryTheory.Functor.pointwiseRightKanExtensionCounit_app</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_obj"><code>CategoryTheory.Functor.pointwiseRightKanExtension_obj</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ_assoc"><code>CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ_assoc</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ"><code>CategoryTheory.Functor.ranObjObjIsoLimit_hom_œÄ</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_map"><code>CategoryTheory.Functor.pointwiseRightKanExtension_map</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_map_hom"><code>CategoryTheory.Functor.RightExtension.coneAtFunctor_map_hom</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_hom_hom"><code>CategoryTheory.Functor.RightExtension.coneAtWhiskerRightIso_hom_hom</code></a>, <a href="#Profinite-Extend-cone_pt"><code>Profinite.Extend.cone_pt</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ"><code>CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_proj"><code>CategoryTheory.Limits.Cone.toStructuredArrow_comp_proj</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÅ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÅ</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ"><code>CategoryTheory.Functor.ranObjObjIsoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_pt"><code>CategoryTheory.Functor.structuredArrowMapCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_obj"><code>proj_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_proj_preimage"><code>isCoseparating_proj_preimage</code></a>, <a href="#CategoryTheory-Functor-IsDenseSubsite-isIso_ranCounit_app_of_isDenseSubsite"><code>CategoryTheory.Functor.IsDenseSubsite.isIso_ranCounit_app_of_isDenseSubsite</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ_assoc"><code>CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ_assoc</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>CategoryTheory.Functor.toStructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_inverseImage_proj"><code>isCoseparating_inverseImage_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-final_proj_of_isFiltered"><code>final_proj_of_isFiltered</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-small_proj_preimage_of_locallySmall"><code>small_proj_preimage_of_locallySmall</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_œÄ_app"><code>CategoryTheory.Functor.structuredArrowMapCone_œÄ_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L808" id="CategoryTheory-StructuredArrow-toCostructuredArrow"><code>toCostructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L819" id="CategoryTheory-StructuredArrow-toCostructuredArrow'"><code>toCostructuredArrow'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow'" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>toCostructuredArrow'_obj</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L85" id="CategoryTheory-StructuredArrow-comp_right"><code>comp_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.comp_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L187" id="CategoryTheory-StructuredArrow-epi_homMk"><code>epi_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.epi_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L180" id="CategoryTheory-StructuredArrow-epi_of_epi_right"><code>epi_of_epi_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.epi_of_epi_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L92" id="CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.eqToHom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L193" id="CategoryTheory-StructuredArrow-eq_mk"><code>eq_mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.eq_mk" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L323" id="CategoryTheory-StructuredArrow-essSurj_map‚ÇÇ"><code>essSurj_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.essSurj_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-essSurj_map"><code>CategoryTheory.Comma.essSurj_map</code></a><br><a href="#CategoryTheory-Functor-instEssSurjId"><code>CategoryTheory.Functor.instEssSurjId</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L197" id="CategoryTheory-StructuredArrow-eta_hom_right"><code>eta_hom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.eta_hom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-eta"><code>eta</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L197" id="CategoryTheory-StructuredArrow-eta_inv_right"><code>eta_inv_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.eta_inv_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-eta"><code>eta</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L167" id="CategoryTheory-StructuredArrow-ext"><code>ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-ext"><code>CategoryTheory.CommaMorphism.ext</code></a><br><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L170" id="CategoryTheory-StructuredArrow-ext_iff"><code>ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-ext"><code>ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L315" id="CategoryTheory-StructuredArrow-faithful_map‚ÇÇ"><code>faithful_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.faithful_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-faithful_map"><code>CategoryTheory.Comma.faithful_map</code></a><br><a href="#CategoryTheory-Functor-Faithful-id"><code>CategoryTheory.Functor.Faithful.id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L319" id="CategoryTheory-StructuredArrow-full_map‚ÇÇ"><code>full_map‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.full_map‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-full_map"><code>CategoryTheory.Comma.full_map</code></a><br><a href="#CategoryTheory-Functor-Full-id"><code>CategoryTheory.Functor.Full.id</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L131" id="CategoryTheory-StructuredArrow-homMk'_comp"><code>homMk'_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L125" id="CategoryTheory-StructuredArrow-homMk'_id"><code>homMk'_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L120" id="CategoryTheory-StructuredArrow-homMk'_left"><code>homMk'_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L135" id="CategoryTheory-StructuredArrow-homMk'_mk_comp"><code>homMk'_mk_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_mk_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'_comp"><code>homMk'_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L128" id="CategoryTheory-StructuredArrow-homMk'_mk_id"><code>homMk'_mk_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_mk_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk'_id"><code>homMk'_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L120" id="CategoryTheory-StructuredArrow-homMk'_right"><code>homMk'_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk'_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk'"><code>homMk'</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L104" id="CategoryTheory-StructuredArrow-homMk_right"><code>homMk_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L113" id="CategoryTheory-StructuredArrow-homMk_surjective"><code>homMk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.homMk_surjective" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L61" id="CategoryTheory-StructuredArrow-hom_eq_iff"><code>hom_eq_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.hom_eq_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L57" id="CategoryTheory-StructuredArrow-hom_ext"><code>hom_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.hom_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-ext"><code>CategoryTheory.CommaMorphism.ext</code></a><br><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L56" id="CategoryTheory-StructuredArrow-hom_ext_iff"><code>hom_ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.hom_ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L89" id="CategoryTheory-StructuredArrow-id_right"><code>id_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.id_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L275" id="CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instEssSurjCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instEssSurjCompPreRight"><code>CategoryTheory.Comma.instEssSurjCompPreRight</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L297" id="CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>instEssSurjObjCompPostOfFull</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instEssSurjObjCompPostOfFull" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_preimage"><code>CategoryTheory.Functor.map_preimage</code></a><br><a href="#CategoryTheory-Functor-map_id"><code>CategoryTheory.Functor.map_id</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L269" id="CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instFaithfulCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instFaithfulCompPreRight"><code>CategoryTheory.Comma.instFaithfulCompPreRight</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L291" id="CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>instFaithfulObjCompPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instFaithfulObjCompPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L272" id="CategoryTheory-StructuredArrow-instFullCompPre"><code>instFullCompPre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instFullCompPre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-instFullCompPreRight"><code>CategoryTheory.Comma.instFullCompPreRight</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L294" id="CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>instFullObjCompPostOfFaithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.instFullObjCompPostOfFaithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a><br><a href="#CategoryTheory-Functor-map_comp"><code>CategoryTheory.Functor.map_comp</code></a><br><a href="#CategoryTheory-Discrete-functor_map_id"><code>CategoryTheory.Discrete.functor_map_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L327" id="CategoryTheory-StructuredArrow-isEquivalenceMap‚ÇÇ"><code>isEquivalenceMap‚ÇÇ</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isEquivalenceMap‚ÇÇ" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-isEquivalenceMap"><code>CategoryTheory.Comma.isEquivalenceMap</code></a><br><a href="#CategoryTheory-Functor-isEquivalence_refl"><code>CategoryTheory.Functor.isEquivalence_refl</code></a><br><a href="#CategoryTheory-Discrete-instIsIsoFunctorNatTrans"><code>CategoryTheory.Discrete.instIsIsoFunctorNatTrans</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L301" id="CategoryTheory-StructuredArrow-isEquivalence_post"><code>isEquivalence_post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isEquivalence_post" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>instFaithfulObjCompPost</code></a><br><a href="#CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>instFullObjCompPostOfFaithful</code></a><br><a href="#CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>instEssSurjObjCompPostOfFull</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L279" id="CategoryTheory-StructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isEquivalence_pre" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-isEquivalence_preRight"><code>CategoryTheory.Comma.isEquivalence_preRight</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L154" id="CategoryTheory-StructuredArrow-isoMk_hom_right"><code>isoMk_hom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isoMk_hom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L154" id="CategoryTheory-StructuredArrow-isoMk_inv_right"><code>isoMk_inv_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.isoMk_inv_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L98" id="CategoryTheory-StructuredArrow-left_eq_id"><code>left_eq_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.left_eq_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_counitIso_hom_app_right"><code>mapIso_counitIso_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_counitIso_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_counitIso_inv_app_right"><code>mapIso_counitIso_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_counitIso_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_functor_map_left"><code>mapIso_functor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_functor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_functor_map_right"><code>mapIso_functor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_functor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_functor_obj_hom"><code>mapIso_functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_functor_obj_left"><code>mapIso_functor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_functor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_functor_obj_right"><code>mapIso_functor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_functor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_inverse_map_left"><code>mapIso_inverse_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_inverse_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_inverse_map_right"><code>mapIso_inverse_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_inverse_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_inverse_obj_hom"><code>mapIso_inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_inverse_obj_left"><code>mapIso_inverse_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_inverse_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_inverse_obj_right"><code>mapIso_inverse_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_inverse_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_unitIso_hom_app_right"><code>mapIso_unitIso_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_unitIso_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L233" id="CategoryTheory-StructuredArrow-mapIso_unitIso_inv_app_right"><code>mapIso_unitIso_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapIso_unitIso_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapLeft"><code>CategoryTheory.Comma.mapLeft</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-mapIso"><code>CategoryTheory.Functor.mapIso</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_counitIso_hom_app_right"><code>mapNatIso_counitIso_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_counitIso_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_counitIso_inv_app_right"><code>mapNatIso_counitIso_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_counitIso_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_functor_map_left"><code>mapNatIso_functor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_functor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_functor_map_right"><code>mapNatIso_functor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_functor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_functor_obj_hom"><code>mapNatIso_functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_functor_obj_left"><code>mapNatIso_functor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_functor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_functor_obj_right"><code>mapNatIso_functor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_functor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_inverse_map_left"><code>mapNatIso_inverse_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_inverse_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_inverse_map_right"><code>mapNatIso_inverse_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_inverse_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_hom"><code>mapNatIso_inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_left"><code>mapNatIso_inverse_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_inverse_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_right"><code>mapNatIso_inverse_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_inverse_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_unitIso_hom_app_right"><code>mapNatIso_unitIso_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_unitIso_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L239" id="CategoryTheory-StructuredArrow-mapNatIso_unitIso_inv_app_right"><code>mapNatIso_unitIso_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mapNatIso_unitIso_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-mapRight"><code>CategoryTheory.Comma.mapRight</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-mapNatIso"><code>mapNatIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L227" id="CategoryTheory-StructuredArrow-map_comp"><code>map_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L222" id="CategoryTheory-StructuredArrow-map_id"><code>map_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L213" id="CategoryTheory-StructuredArrow-map_map_left"><code>map_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L213" id="CategoryTheory-StructuredArrow-map_map_right"><code>map_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L218" id="CategoryTheory-StructuredArrow-map_mk"><code>map_mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_mk" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L213" id="CategoryTheory-StructuredArrow-map_obj_hom"><code>map_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L213" id="CategoryTheory-StructuredArrow-map_obj_left"><code>map_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L213" id="CategoryTheory-StructuredArrow-map_obj_right"><code>map_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L311" id="CategoryTheory-StructuredArrow-map‚ÇÇ_map_left"><code>map‚ÇÇ_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Discrete-natTrans"><code>CategoryTheory.Discrete.natTrans</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L311" id="CategoryTheory-StructuredArrow-map‚ÇÇ_map_right"><code>map‚ÇÇ_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Discrete-natTrans"><code>CategoryTheory.Discrete.natTrans</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L311" id="CategoryTheory-StructuredArrow-map‚ÇÇ_obj_hom"><code>map‚ÇÇ_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L311" id="CategoryTheory-StructuredArrow-map‚ÇÇ_obj_left"><code>map‚ÇÇ_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L311" id="CategoryTheory-StructuredArrow-map‚ÇÇ_obj_right"><code>map‚ÇÇ_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.map‚ÇÇ_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-map‚ÇÇ"><code>map‚ÇÇ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L146" id="CategoryTheory-StructuredArrow-mkPostcomp_comp"><code>mkPostcomp_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkPostcomp_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L145" id="CategoryTheory-StructuredArrow-mkPostcomp_id"><code>mkPostcomp_id</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkPostcomp_id" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>eqToHom_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L140" id="CategoryTheory-StructuredArrow-mkPostcomp_left"><code>mkPostcomp_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkPostcomp_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L140" id="CategoryTheory-StructuredArrow-mkPostcomp_right"><code>mkPostcomp_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mkPostcomp_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-mkPostcomp"><code>mkPostcomp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L77" id="CategoryTheory-StructuredArrow-mk_hom_eq_self"><code>mk_hom_eq_self</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk_hom_eq_self" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L69" id="CategoryTheory-StructuredArrow-mk_left"><code>mk_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L73" id="CategoryTheory-StructuredArrow-mk_right"><code>mk_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L201" id="CategoryTheory-StructuredArrow-mk_surjective"><code>mk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mk_surjective" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L183" id="CategoryTheory-StructuredArrow-mono_homMk"><code>mono_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mono_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L177" id="CategoryTheory-StructuredArrow-mono_of_mono_right"><code>mono_of_mono_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.mono_of_mono_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L160" id="CategoryTheory-StructuredArrow-obj_ext"><code>obj_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.obj_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_id"><code>CategoryTheory.Functor.map_id</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L285" id="CategoryTheory-StructuredArrow-post_map"><code>post_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.post_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L285" id="CategoryTheory-StructuredArrow-post_obj"><code>post_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.post_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-post"><code>post</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L908" id="CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>preEquivalenceFunctor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceFunctor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L908" id="CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>preEquivalenceFunctor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L908" id="CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>preEquivalenceFunctor_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L908" id="CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>preEquivalenceFunctor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>preEquivalenceInverse_map_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_map_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>preEquivalenceInverse_obj_hom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_hom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>preEquivalenceInverse_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>preEquivalenceInverse_obj_right_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>preEquivalenceInverse_obj_right_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L920" id="CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>preEquivalenceInverse_obj_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L934" id="CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>preEquivalence_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalence_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L934" id="CategoryTheory-StructuredArrow-preEquivalence_functor"><code>preEquivalence_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalence_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L934" id="CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>preEquivalence_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalence_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L934" id="CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>preEquivalence_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.preEquivalence_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalence"><code>preEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor"><code>preEquivalenceFunctor</code></a><br><a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse"><code>preEquivalenceInverse</code></a><br><a href="#CategoryTheory-StructuredArrow-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L265" id="CategoryTheory-StructuredArrow-pre_map_left"><code>pre_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L265" id="CategoryTheory-StructuredArrow-pre_map_right"><code>pre_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L265" id="CategoryTheory-StructuredArrow-pre_obj_hom"><code>pre_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L265" id="CategoryTheory-StructuredArrow-pre_obj_left"><code>pre_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L265" id="CategoryTheory-StructuredArrow-pre_obj_right"><code>pre_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.pre_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>pre</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1030" id="CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>prodEquivalence_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodEquivalence_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1030" id="CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>prodEquivalence_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodEquivalence_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1030" id="CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>prodEquivalence_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodEquivalence_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1030" id="CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>prodEquivalence_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodEquivalence_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodEquivalence"><code>prodEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1013" id="CategoryTheory-StructuredArrow-prodFunctor_map"><code>prodFunctor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodFunctor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1013" id="CategoryTheory-StructuredArrow-prodFunctor_obj"><code>prodFunctor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodFunctor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-prodFunctor"><code>prodFunctor</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1022" id="CategoryTheory-StructuredArrow-prodInverse_map"><code>prodInverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodInverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1022" id="CategoryTheory-StructuredArrow-prodInverse_obj"><code>prodInverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.prodInverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-StructuredArrow-prodInverse"><code>prodInverse</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L173" id="CategoryTheory-StructuredArrow-proj_faithful"><code>proj_faithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj_faithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>proj</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-ext"><code>ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L50" id="CategoryTheory-StructuredArrow-proj_map"><code>proj_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>proj</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L50" id="CategoryTheory-StructuredArrow-proj_obj"><code>proj_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>proj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L244" id="CategoryTheory-StructuredArrow-proj_reflectsIsomorphisms"><code>proj_reflectsIsomorphisms</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.proj_reflectsIsomorphisms" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ReflectsIsomorphisms"><code>CategoryTheory.Functor.ReflectsIsomorphisms</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>proj</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_isIso"><code>CategoryTheory.Functor.map_isIso</code></a><br><a href="#CategoryTheory-Functor-map_inv"><code>CategoryTheory.Functor.map_inv</code></a><br><a href="#CategoryTheory-IsIso-comp_inv_eq"><code>CategoryTheory.IsIso.comp_inv_eq</code></a><br><a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a><br><a href="#CategoryTheory-CommaMorphism-ext"><code>CategoryTheory.CommaMorphism.ext</code></a><br><a href="#CategoryTheory-IsIso-hom_inv_id"><code>CategoryTheory.IsIso.hom_inv_id</code></a><br><a href="#CategoryTheory-IsIso-inv_hom_id"><code>CategoryTheory.IsIso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L818" id="CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>toCostructuredArrow'_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow'_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'"><code>toCostructuredArrow'</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L818" id="CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>toCostructuredArrow'_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow'_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'"><code>toCostructuredArrow'</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L807" id="CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>toCostructuredArrow_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-toCostructuredArrow"><code>toCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L807" id="CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>toCostructuredArrow_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.toCostructuredArrow_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-op"><code>CategoryTheory.Functor.op</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-toCostructuredArrow"><code>toCostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L81" id="CategoryTheory-StructuredArrow-w"><code>w</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L80" id="CategoryTheory-StructuredArrow-w_assoc"><code>w_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1002" id="CategoryTheory-StructuredArrow-w_prod_fst"><code>w_prod_fst</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w_prod_fst" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1001" id="CategoryTheory-StructuredArrow-w_prod_fst_assoc"><code>w_prod_fst_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w_prod_fst_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-StructuredArrow-w_prod_fst"><code>w_prod_fst</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1007" id="CategoryTheory-StructuredArrow-w_prod_snd"><code>w_prod_snd</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w_prod_snd" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L1006" id="CategoryTheory-StructuredArrow-w_prod_snd_assoc"><code>w_prod_snd_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.w_prod_snd_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-prod'"><code>CategoryTheory.prod'</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-prod"><code>CategoryTheory.Functor.prod</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-StructuredArrow-w_prod_snd"><code>w_prod_snd</code></a></td></tr>
</table>
<h2>CategoryTheory.StructuredArrow.IsUniversal</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L369" id="CategoryTheory-StructuredArrow-IsUniversal-desc"><code>desc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.desc" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-fac_assoc"><code>fac_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-fac"><code>fac</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L391" id="CategoryTheory-StructuredArrow-IsUniversal-existsUnique"><code>existsUnique</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.existsUnique" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#ExistsUnique"><code>ExistsUnique</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-IsUniversal-fac"><code>fac</code></a><br><a href="#CategoryTheory-StructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L374" id="CategoryTheory-StructuredArrow-IsUniversal-fac"><code>fac</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.fac" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-IsUniversal-desc"><code>desc</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L373" id="CategoryTheory-StructuredArrow-IsUniversal-fac_assoc"><code>fac_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.fac_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-IsUniversal-desc"><code>desc</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-StructuredArrow-IsUniversal-fac"><code>fac</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L378" id="CategoryTheory-StructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.hom_desc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-IsUniversal-desc"><code>desc</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsInitial-hom_ext"><code>CategoryTheory.Limits.IsInitial.hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L386" id="CategoryTheory-StructuredArrow-IsUniversal-hom_ext"><code>hom_ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.hom_ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-IsUniversal-hom_desc"><code>hom_desc</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.lean#L365" id="CategoryTheory-StructuredArrow-IsUniversal-uniq"><code>uniq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow.IsUniversal.uniq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-IsInitial-hom_ext"><code>CategoryTheory.Limits.IsInitial.hom_ext</code></a></td></tr>
</table>
<p>---</p>
<p><a href="index.html">‚Üê Back to Index</a></p>
    </div>
  </main>
</body>
</html>