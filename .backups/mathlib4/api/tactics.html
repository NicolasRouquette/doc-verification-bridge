<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="./style.css"></link><link rel="icon" href="./favicon.svg"></link><link rel="mask-icon" href="./favicon.svg" color="#000000"></link><link rel="prefetch" href=".//declarations/declaration-data.bmp" as="image"></link><title>Tactics</title><script defer="true" src="./mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="./";</script><script type="module" src="./jump-src.js"></script><script type="module" src="./search.js"></script><script type="module" src="./expand-nav.js"></script><script type="module" src="./how-about.js"></script><script type="module" src="./instances.js"></script><script type="module" src="./importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Tactics</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='./search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p><a href="#¬´tactic#adaptation_note_¬ª">#adaptation_note</a></p><p><a href="#Mathlib.Tactic.¬´tactic#check__¬ª">#check</a></p><p><a href="#Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª">#count_heartbeats</a></p><p><a href="#Mathlib.Tactic.DefEqAbuse.defeqAbuse">#defeq_abuse</a></p><p><a href="#Mathlib.Tactic.Find.¬´tactic#find_¬ª">#find</a></p><p><a href="#Mathlib.Tactic.Abel.abel">abel</a></p><p><a href="#Mathlib.Tactic.acChange">ac_change</a></p><p><a href="#CategoryTheory.aesop_cat">aesop_cat</a></p><p><a href="#CategoryTheory.aesop_cat?">aesop_cat?</a></p><p><a href="#CategoryTheory.aesop_cat_nonterminal">aesop_cat_nonterminal</a></p><p><a href="#aesop_graph">aesop_graph</a></p><p><a href="#aesop_graph?">aesop_graph?</a></p><p><a href="#aesop_graph_nonterminal">aesop_graph_nonterminal</a></p><p><a href="#Matroid.aesop_mat">aesop_mat</a></p><p><a href="#Mathlib.Tactic.tacticAlgebraize__">algebraize</a></p><p><a href="#Mathlib.Tactic.tacticAlgebraize_only__">algebraize_only</a></p><p><a href="#Mathlib.Tactic.tacticApply_At_">apply</a></p><p><a href="#Mathlib.Tactic.applyFun">apply_fun</a></p><p><a href="#GradedMonoid.tacticApply_gmonoid_gnpowRec_succ_tac">apply_gmonoid_gnpowRec_succ_tac</a></p><p><a href="#GradedMonoid.tacticApply_gmonoid_gnpowRec_zero_tac">apply_gmonoid_gnpowRec_zero_tac</a></p><p><a href="#Mathlib.Tactic.tacticApply_rewrite___">apply_rewrite</a></p><p><a href="#Mathlib.Tactic.applyRwSeq">apply_rw</a></p><p><a href="#ArithmeticFunction.arith_mult">arith_mult</a></p><p><a href="#ArithmeticFunction.arith_mult?">arith_mult?</a></p><p><a href="#Mathlib.Tactic.tacticAssumption'">assumption'</a></p><p><a href="#Mathlib.Tactic.Group.aux_group‚ÇÅ">aux_group‚ÇÅ</a></p><p><a href="#Mathlib.Tactic.Group.aux_group‚ÇÇ">aux_group‚ÇÇ</a></p><p><a href="#tacticBddDefault">bddDefault</a></p><p><a href="#Mathlib.Tactic.betaReduceStx">beta_reduce</a></p><p><a href="#Mathlib.Tactic.Bicategory.tacticBicategory">bicategory</a></p><p><a href="#Mathlib.Tactic.Bicategory.tacticBicategory_coherence">bicategory_coherence</a></p><p><a href="#Mathlib.Tactic.BicategoryCoherence.tacticBicategory_coherence">bicategory_coherence</a></p><p><a href="#Mathlib.Tactic.Bicategory.tacticBicategory_nf">bicategory_nf</a></p><p><a href="#Nat.tacticBitwise_assoc_tac">bitwise_assoc_tac</a></p><p><a href="#Mathlib.Tactic.Borelize.tacticBorelize___">borelize</a></p><p><a href="#¬´tacticBound[_]¬ª">bound</a></p><p><a href="#Mathlib.Tactic.ByCases.byCases!">by_cases!</a></p><p><a href="#Mathlib.Tactic.ByContra.byContra!">by_contra!</a></p><p><a href="#Lean.Elab.Tactic.tacticCalc?">calc?</a></p><p><a href="#cancelDenoms">cancel_denoms</a></p><p><a href="#Mathlib.Tactic.cases'">cases'</a></p><p><a href="#Mathlib.Tactic.ENatToNat.tacticCases_first_enat">cases_first_enat</a></p><p><a href="#Mathlib.Tactic.casesType">cases_type</a></p><p><a href="#Mathlib.Tactic.casesM">casesm</a></p><p><a href="#CategoryTheory.cat_disch">cat_disch</a></p><p><a href="#cfcContTac">cfc_cont_tac</a></p><p><a href="#cfcTac">cfc_tac</a></p><p><a href="#cfcZeroTac">cfc_zero_tac</a></p><p><a href="#change?">change?</a></p><p><a href="#Mathlib.Tactic.CheckCompositions.tacticCheck_compositions">check_compositions</a></p><p><a href="#Mathlib.Tactic.Choose.choose">choose</a></p><p><a href="#Mathlib.Tactic.tacticClean_">clean</a></p><p><a href="#Lean.Elab.Tactic.clearExceptTactic">clear</a></p><p><a href="#Mathlib.Tactic.clear!">clear!</a></p><p><a href="#Mathlib.Tactic.clear_">clear_</a></p><p><a href="#Mathlib.Tactic.clearAuxDecl">clear_aux_decl</a></p><p><a href="#Mathlib.Tactic.Coherence.coherence">coherence</a></p><p><a href="#tacticCompareOfLessAndEq_rfl">compareOfLessAndEq_rfl</a></p><p><a href="#Mathlib.Tactic.ComputeDegree.computeDegree">compute_degree</a></p><p><a href="#Congr!.congr!">congr!</a></p><p><a href="#Mathlib.Tactic.congrM">congrm</a></p><p><a href="#tacticCongrm?">congrm?</a></p><p><a href="#Mathlib.Tactic.constructorM">constructorm</a></p><p><a href="#tacticContinuity">continuity</a></p><p><a href="#Mathlib.Tactic.Contrapose.contrapose">contrapose</a></p><p><a href="#Mathlib.Tactic.Conv.tacticConv?">conv?</a></p><p><a href="#Mathlib.Tactic.Conv.convLHS">conv_lhs</a></p><p><a href="#Mathlib.Tactic.Conv.convRHS">conv_rhs</a></p><p><a href="#Mathlib.Tactic.convert">convert</a></p><p><a href="#Mathlib.Tactic.convertTo">convert_to</a></p><p><a href="#CategoryTheory.Discrete.tacticDiscrete_cases">discrete_cases</a></p><p><a href="#tacticEconstructor">econstructor</a></p><p><a href="#Mathlib.Tactic.ENatToNat.tacticEnat_to_nat">enat_to_nat</a></p><p><a href="#Mathlib.Tactic.Erw?.erw?">erw?</a></p><p><a href="#Mathlib.Tactic.etaExpandStx">eta_expand</a></p><p><a href="#Mathlib.Tactic.etaReduceStx">eta_reduce</a></p><p><a href="#Mathlib.Tactic.etaStructStx">eta_struct</a></p><p><a href="#Mathlib.Tactic.¬´tacticExistsi_,,¬ª">existsi</a></p><p><a href="#Mathlib.Tactic.ExtractGoal.extractGoal">extract_goal</a></p><p><a href="#Mathlib.Tactic.failIfNoProgress">fail_if_no_progress</a></p><p><a href="#tacticFconstructor">fconstructor</a></p><p><a href="#Mathlib.Tactic.FieldSimp.field">field</a></p><p><a href="#Mathlib.Tactic.FieldSimp.fieldSimp">field_simp</a></p><p><a href="#Mathlib.Tactic.FieldSimp.tacticField_simp_discharge">field_simp_discharge</a></p><p><a href="#Mathlib.Tactic.filterUpwards">filter_upwards</a></p><p><a href="#Lean.Elab.Tactic.finCases">fin_cases</a></p><p><a href="#Fin.tacticFin_omega">fin_omega</a></p><p><a href="#Mathlib.Tactic.Find.tacticFind">find</a></p><p><a href="#finiteness">finiteness</a></p><p><a href="#RatFunc.tacticFrac_tac">frac_tac</a></p><p><a href="#Mathlib.Meta.FunProp.funPropTacStx">fun_prop</a></p><p><a href="#Mathlib.Tactic.GCongr.tacticGcongr___With___">gcongr</a></p><p><a href="#tacticGcongr?">gcongr?</a></p><p><a href="#Mathlib.Tactic.GCongr.tacticGcongr_discharger">gcongr_discharger</a></p><p><a href="#¬´tacticGeneralize'_:_=_¬ª">generalize'</a></p><p><a href="#WittVector.Tactic.ghostCalc">ghost_calc</a></p><p><a href="#WittVector.¬´tacticGhost_fun_tac_,_¬ª">ghost_fun_tac</a></p><p><a href="#WittVector.Tactic.ghostSimp">ghost_simp</a></p><p><a href="#Mathlib.Tactic.grewriteSeq">grewrite</a></p><p><a href="#Mathlib.Tactic.Group.group">group</a></p><p><a href="#Mathlib.Tactic.grwSeq">grw</a></p><p><a href="#guardGoalNums">guard_goal_nums</a></p><p><a href="#guardHypNums">guard_hyp_nums</a></p><p><a href="#Mathlib.Tactic.Hint.hintStx">hint</a></p><p><a href="#Mathlib.Tactic.induction'">induction'</a></p><p><a href="#Mathlib.Tactic.inferOptParam">infer_param</a></p><p><a href="#Lean.Elab.Tactic.inhabit">inhabit</a></p><p><a href="#WittVector.initRing">init_ring</a></p><p><a href="#Mathlib.Tactic.intervalCases">interval_cases</a></p><p><a href="#Mathlib.Tactic.introv">introv</a></p><p><a href="#Filter.tacticIsBoundedDefault">isBoundedDefault</a></p><p><a href="#Mathlib.Tactic.ITauto.itauto">itauto</a></p><p><a href="#Mathlib.Tactic.lift">lift</a></p><p><a href="#Mathlib.Tactic.Coherence.liftable_prefixes">liftable_prefixes</a></p><p><a href="#Mathlib.Tactic.linarith">linarith</a></p><p><a href="#Mathlib.Tactic.linarith?">linarith?</a></p><p><a href="#Mathlib.Tactic.LinearCombination.linearCombination">linear_combination</a></p><p><a href="#Mathlib.Tactic.LinearCombination'.linearCombination'">linear_combination'</a></p><p><a href="#WittVector.mapFun.tacticMap_fun_tac">map_fun_tac</a></p><p><a href="#Mathlib.Tactic.Module.tacticMatch_scalars">match_scalars</a></p><p><a href="#Mathlib.Tactic.tacticMatch_target_">match_target</a></p><p><a href="#Mathlib.Tactic.measurability">measurability</a></p><p><a href="#Mathlib.Tactic.measurability?">measurability?</a></p><p><a href="#AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.tacticMem_tac">mem_tac</a></p><p><a href="#Tactic.MfldSetTac.mfldSetTac">mfld_set_tac</a></p><p><a href="#Mathlib.Tactic.ModCases.¬´tacticMod_cases_:_%_¬ª">mod_cases</a></p><p><a href="#Mathlib.Tactic.Module.tacticModule">module</a></p><p><a href="#Mathlib.Tactic.ComputeDegree.monicityMacro">monicity</a></p><p><a href="#Mathlib.Tactic.Monotonicity.mono">mono</a></p><p><a href="#Mathlib.Tactic.Monoidal.tacticMonoidal">monoidal</a></p><p><a href="#Mathlib.Tactic.Coherence.tacticMonoidal_coherence">monoidal_coherence</a></p><p><a href="#Mathlib.Tactic.Monoidal.tacticMonoidal_coherence">monoidal_coherence</a></p><p><a href="#Mathlib.Tactic.Monoidal.tacticMonoidal_nf">monoidal_nf</a></p><p><a href="#Mathlib.Tactic.Coherence.monoidal_simps">monoidal_simps</a></p><p><a href="#Mathlib.MoveAdd.moveOperTac">move_oper</a></p><p><a href="#Mathlib.Tactic.MvBisim.tacticMv_bisim___With___">mv_bisim</a></p><p><a href="#Mathlib.Tactic.nlinarith">nlinarith</a></p><p><a href="#Mathlib.Tactic.NoncommRing.noncomm_ring">noncomm_ring</a></p><p><a href="#Mathlib.Tactic.Nontriviality.nontriviality">nontriviality</a></p><p><a href="#Mathlib.Tactic.normNum">norm_num</a></p><p><a href="#Mathlib.Tactic.normNum1">norm_num1</a></p><p><a href="#Mathlib.Tactic.tacticNth_grewrite_____">nth_grewrite</a></p><p><a href="#Mathlib.Tactic.tacticNth_grw_____">nth_grw</a></p><p><a href="#Mathlib.Tactic.tacticNth_rewrite_____">nth_rewrite</a></p><p><a href="#Mathlib.Tactic.tacticNth_rw_____">nth_rw</a></p><p><a href="#Mathlib.Tactic.LibrarySearch.observe">observe</a></p><p><a href="#Mathlib.Tactic.Order.tacticOrder_">order</a></p><p><a href="#Mathlib.Tactic.Order.order_core">order_core</a></p><p><a href="#Mathlib.Tactic.Peel.peel">peel</a></p><p><a href="#Real.¬´tacticPi_lower_bound[_,,]¬ª">pi_lower_bound</a></p><p><a href="#Real.¬´tacticPi_upper_bound[_,,]¬ª">pi_upper_bound</a></p><p><a href="#Mathlib.Tactic.PNatToNat.tacticPnat_positivity">pnat_positivity</a></p><p><a href="#Mathlib.Tactic.PNatToNat.tacticPnat_to_nat">pnat_to_nat</a></p><p><a href="#Mathlib.Tactic.Polyrith.¬´tacticPolyrithOnly[_]¬ª">polyrith</a></p><p><a href="#Mathlib.Tactic.Positivity.positivity">positivity</a></p><p><a href="#Mathlib.Tactic.Push.pull">pull</a></p><p><a href="#Mathlib.Tactic.Coherence.pure_coherence">pure_coherence</a></p><p><a href="#Mathlib.Tactic.Push.pushStx">push</a></p><p><a href="#Mathlib.Tactic.Push.push_neg">push_neg</a></p><p><a href="#Mathlib.Tactic.Qify.qify">qify</a></p><p><a href="#Mathlib.Tactic.tacticRecover_">recover</a></p><p><a href="#Mathlib.Tactic.tacticReduce__">reduce</a></p><p><a href="#Tactic.ReduceModChar.reduce_mod_char">reduce_mod_char</a></p><p><a href="#Mathlib.Tactic.refoldLetStx">refold_let</a></p><p><a href="#Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª">rel</a></p><p><a href="#Mathlib.Tactic.rename'">rename'</a></p><p><a href="#Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª">rename_bvar</a></p><p><a href="#Mathlib.Tactic.tacticRepeat1_">repeat1</a></p><p><a href="#Mathlib.Tactic.replace'">replace</a></p><p><a href="#TopCat.Presheaf.restrict_tac">restrict_tac</a></p><p><a href="#TopCat.Presheaf.restrict_tac?">restrict_tac?</a></p><p><a href="#Mathlib.Tactic.DepRewrite.depRewriteSeq">rewrite!</a></p><p><a href="#CategoryTheory.rfl_cat">rfl_cat</a></p><p><a href="#Mathlib.Tactic.Rify.rify">rify</a></p><p><a href="#Mathlib.Tactic.RingNF.ring">ring</a></p><p><a href="#Mathlib.Tactic.Ring.ring1">ring1</a></p><p><a href="#Mathlib.Tactic.RingNF.ringNF">ring_nf</a></p><p><a href="#Mathlib.Tactic.rsuffices">rsuffices</a></p><p><a href="#Mathlib.Tactic.DepRewrite.depRwSeq">rw!</a></p><p><a href="#Mathlib.Tactic.LibraryRewrite.tacticRw??">rw??</a></p><p><a href="#Mathlib.Tactic.RewriteSearch.tacticRw_search_">rw_search</a></p><p><a href="#Mathlib.Tactic.Says.says">says</a></p><p><a href="#Mathlib.Tactic.setTactic">set</a></p><p><a href="#Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª">simp_intro</a></p><p><a href="#Mathlib.Tactic.tacticSimp_rw___">simp_rw</a></p><p><a href="#tacticSleep_heartbeats_">sleep_heartbeats</a></p><p><a href="#Mathlib.Tactic.Slice.sliceLHS">slice_lhs</a></p><p><a href="#Mathlib.Tactic.Slice.sliceRHS">slice_rhs</a></p><p><a href="#RatFunc.tacticSmul_tac">smul_tac</a></p><p><a href="#CategoryTheory.sorryIfSorry">sorry_if_sorry</a></p><p><a href="#Mathlib.Tactic.TautoSet.specialize_all">specialize_all</a></p><p><a href="#Mathlib.Tactic.splitIfs">split_ifs</a></p><p><a href="#Mathlib.Tactic.subsingletonStx">subsingleton</a></p><p><a href="#CategoryTheory.tacticSubst_hom_lift___">subst_hom_lift</a></p><p><a href="#Mathlib.Tactic.Substs.substs">substs</a></p><p><a href="#Mathlib.Tactic.successIfFailWithMsg">success_if_fail_with_msg</a></p><p><a href="#Mathlib.Tactic.¬´tacticSwap_var__,,¬ª">swap_var</a></p><p><a href="#Mathlib.Tactic.Tauto.tauto">tauto</a></p><p><a href="#Mathlib.Tactic.TautoSet.tacticTauto_set">tauto_set</a></p><p><a href="#Mathlib.Tactic.TFAE.tfaeFinish">tfae_finish</a></p><p><a href="#Mathlib.Tactic.TFAE.tfaeHave">tfae_have</a></p><p><a href="#Set.tacticToFinite_tac">toFinite_tac</a></p><p><a href="#Set.tacticTo_encard_tac">to_encard_tac</a></p><p><a href="#Lean.Parser.Tactic.trace">trace</a></p><p><a href="#Mathlib.Tactic.tacticTry_this__">try_this</a></p><p><a href="#tacticType_check_">type_check</a></p><p><a href="#Mathlib.Tactic.InteractiveUnfold.tacticUnfold?">unfold?</a></p><p><a href="#Mathlib.Tactic.unfoldProjsStx">unfold_projs</a></p><p><a href="#intervalIntegral.tacticUniqueDiffWithinAt_Ici_Iic_univ">uniqueDiffWithinAt_Ici_Iic_univ</a></p><p><a href="#Tactic.Interactive.tacticUnit_interval">unit_interval</a></p><p><a href="#Mathlib.Tactic.useSyntax">use</a></p><p><a href="#Mathlib.Tactic.tacticUse_discharger">use_discharger</a></p><p><a href="#tacticUse_finite_instance">use_finite_instance</a></p><p><a href="#CategoryTheory.ComposableArrows.tacticValid">valid</a></p><p><a href="#MeasureTheory.tacticVolume_tac">volume_tac</a></p><p><a href="#Mathlib.Tactic.BicategoryCoherence.whisker_simps">whisker_simps</a></p><p><a href="#Mathlib.Tactic.tacticWhnf__">whnf</a></p><p><a href="#witt_truncateFun_tac">witt_truncateFun_tac</a></p><p><a href="#Mathlib.Tactic.wlog">wlog</a></p><p><a href="#Mathlib.Tactic.Zify.zify">zify</a></p></nav><main>
<p>The tactic language is a special-purpose programming language for constructing proofs, indicated using the keyword <code>by</code>.</p><div id="¬´tactic#adaptation_note_¬ª"><h2>#adaptation_note</h2><p><p><code>#adaptation_note /-- comment -/</code> adds an adaptation note to the current file.
Adaptation notes are comments that are used to indicate that a piece of code
has been changed to accommodate a change in Lean core.
They typically require further action/maintenance to be taken in the future.</p><p>This syntax works as a command, or inline in tactic or term mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/AdaptationNote.html#¬´tactic#adaptation_note_¬ª">Mathlib.Tactic.AdaptationNote</a></dd></dl></div><div id="Mathlib.Tactic.¬´tactic#check__¬ª"><h2>#check</h2><p><p><code>#check t</code> elaborates the term <code>t</code> and then pretty prints it with its type as <code>e : ty</code>.</p><p>If <code>t</code> is an identifier, then it pretty prints a type declaration form
for the global constant <code>t</code> instead.
Use <code>#check (t)</code> to pretty print it as an elaborated expression.</p><p>Like the <code>#check</code> command, the <code>#check</code> tactic allows stuck typeclass instance problems.
These become metavariables in the output.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Check.html#Mathlib.Tactic.¬´tactic#check__¬ª">Mathlib.Tactic.Check</a></dd></dl></div><div id="Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª"><h2>#count_heartbeats</h2><p><p><code>#count_heartbeats tac</code> counts the heartbeats used by the tactic sequence <code>tac</code>
and prints an info line with the number of heartbeats.</p><ul><li><code>#count_heartbeats! n in tac</code>, where <code>n</code> is an optional natural number literal, runs <code>tac</code>
<code>n</code> times on the same goal while counting the heartbeats, and prints an info line with range and
standard deviation. <code>n</code> can be left out, and defaults to 10.</li></ul><p>Example:</p><pre><code>example : 1 + 1 = 2 := by
  -- The next line will print an info message of this format; the exact number may vary.
  -- info: 4646
  #count_heartbeats simp

example : 1 + 1 = 2 := by
  -- The next line will print an info message of this format; the exact numbers may vary.
  -- info: Min: 4 Max: 4 StdDev: 2%
  #count_heartbeats! 37 in simp
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Util/CountHeartbeats.html#Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª">Mathlib.Util.CountHeartbeats</a></dd></dl></div><div id="Mathlib.Tactic.DefEqAbuse.defeqAbuse"><h2>#defeq_abuse</h2><p><blockquote><p><strong>WARNING:</strong> <code>#defeq_abuse</code> is an experimental tool intended to assist with breaking
changes to transparency handling. Its syntax may change at any time, and it may not behave as
expected. Please report unexpected behavior <a href="https://leanprover.zulipchat.com/#narrow/channel/113488-general/topic/backward.2EisDefEq.2ErespectTransparency/with/575685551">on Zulip</a>.</p></blockquote><p><code>#defeq_abuse in tac</code> runs <code>tac</code> with <code>backward.isDefEq.respectTransparency</code> both <code>true</code> and
<code>false</code>. If the tactic succeeds with <code>false</code> but fails with <code>true</code>, it identifies the specific
<code>isDefEq</code> checks that fail with the stricter setting.</p><p>The tactic still executes (using the permissive setting if needed), so proofs remain valid
during debugging.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqAbuse.html#Mathlib.Tactic.DefEqAbuse.defeqAbuse">Mathlib.Tactic.DefEqAbuse</a></dd></dl></div><div id="Mathlib.Tactic.Find.¬´tactic#find_¬ª"><h2>#find</h2><p><p><code>#find t</code> finds definitions and theorems whose result type matches the term <code>t</code>, and prints them as
info lines. Use holes in <code>t</code> to indicate arbitrary subexpressions, for example <code>#find _ ‚àß _</code> will
match any conjunction. <code>#find</code> is also available as a command.
<code>#find</code> will not affect the goal by itself and should be removed from the finished proof.</p><p>There is also the <code>find</code> tactic which looks for lemmas which are <code>apply</code>able against the current
goal.</p><p>Examples:</p><pre><code class="language-lean">#find _ + _ = _ + _
#find ?n + _ = _ + ?n
#find (_ : Nat) + _ = _ + _
#find Nat ‚Üí Nat
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Find.html#Mathlib.Tactic.Find.¬´tactic#find_¬ª">Mathlib.Tactic.Find</a></dd></dl></div><div id="Mathlib.Tactic.Abel.abel"><h2>abel</h2><p><p><code>abel</code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code>abel</code> and its variants work as both tactics and conv tactics.</p><ul><li><code>abel1</code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code>abel1!</code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Œ±] (a b : Œ±) : a + (b + a) = a + a + b := by abel
example [AddCommGroup Œ±] (a : Œ±) : (3 : ‚Ñ§) ‚Ä¢ a = a + (2 : ‚Ñ§) ‚Ä¢ a := by abel
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">Mathlib.Tactic.Abel</a></dd></dl></div><div id="Mathlib.Tactic.acChange"><h2>ac_change</h2><p><p><code>ac_change t</code> on a goal <code>‚ä¢ t'</code> changes the goal to <code>‚ä¢ t</code> and adds new goals for proving the equality
<code>t' = t</code> using congruence, then tries proving these goals by associativity and commutativity. The
goals are created like <code>congr!</code> would.
In other words, <code>ac_change t</code> is like <code>convert_to t</code> followed by <code>ac_refl</code>.</p><p>Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>t</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert_to</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><ul><li><code>ac_change t using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence
is applied. For example, if the main goal is <code>‚ä¢ <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> ((a * b + 1) + c)</code>,
then <code>ac_change <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> ((1 + a * b) + c) using 2</code> solves the side goals, and
<code>ac_change <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> ((1 + a * b) + c) using 3</code> (or more) results in two (impossible) goals
<code>‚ä¢ 1 = a * b</code> and <code>‚ä¢ a * b = 1</code>.
The default value for <code>n</code> is 1.</li></ul><p>Example:</p><pre><code class="language-lean">example (a b c d e f g N : ‚Ñï) : (a + b) + (c + d) + (e + f) + g ‚â§ N := by
  ac_change a + d + e + f + c + g + b ‚â§ _
  -- ‚ä¢ a + d + e + f + c + g + b ‚â§ N
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange">Mathlib.Tactic.Convert</a></dd></dl></div><div id="CategoryTheory.aesop_cat"><h2>aesop_cat</h2><p><p>A thin wrapper for <code>aesop</code> which adds the <code>CategoryTheory</code> rule set and
allows <code>aesop</code> to look through semireducible definitions when calling <code>intros</code>.
This tactic fails when it is unable to solve the goal, making it suitable for
use in auto-params.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="CategoryTheory.aesop_cat?"><h2>aesop_cat?</h2><p><p>We also use <code>aesop_cat?</code> to pass along a <code>Try this</code> suggestion when using <code>aesop_cat</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat?">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="CategoryTheory.aesop_cat_nonterminal"><h2>aesop_cat_nonterminal</h2><p><p>A variant of <code>aesop_cat</code> which does not fail when it is unable to solve the
goal. Use this only for exploration! Nonterminal <code>aesop</code> is even worse than
nonterminal <code>simp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat_nonterminal">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="aesop_graph"><h2>aesop_graph</h2><p><p>A variant of the <code>aesop</code> tactic for use in the graph library. Changes relative
to standard <code>aesop</code>:</p><ul><li>We use the <code><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#SimpleGraph">SimpleGraph</a></code> rule set in addition to the default rule sets.</li><li>We instruct Aesop's <code>intro</code> rule to unfold with <code>default</code> transparency.</li><li>We instruct Aesop to fail if it can't fully solve the goal. This allows us to
use <code><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph">aesop_graph</a></code> for auto-params.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph">Mathlib.Combinatorics.SimpleGraph.Basic</a></dd></dl></div><div id="aesop_graph?"><h2>aesop_graph?</h2><p><p>Use <code><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph?">aesop_graph?</a></code> to pass along a <code>Try this</code> suggestion when using <code><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph">aesop_graph</a></code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph?">Mathlib.Combinatorics.SimpleGraph.Basic</a></dd></dl></div><div id="aesop_graph_nonterminal"><h2>aesop_graph_nonterminal</h2><p><p>A variant of <code><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph">aesop_graph</a></code> which does not fail if it is unable to solve the goal.
Use this only for exploration! Nonterminal Aesop is even worse than nonterminal <code>simp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Combinatorics/SimpleGraph/Basic.html#aesop_graph_nonterminal">Mathlib.Combinatorics.SimpleGraph.Basic</a></dd></dl></div><div id="Matroid.aesop_mat"><h2>aesop_mat</h2><p><p>The <code>aesop_mat</code> tactic attempts to prove a set is contained in the ground set of a matroid.
It uses a <code>[Matroid]</code> ruleset, and is allowed to fail.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Combinatorics/Matroid/Basic.html#Matroid.aesop_mat">Mathlib.Combinatorics.Matroid.Basic</a></dd></dl></div><div id="Mathlib.Tactic.tacticAlgebraize__"><h2>algebraize</h2><p><p>Tactic that, given <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code>s, adds the corresponding <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> and (if possible)
<code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances, as well as <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> corresponding to <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code> properties available
as hypotheses.</p><p>Example: given <code>f : A ‚Üí+* B</code> and <code>g : B ‚Üí+* C</code>, and <code>hf : f.FiniteType</code>, <code>algebraize [f, g]</code> will
add the instances <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> A B</code>, <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> B C</code>, and <code><a href="./Mathlib/RingTheory/FiniteType.html#Algebra.FiniteType">Algebra.FiniteType</a> A B</code>.</p><p>See the <code>algebraize</code> tag for instructions on what properties can be added.</p><p>The tactic also comes with a configuration option <code>properties</code>. If set to <code>true</code> (default), the
tactic searches through the local context for <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code> properties that can be converted to
<code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> properties. The macro <code>algebraize_only</code> calls
<code>algebraize -properties</code>,
so in other words it only adds <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> and <code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Algebraize.html#Mathlib.Tactic.tacticAlgebraize__">Mathlib.Tactic.Algebraize</a></dd></dl></div><div id="Mathlib.Tactic.tacticAlgebraize_only__"><h2>algebraize_only</h2><p><p>Version of <code>algebraize</code>, which only adds <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> instances and <code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances,
but does not try to add any instances about any properties tagged with
<code>@[algebraize]</code>, like for example <code><a href="./Mathlib/Data/Finite/Defs.html#Finite">Finite</a></code> or <code><a href="./Mathlib/RingTheory/IntegralClosure/IsIntegral/Defs.html#IsIntegral">IsIntegral</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Algebraize.html#Mathlib.Tactic.tacticAlgebraize_only__">Mathlib.Tactic.Algebraize</a></dd></dl></div><div id="Mathlib.Tactic.tacticApply_At_"><h2>apply</h2><p><p><code>apply t at i</code> uses forward reasoning with <code>t</code> at the hypothesis <code>i</code>.
Explicitly, if <code>t : Œ±‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±·µ¢ ‚Üí ‚ãØ ‚Üí Œ±‚Çô</code> and <code>i</code> has type <code>Œ±·µ¢</code>, then this tactic adds
metavariables/goals for any terms of <code>Œ±‚±º</code> for <code>j = 1, ‚Ä¶, i-1</code>,
then replaces the type of <code>i</code> with <code>Œ±·µ¢‚Çä‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±‚Çô</code> by applying those metavariables and the
original <code>i</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ApplyAt.html#Mathlib.Tactic.tacticApply_At_">Mathlib.Tactic.ApplyAt</a></dd></dl></div><div id="Mathlib.Tactic.applyFun"><h2>apply_fun</h2><p><p>Apply a function to an equality or inequality in either a local hypothesis or the goal.</p><ul><li>If we have <code>h : a = b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a = f b</code>.</li><li>If we have <code>h : a ‚â§ b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a ‚â§ f b</code>,
and create a subsidiary goal <code><a href="./Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> f</code>.
<code>apply_fun</code> will automatically attempt to discharge this subsidiary goal using <code>mono</code>,
or an explicit solution can be provided with <code>apply_fun f at h using P</code>, where <code>P : <a href="./Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> f</code>.</li><li>If we have <code>h : a &lt; b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a &lt; f b</code>,
and create a subsidiary goal <code><a href="./Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> f</code> and behaves as in the previous case.</li><li>If we have <code>h : a ‚â† b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a ‚â† f b</code>,
and create a subsidiary goal <code>Injective f</code> and behaves as in the previous two cases.</li><li>If the goal is <code>a ‚â† b</code>, <code>apply_fun f</code> will replace this with <code>f a ‚â† f b</code>.</li><li>If the goal is <code>a = b</code>, <code>apply_fun f</code> will replace this with <code>f a = f b</code>,
and create a subsidiary goal <code>injective f</code>.
<code>apply_fun</code> will automatically attempt to discharge this subsidiary goal using local hypotheses,
or if <code>f</code> is actually an <code><a href="./Mathlib/Logic/Equiv/Defs.html#Equiv">Equiv</a></code>,
or an explicit solution can be provided with <code>apply_fun f using P</code>, where <code>P : Injective f</code>.</li><li>If the goal is <code>a ‚â§ b</code> (or similarly for <code>a &lt; b</code>), and <code>f</code> is actually an <code><a href="./Mathlib/Order/Hom/Basic.html#OrderIso">OrderIso</a></code>,
<code>apply_fun f</code> will replace the goal with <code>f a ‚â§ f b</code>.
If <code>f</code> is anything else (e.g. just a function, or an <code><a href="./Mathlib/Logic/Equiv/Defs.html#Equiv">Equiv</a></code>), <code>apply_fun</code> will fail.</li></ul><p>Typical usage is:</p><pre><code class="language-lean">open Function

example (X Y Z : Type) (f : X ‚Üí Y) (g : Y ‚Üí Z) (H : Injective &lt;| g ‚àò f) :
    Injective f := by
  intro x x' h
  apply_fun g at h
  exact H h
</code></pre><p>The function <code>f</code> is handled similarly to how it would be handled by <code>refine</code> in that <code>f</code> can contain
placeholders. Named placeholders (like <code>?a</code> or <code>?_</code>) will produce new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFun">Mathlib.Tactic.ApplyFun</a></dd></dl></div><div id="GradedMonoid.tacticApply_gmonoid_gnpowRec_succ_tac"><h2>apply_gmonoid_gnpowRec_succ_tac</h2><p><p>A tactic to for use as an optional value for <code>GMonoid.gnpow_succ'</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Algebra/GradedMonoid.html#GradedMonoid.tacticApply_gmonoid_gnpowRec_succ_tac">Mathlib.Algebra.GradedMonoid</a></dd></dl></div><div id="GradedMonoid.tacticApply_gmonoid_gnpowRec_zero_tac"><h2>apply_gmonoid_gnpowRec_zero_tac</h2><p><p>A tactic to for use as an optional value for <code>GMonoid.gnpow_zero'</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Algebra/GradedMonoid.html#GradedMonoid.tacticApply_gmonoid_gnpowRec_zero_tac">Mathlib.Algebra.GradedMonoid</a></dd></dl></div><div id="Mathlib.Tactic.tacticApply_rewrite___"><h2>apply_rewrite</h2><p><p><code>apply_rewrite [rules]</code> is a shorthand for <code>grewrite +implicationHyp [rules]</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticApply_rewrite___">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.applyRwSeq"><h2>apply_rw</h2><p><p><code>apply_rw [rules]</code> is a shorthand for <code>grw +implicationHyp [rules]</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.applyRwSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="ArithmeticFunction.arith_mult"><h2>arith_mult</h2><p><p><code>arith_mult</code> solves goals of the form <code>IsMultiplicative f</code> for <code>f : <a href="./Mathlib/NumberTheory/ArithmeticFunction/Defs.html#ArithmeticFunction">ArithmeticFunction</a> R</code>
by applying lemmas tagged with the user attribute <code>arith_mult</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ArithMult.html#ArithmeticFunction.arith_mult">Mathlib.Tactic.ArithMult</a></dd></dl></div><div id="ArithmeticFunction.arith_mult?"><h2>arith_mult?</h2><p><p><code>arith_mult</code> solves goals of the form <code>IsMultiplicative f</code> for <code>f : <a href="./Mathlib/NumberTheory/ArithmeticFunction/Defs.html#ArithmeticFunction">ArithmeticFunction</a> R</code>
by applying lemmas tagged with the user attribute <code>arith_mult</code>, and prints out the generated
proof term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ArithMult.html#ArithmeticFunction.arith_mult?">Mathlib.Tactic.ArithMult</a></dd></dl></div><div id="Mathlib.Tactic.tacticAssumption'"><h2>assumption'</h2><p><p>Try calling <code>assumption</code> on all goals; succeeds if it closes at least one goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticAssumption'">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Group.aux_group‚ÇÅ"><h2>aux_group‚ÇÅ</h2><p><p>Auxiliary tactic for the <code>group</code> tactic. Calls the simplifier only.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.aux_group‚ÇÅ">Mathlib.Tactic.Group</a></dd></dl></div><div id="Mathlib.Tactic.Group.aux_group‚ÇÇ"><h2>aux_group‚ÇÇ</h2><p><p>Auxiliary tactic for the <code>group</code> tactic. Calls <code>ring_nf</code> to normalize exponents.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.aux_group‚ÇÇ">Mathlib.Tactic.Group</a></dd></dl></div><div id="tacticBddDefault"><h2>bddDefault</h2><p><p>Sets are automatically bounded or cobounded in complete lattices. To use the same statements
in complete and conditionally complete lattices but let automation fill automatically the
boundedness proofs in complete lattices, we use the tactic <code>bddDefault</code> in the statements,
in the form <code>(hA : <a href="./Mathlib/Order/Bounds/Defs.html#BddAbove">BddAbove</a> A := by bddDefault)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Bounds/Basic.html#tacticBddDefault">Mathlib.Order.Bounds.Basic</a></dd></dl></div><div id="Mathlib.Tactic.betaReduceStx"><h2>beta_reduce</h2><p><p><code>beta_reduce at loc</code> completely beta reduces the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>This means that whenever there is an applied lambda expression such as
<code>(fun x =&gt; f x) y</code> then the argument is substituted into the lambda expression
yielding an expression such as <code>f y</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.Bicategory.tacticBicategory"><h2>bicategory</h2><p><p>Use the coherence theorem for bicategories to solve equations in a bicategory,
where the two sides only differ by replacing strings of bicategory structural morphisms
(that is, associators, unitors, and identities)
with different strings of structural morphisms with the same source and target.</p><p>That is, <code>bicategory</code> can handle goals of the form
<code>a ‚â´ f ‚â´ b ‚â´ g ‚â´ c = a' ‚â´ f ‚â´ b' ‚â´ g ‚â´ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>bicategory_coherence</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Bicategory/Basic.html#Mathlib.Tactic.Bicategory.tacticBicategory">Mathlib.Tactic.CategoryTheory.Bicategory.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Bicategory.tacticBicategory_coherence"><h2>bicategory_coherence</h2><p><p>Close the goal of the form <code>Œ∑.hom = Œ∏.hom</code>, where <code>Œ∑</code> and <code>Œ∏</code> are 2-isomorphisms made up only of
associators, unitors, and identities.</p><pre><code class="language-lean">example {B : Type} [Bicategory B] {a : B} :
  (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom := by
  bicategory_coherence
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Bicategory/PureCoherence.html#Mathlib.Tactic.Bicategory.tacticBicategory_coherence">Mathlib.Tactic.CategoryTheory.Bicategory.PureCoherence</a></dd></dl></div><div id="Mathlib.Tactic.BicategoryCoherence.tacticBicategory_coherence"><h2>bicategory_coherence</h2><p><p>Coherence tactic for bicategories.
Use <code>pure_coherence</code> instead, which is a frontend to this one.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/BicategoryCoherence.html#Mathlib.Tactic.BicategoryCoherence.tacticBicategory_coherence">Mathlib.Tactic.CategoryTheory.BicategoryCoherence</a></dd></dl></div><div id="Mathlib.Tactic.Bicategory.tacticBicategory_nf"><h2>bicategory_nf</h2><p><p>Normalize the both sides of an equality.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Bicategory/Basic.html#Mathlib.Tactic.Bicategory.tacticBicategory_nf">Mathlib.Tactic.CategoryTheory.Bicategory.Basic</a></dd></dl></div><div id="Nat.tacticBitwise_assoc_tac"><h2>bitwise_assoc_tac</h2><p><p>Proving associativity of bitwise operations in general essentially boils down to a huge case
distinction, so it is shorter to use this tactic instead of proving it in the general case.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Nat/Bitwise.html#Nat.tacticBitwise_assoc_tac">Mathlib.Data.Nat.Bitwise</a></dd></dl></div><div id="Mathlib.Tactic.Borelize.tacticBorelize___"><h2>borelize</h2><p><p>The behaviour of <code>borelize Œ±</code> depends on the existing assumptions on <code>Œ±</code>.</p><ul><li>if <code>Œ±</code> is a topological space with instances <code>[MeasurableSpace Œ±] [BorelSpace Œ±]</code>, then
<code>borelize Œ±</code> replaces the former instance by <code><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#borel">borel</a> Œ±</code>;</li><li>otherwise, <code>borelize Œ±</code> adds instances <code><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#borel">borel</a> Œ± : <a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#MeasurableSpace">MeasurableSpace</a> Œ±</code> and <code>‚ü®rfl‚ü© : <a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#BorelSpace">BorelSpace</a> Œ±</code>.</li></ul><p>Finally, <code>borelize Œ± Œ≤ Œ≥</code> runs <code>borelize Œ±; borelize Œ≤; borelize Œ≥</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#Mathlib.Tactic.Borelize.tacticBorelize___">Mathlib.MeasureTheory.Constructions.BorelSpace.Basic</a></dd></dl></div><div id="¬´tacticBound[_]¬ª"><h2>bound</h2><p><p><code>bound</code> tactic for proving inequalities via straightforward recursion on expression structure.</p><p>An example use case is</p><pre><code>-- Calc example: A weak lower bound for `z ‚Ü¶ z^2 + c`
<a href="./Mathlib/Tactic/Lemma.html#lemma">lemma</a> le_sqr_add (c z : ‚Ñù) (cz : ‚Äñc‚Äñ ‚â§ ‚Äñz‚Äñ) (z3 : 3 ‚â§ ‚Äñz‚Äñ) :
    2 * ‚Äñz‚Äñ ‚â§ ‚Äñz^2 + c‚Äñ := by
  calc ‚Äñz^2 + c‚Äñ
    _ ‚â• ‚Äñz^2‚Äñ - ‚Äñc‚Äñ := by bound
    _ ‚â• ‚Äñz^2‚Äñ - ‚Äñz‚Äñ := by  bound
    _ ‚â• (‚Äñz‚Äñ - 1) * ‚Äñz‚Äñ := by
      rw [mul_comm, mul_sub_one, ‚Üê pow_two, ‚Üê norm_pow]
    _ ‚â• 2 * ‚Äñz‚Äñ := by bound
</code></pre><p><code>bound</code> is built on top of <code>aesop</code>, and uses</p><ol><li>Apply lemmas registered via the <code>@[bound]</code> attribute</li><li>Forward lemmas registered via the <code>@[bound_forward]</code> attribute</li><li>Local hypotheses from the context</li><li>Optionally: additional hypotheses provided as <code>bound [h‚ÇÄ, h‚ÇÅ]</code> or similar. These are added to the
context as if by <code>have := h·µ¢</code>.</li></ol><p>The functionality of <code>bound</code> overlaps with <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code>gcongr</code>, but can jump back and forth
between <code>0 ‚â§ x</code> and <code>x ‚â§ y</code>-type inequalities.  For example, <code>bound</code> proves
<code>0 ‚â§ c ‚Üí b ‚â§ a ‚Üí 0 ‚â§ a * c - b * c</code>
by turning the goal into <code>b * c ‚â§ a * c</code>, then using <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_right">mul_le_mul_of_nonneg_right</a></code>.  <code>bound</code> also
contains lemmas for goals of the form <code>1 ‚â§ x, 1 &lt; x, x ‚â§ 1, x &lt; 1</code>.  Conversely, <code>gcongr</code> can prove
inequalities for more types of relations, supports all <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> functionality, and is likely
faster since it is more specialized (not built atop <code>aesop</code>).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Bound.html#¬´tacticBound[_]¬ª">Mathlib.Tactic.Bound</a></dd></dl></div><div id="Mathlib.Tactic.ByCases.byCases!"><h2>by_cases!</h2><p><p><code>by_cases! h : p</code> runs the <code><a href="./Mathlib/Logic/Basic.html#by_cases">by_cases</a> h : p</code> tactic, followed by
<code>push_neg at h</code> in the second subgoal. For example,</p><ul><li><code>by_cases! h : a &lt; b</code> creates one goal with hypothesis <code>h : a &lt; b</code> and
another with <code>h : b ‚â§ a</code>.</li><li><code>by_cases! h : a ‚â† b</code> creates one goal with hypothesis <code>h : a ‚â† b</code> and
another with <code>h : a = b</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ByCases.html#Mathlib.Tactic.ByCases.byCases!">Mathlib.Tactic.ByCases</a></dd></dl></div><div id="Mathlib.Tactic.ByContra.byContra!"><h2>by_contra!</h2><p><p>If the target of the main goal is a proposition <code>p</code>,
<code>by_contra!</code> reduces the goal to proving <code>False</code> using the additional hypothesis <code>this : ¬¨ p</code>.
<code>by_contra! h</code> can be used to name the hypothesis <code>h : ¬¨ p</code>.
The hypothesis <code>¬¨ p</code> will be normalized using <code>push_neg</code>.
For instance, <code>¬¨ a &lt; b</code> will be changed to <code>b ‚â§ a</code>.
<code>by_contra!</code> can be used with <code>rcases</code> patterns.
For instance, <code>by_contra! rfl</code> on <code>‚ä¢ s.Nonempty</code> will substitute the equality <code>s = ‚àÖ</code>,
and <code>by_contra! ‚ü®hp, hq‚ü©</code> on <code>‚ä¢ ¬¨ p ‚à® ¬¨ q</code> will introduce <code>hp : p</code> and <code>hq : q</code>.
<code>by_contra! h : q</code> will normalize negations in <code>¬¨ p</code>, normalize negations in <code>q</code>,
and then check that the two normalized forms are equal.
The resulting hypothesis is the pre-normalized form, <code>q</code>.
If the name <code>h</code> is not explicitly provided, then <code>this</code> will be used as name.
This tactic uses classical reasoning.
It is a variant on the tactic <code><a href="./Mathlib/Logic/Basic.html#by_contra">by_contra</a></code>.
Examples:</p><pre><code class="language-lean">example : 1 &lt; 2 := by
  by_contra! h
  -- h : 2 ‚â§ 1 ‚ä¢ False

example : 1 &lt; 2 := by
  by_contra! h : ¬¨ 1 &lt; 2
  -- h : ¬¨ 1 &lt; 2 ‚ä¢ False
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ByContra.html#Mathlib.Tactic.ByContra.byContra!">Mathlib.Tactic.ByContra</a></dd></dl></div><div id="Lean.Elab.Tactic.tacticCalc?"><h2>calc?</h2><p><p>Create a <code>calc</code> proof.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/Calc.html#Lean.Elab.Tactic.tacticCalc?">Mathlib.Tactic.Widget.Calc</a></dd></dl></div><div id="cancelDenoms"><h2>cancel_denoms</h2><p><p><code>cancel_denoms</code> attempts to remove numerals from the denominators of fractions.
It works on propositions that are field-valued inequalities.</p><pre><code class="language-lean">variable [LinearOrderedField Œ±] (a b c : Œ±)

example (h : a / 5 + b / 4 &lt; c) : 4*a + 5*b &lt; 20*c := by
  cancel_denoms at h
  exact h

example (h : a &gt; 0) : a / 5 &gt; 0 := by
  cancel_denoms
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CancelDenoms/Core.html#cancelDenoms">Mathlib.Tactic.CancelDenoms.Core</a></dd></dl></div><div id="Mathlib.Tactic.cases'"><h2>cases'</h2><p><p><code>cases' x</code>, where the variable <code>x</code> has inductive type <code>t</code>, splits the main goal,
producing one goal for each constructor of <code>t</code>, in which <code>x</code> is replaced by that constructor
applied to newly introduced variables. This is a backwards-compatible variant of the
<code>cases</code> tactic in Lean 4 core.</p><p>Prefer <code>cases</code>, <code>rcases</code>, or <code>obtain</code> when possible, because these tactics promote
structured proofs.</p><ul><li><code>cases' x with n1 n2 ...</code> names the arguments to the constructors. This is the main difference
with <code>cases</code> in core Lean.</li><li><code>cases' e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then performs induction on the resulting variable.</li><li><code>cases' h : e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then splits by cases on the resulting variable, adding to each goal the hypothesis
<code>h : e = _</code> where <code>_</code> is the constructor instance.</li><li><code>cases' x using r</code> uses <code>r</code> as the case matching rule. Here <code>r</code> should be a term whose result type
is of the form <code>C t1 t2 ...</code>, where <code>C</code> is a bound variable and <code>t1</code>, <code>t2</code>, ... (if present) are
bound variables.</li></ul><p>Example:</p><pre><code>example (h : p ‚à® q) : q ‚à® p := by
  cases' h with hp hq
  ¬∑ exact Or.inr hp
  ¬∑ exact Or.inl hq

-- Though the following equivalent spellings should be preferred
example (h : p ‚à® q) : q ‚à® p := by
  cases h with
  | inl hp =&gt; exact Or.inr hp
  | inr hq =&gt; exact Or.inl hq

example (h : p ‚à® q) : q ‚à® p := by
  rcases h with hp | hq
  ¬∑ exact Or.inr hp
  ¬∑ exact Or.inl hq
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Cases.html#Mathlib.Tactic.cases'">Mathlib.Tactic.Cases</a></dd></dl></div><div id="Mathlib.Tactic.ENatToNat.tacticCases_first_enat"><h2>cases_first_enat</h2><p><p>Finds the first <code><a href="./Mathlib/Data/ENat/Defs.html#ENat">ENat</a></code> in the context and applies the <code>cases</code> tactic to it.
Then simplifies expressions involving <code>‚ä§</code> using the <code>enat_to_nat_top</code> simp set.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ENatToNat.html#Mathlib.Tactic.ENatToNat.tacticCases_first_enat">Mathlib.Tactic.ENatToNat</a></dd></dl></div><div id="Mathlib.Tactic.casesType"><h2>cases_type</h2><p><p><code>cases_type I</code> searches for a hypothesis <code>h : type</code> where <code>I</code> has the form <code>(I ...)</code>, and splits the
main goal by cases on <code>h</code>. <code>cases_type p</code> fails if no hypothesis type has the identifier <code>I</code> as its
head symbol.</p><ul><li><code>cases_type I_1 ... I_n</code> searches for a hypothesis <code>h : type</code> where <code>type</code> has one or more of
<code>I_1</code>, ..., <code>I_n</code> as its head symbol, and splits the main goal by cases on <code>h</code>.</li><li><code>cases_type* I</code> repeatedly performs case splits until no more hypothesis type has <code>I</code> as its head
symbol. This shorthand for <code>¬∑ repeat cases_type I</code>.</li><li><code>cases_type! p</code> and <code>cases_type!* p</code> skip a hypothesis if the main goal would be replaced with two
or more subgoals.</li></ul><p>Example:</p><pre><code>example (h : a ‚àß b ‚à® c ‚àß d) (h2 : e ‚àß f) : True := by
  -- The following tactic destructs all conjunctions and disjunctions in the current context.
  cases_type* Or And
  ¬∑ clear ‚Äπa‚Ä∫ ‚Äπb‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; (fail_if_success clear ‚Äπc‚Ä∫); trivial
  ¬∑ clear ‚Äπc‚Ä∫ ‚Äπd‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; trivial
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="Mathlib.Tactic.casesM"><h2>casesm</h2><p><p><code>casesm p</code> searches for the first hypothesis <code>h : type</code> where <code>type</code> matches the term <code>p</code>,
and splits the main goal by cases on <code>h</code>. Use holes in <code>p</code> to indicate arbitrary subexpressions,
for example <code>casesm _ ‚àß _</code> will match any conjunction. <code>casesm p</code> fails if no hypothesis type
matches <code>p</code>.</p><ul><li><code>casesm p_1, ..., p_n</code> searches for a hypothesis <code>h : type</code> where <code>type</code> matches one or more of
the given patterns <code>p_1</code>, ... <code>p_n</code>, and splits the main goal by cases on <code>h</code>.</li><li><code>casesm* p</code> repeatedly performs case splits until no more hypothesis type matches <code>p</code>.
This is a more efficient and compact version of <code>¬∑ repeat casesm p</code>.
It is more efficient because the pattern is compiled once.</li><li><code>casesm! p</code> and <code>casesm!* p</code> skip a hypothesis if the main goal would be replaced with two or more
subgoals.</li></ul><p>Example:</p><pre><code>example (h : a ‚àß b ‚à® c ‚àß d) (h2 : e ‚àß f) : True := by
  -- The following tactic destructs all conjunctions and disjunctions in the current context.
  casesm* _‚à®_, _‚àß_
  ¬∑ clear ‚Äπa‚Ä∫ ‚Äπb‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; (fail_if_success clear ‚Äπc‚Ä∫); trivial
  ¬∑ clear ‚Äπc‚Ä∫ ‚Äπd‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; trivial
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="CategoryTheory.cat_disch"><h2>cat_disch</h2><p><p>A tactic for discharging easy category theory goals, widely used as an autoparameter.
Currently this defaults to the <code>aesop_cat</code> wrapper around <code>aesop</code>, but by setting
the option <code><a href="./Mathlib/CategoryTheory/Category/Init.html#mathlib.tactic.category.grind">mathlib.tactic.category.grind</a></code> to <code>true</code>, it will use the <code>grind</code> tactic instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cat_disch">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="cfcContTac"><h2>cfc_cont_tac</h2><p><p>A tactic used to automatically discharge goals relating to the continuous functional calculus,
specifically concerning continuity of the functions involved.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcContTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="cfcTac"><h2>cfc_tac</h2><p><p>A tactic used to automatically discharge goals relating to the continuous functional calculus,
specifically whether the element satisfies the predicate.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="cfcZeroTac"><h2>cfc_zero_tac</h2><p><p>A tactic used to automatically discharge goals relating to the non-unital continuous functional
calculus, specifically concerning whether <code>f 0 = 0</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcZeroTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="change?"><h2>change?</h2><p><p><code><a href="./Mathlib/Tactic/Change.html#change?">change?</a> term</code> unifies <code>term</code> with the current goal, then suggests explicit <code>change</code> syntax
that uses the resulting unified term.</p><p>If <code>term</code> is not present, <code><a href="./Mathlib/Tactic/Change.html#change?">change?</a></code> suggests the current goal itself. This is useful after tactics
which transform the goal while maintaining definitional equality, such as <code>dsimp</code>; those preceding
tactic calls can then be deleted.</p><pre><code class="language-lean">example : (fun x : Nat =&gt; x) 0 = 1 := by
  <a href="./Mathlib/Tactic/Change.html#change?">change?</a> 0 = _  -- `Try this: change 0 = 1`
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Change.html#change?">Mathlib.Tactic.Change</a></dd></dl></div><div id="Mathlib.Tactic.CheckCompositions.tacticCheck_compositions"><h2>check_compositions</h2><p><p>For each composition <code>f ‚â´ g</code> in the goal,
which internally is represented as <code>CategoryStruct.comp C inst X Y Z f g</code>,
infer the types of <code>f</code> and <code>g</code> and check whether their sources and targets agree
with <code>X</code>, <code>Y</code>, and <code>Z</code> at &quot;instances and reducible&quot; transparency,
reporting any discrepancies.</p><p>An example:</p><pre><code>example (j : J) :
    colimit.Œπ ((F ‚ãô G) ‚ãô H) j ‚â´ (preservesColimitIso (G ‚ãô H) F).inv =
      H.map (G.map (colimit.Œπ F j)) := by

  -- We know which <a href="./Mathlib/Tactic/Lemma.html#lemma">lemma</a> we want to use, and it's even a simp lemma, but `rw`
  -- won't let us apply it
  fail_if_success rw [Œπ_preservesColimitIso_inv]
  fail_if_success rw [Œπ_preservesColimitIso_inv (G ‚ãô H)]
  fail_if_success simp only [Œπ_preservesColimitIso_inv]

  -- This would work:
  -- erw [Œπ_preservesColimitIso_inv (G ‚ãô H)]

  -- `check_compositions` checks if the two morphisms we're composing are
  -- composed by abusing defeq, and indeed it tells us that we are abusing
  -- definitional associativity of composition of functors here: it prints
  -- the following.

  -- info: In composition
  --   colimit.Œπ ((F ‚ãô G) ‚ãô H) j ‚â´ (preservesColimitIso (G ‚ãô H) F).inv
  -- the source of
  --   (preservesColimitIso (G ‚ãô H) F).inv
  -- is
  --   colimit (F ‚ãô G ‚ãô H)
  -- but should be
  --   colimit ((F ‚ãô G) ‚ãô H)

  check_compositions

  -- In this case, we can &quot;fix&quot; this by reassociating in the goal, but
  -- usually at this point the right thing to do is to back off and
  -- check how we ended up with a bad goal in the first place.
  dsimp only [Functor.assoc]

  -- This would work now, but it is not needed, because simp works as well
  -- rw [Œπ_preservesColimitIso_inv]

  simp
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/CheckCompositions.html#Mathlib.Tactic.CheckCompositions.tacticCheck_compositions">Mathlib.Tactic.CategoryTheory.CheckCompositions</a></dd></dl></div><div id="Mathlib.Tactic.Choose.choose"><h2>choose</h2><p><ul><li><p><code>choose a b h h' using hyp</code> takes a hypothesis <code>hyp</code> of the form
<code>‚àÄ (x : X) (y : Y), ‚àÉ (a : A) (b : B), P x y a b ‚àß Q x y a b</code>
for some <code>P Q : X ‚Üí Y ‚Üí A ‚Üí B ‚Üí Prop</code> and outputs
into context a function <code>a : X ‚Üí Y ‚Üí A</code>, <code>b : X ‚Üí Y ‚Üí B</code> and two assumptions:
<code>h : ‚àÄ (x : X) (y : Y), P x y (a x y) (b x y)</code> and
<code>h' : ‚àÄ (x : X) (y : Y), Q x y (a x y) (b x y)</code>. It also works with dependent versions.</p></li><li><p><code>choose! a b h h' using hyp</code> does the same, except that it will remove dependency of
the functions on propositional arguments if possible. For example if <code>Y</code> is a proposition
and <code>A</code> and <code>B</code> are nonempty in the above example then we will instead get
<code>a : X ‚Üí A</code>, <code>b : X ‚Üí B</code>, and the assumptions
<code>h : ‚àÄ (x : X) (y : Y), P x y (a x) (b x)</code> and
<code>h' : ‚àÄ (x : X) (y : Y), Q x y (a x) (b x)</code>.</p></li></ul><p>The <code>using hyp</code> part can be omitted,
which will effectively cause <code>choose</code> to start with an <code>intro hyp</code>.</p><p>Like <code>intro</code>, the <code>choose</code> tactic supports type annotations to specify the expected type
of the introduced variables. This is useful for documentation and for catching mistakes early:</p><pre><code>example (h : ‚àÉ n : ‚Ñï, n &gt; 0) : True := by
  choose (n : ‚Ñï) (hn : n &gt; 0) using h
  trivial
</code></pre><p>If the provided type does not match the actual type, an error is raised.</p><p>Examples:</p><pre><code>example (h : ‚àÄ n m : ‚Ñï, ‚àÉ i j, m = n + i ‚à® m + j = n) : True := by
  choose i j h using h
  guard_hyp i : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  guard_hyp j : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  guard_hyp h : ‚àÄ (n m : ‚Ñï), m = n + i n m ‚à® m + j n m = n
  trivial
</code></pre><pre><code>example (h : ‚àÄ i : ‚Ñï, i &lt; 7 ‚Üí ‚àÉ j, i &lt; j ‚àß j &lt; i+i) : True := by
  choose! f h h' using h
  guard_hyp f : ‚Ñï ‚Üí ‚Ñï
  guard_hyp h : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí i &lt; f i
  guard_hyp h' : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí f i &lt; i + i
  trivial
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose">Mathlib.Tactic.Choose</a></dd></dl></div><div id="Mathlib.Tactic.tacticClean_"><h2>clean</h2><p><p>(Deprecated) <code>clean t</code> is a macro for <code>exact clean% t</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Clean.html#Mathlib.Tactic.tacticClean_">Mathlib.Tactic.Clean</a></dd></dl></div><div id="Lean.Elab.Tactic.clearExceptTactic"><h2>clear</h2><p><p>Clears all hypotheses it can, except those provided after a minus sign. Example:</p><pre><code>  clear * - h‚ÇÅ h‚ÇÇ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ClearExcept.html#Lean.Elab.Tactic.clearExceptTactic">Mathlib.Tactic.ClearExcept</a></dd></dl></div><div id="Mathlib.Tactic.clear!"><h2>clear!</h2><p><p>A variant of <code>clear</code> which clears not only the given hypotheses but also any other hypotheses
depending on them</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ClearExclamation.html#Mathlib.Tactic.clear!">Mathlib.Tactic.ClearExclamation</a></dd></dl></div><div id="Mathlib.Tactic.clear_"><h2>clear_</h2><p><p>Clear all hypotheses starting with <code>_</code>, like <code>_match</code> and <code>_let_match</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Clear_.html#Mathlib.Tactic.clear_">Mathlib.Tactic.Clear_</a></dd></dl></div><div id="Mathlib.Tactic.clearAuxDecl"><h2>clear_aux_decl</h2><p><p>This tactic clears all auxiliary declarations from the context.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearAuxDecl">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Coherence.coherence"><h2>coherence</h2><p><p>Use the coherence theorem for monoidal categories to solve equations in a monoidal equation,
where the two sides only differ by replacing strings of monoidal structural morphisms
(that is, associators, unitors, and identities)
with different strings of structural morphisms with the same source and target.</p><p>That is, <code>coherence</code> can handle goals of the form
<code>a ‚â´ f ‚â´ b ‚â´ g ‚â´ c = a' ‚â´ f ‚â´ b' ‚â´ g ‚â´ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>pure_coherence</code>.</p><p>(If you have very large equations on which <code>coherence</code> is unexpectedly failing,
you may need to increase the typeclass search depth,
using e.g. <code>set_option synthInstance.maxSize 500</code>.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Coherence.html#Mathlib.Tactic.Coherence.coherence">Mathlib.Tactic.CategoryTheory.Coherence</a></dd></dl></div><div id="tacticCompareOfLessAndEq_rfl"><h2>compareOfLessAndEq_rfl</h2><p><p>This attempts to prove that a given instance of <code>compare</code> is equal to <code>compareOfLessAndEq</code> by
introducing the arguments and trying the following approaches in order:</p><ol><li>seeing if <code>rfl</code> works</li><li>seeing if the <code>compare</code> at hand is nonetheless essentially <code>compareOfLessAndEq</code>, but, because of
implicit arguments, requires us to unfold the defs and split the <code>if</code>s in the definition of
<code>compareOfLessAndEq</code></li><li>seeing if we can split by cases on the arguments, then see if the defs work themselves out
(useful when <code>compare</code> is defined via a <code>match</code> statement, as it is for <code>Bool</code>)</li></ol></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Defs/LinearOrder.html#tacticCompareOfLessAndEq_rfl">Mathlib.Order.Defs.LinearOrder</a></dd></dl></div><div id="Mathlib.Tactic.ComputeDegree.computeDegree"><h2>compute_degree</h2><p><p><code>compute_degree</code> is a tactic to solve goals of the form</p><ul><li><code>natDegree f = d</code>,</li><li><code>degree f = d</code>,</li><li><code>natDegree f ‚â§ d</code> (or <code>&lt;</code>),</li><li><code>degree f ‚â§ d</code> (or <code>&lt;</code>),</li><li><code>coeff f d = r</code>, if <code>d</code> is the degree of <code>f</code>.</li></ul><p>The tactic may leave goals of the form <code>d' = d</code>, <code>d' ‚â§ d</code>, <code>d' &lt; d</code>, or <code>r ‚â† 0</code>, where <code>d'</code> in <code>‚Ñï</code>
or <code><a href="./Mathlib/Order/TypeTags.html#WithBot">WithBot</a> ‚Ñï</code> is the tactic's guess of the degree, and <code>r</code> is the coefficient's guess of the
leading coefficient of <code>f</code>.</p><p><code>compute_degree</code> applies <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> to the left-hand side of all side goals, trying to close them.</p><p>The variant <code>compute_degree!</code> first applies <code>compute_degree</code>.
Then it uses <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> on all the remaining goals and tries <code>assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ComputeDegree.html#Mathlib.Tactic.ComputeDegree.computeDegree">Mathlib.Tactic.ComputeDegree</a></dd></dl></div><div id="Congr!.congr!"><h2>congr!</h2><p><p><code>congr!</code> tries to prove the main goal by repeatedly applying congruence rules. For example, on a
goal of the form <code>‚ä¢ f a1 a2 ... = f b1 b2 ...</code>, <code>congr!</code> will make new goals <code>‚ä¢ a1 = b1</code>,
<code>‚ä¢ a2 = b2</code>, ...</p><p><code>congr!</code> is a more powerful version of the <code>congr</code> tactic that uses congruence lemmas (tagged with
<code>@[congr]</code>), reflexivity rules (tagged with <code>@[refl]</code>) and proof discharging strategies. The full
list of congruence proof strategies is documented in the module <code><a href="./Mathlib/Tactic/CongrExclamation.html">Mathlib.Tactic.CongrExclamation</a></code>.
The <code>congr!</code> tactic is used by the <code>convert</code> and <code>convert_to</code> tactics.</p><ul><li><code>congr! n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence is
applied. For example, if the main goal is <code>n + n + 1 = 2 * n + 1</code>, then <code>congr! 1</code> results in one
goal, <code>‚ä¢ n + n = 2 * n</code>, and <code>congr! 2</code> (or more) results in two (impossible) goals
<code>‚ä¢ HAdd.hAdd = HMul.hMul</code> and <code>‚ä¢ n = 2</code>.
By default, the depth is unlimited.</li><li><code>congr! with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>congr! (config := cfg)</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">Mathlib.Tactic.CongrExclamation</a></dd></dl></div><div id="Mathlib.Tactic.congrM"><h2>congrm</h2><p><p><code>congrm e</code> is a tactic for proving goals of the form <code>lhs = rhs</code>, <code>lhs ‚Üî rhs</code>, <code>lhs ‚âç rhs</code>,
or <code>R lhs rhs</code> when <code>R</code> is a reflexive relation.
The expression <code>e</code> is a pattern containing placeholders <code>?_</code>,
and this pattern is matched against <code>lhs</code> and <code>rhs</code> simultaneously.
These placeholders generate new goals that state that corresponding subexpressions
in <code>lhs</code> and <code>rhs</code> are equal.
If the placeholders have names, such as <code>?m</code>, then the new goals are given tags with those names.</p><p>Examples:</p><pre><code class="language-lean">example {a b c d : ‚Ñï} :
    Nat.pred a.succ * (d + (c + a.pred)) = Nat.pred b.succ * (b + (c + d.pred)) := by
  congrm Nat.pred (Nat.succ ?h1) * (?h2 + ?h3)
  /-  Goals left:
  case h1 ‚ä¢ a = b
  case h2 ‚ä¢ d = b
  case h3 ‚ä¢ c + a.pred = c + d.pred
  -/
  sorry
  sorry
  sorry

example {a b : ‚Ñï} (h : a = b) : (fun y : ‚Ñï =&gt; ‚àÄ z, a + a = z) = (fun x =&gt; ‚àÄ z, b + a = z) := by
  congrm fun x =&gt; ‚àÄ w, ?_ + a = w
  -- ‚ä¢ a = b
  exact h
</code></pre><p>The <code>congrm</code> command is a convenient frontend to <code>congr(...)</code> congruence quotations.
If the goal is an equality, <code>congrm e</code> is equivalent to <code>refine congr(e')</code> where <code>e'</code> is
built from <code>e</code> by replacing each placeholder <code>?m</code> by <code>$(?m)</code>.
The pattern <code>e</code> is allowed to contain <code>$(...)</code> expressions to immediately substitute
equality proofs into the congruence, just like for congruence quotations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CongrM.html#Mathlib.Tactic.congrM">Mathlib.Tactic.CongrM</a></dd></dl></div><div id="tacticCongrm?"><h2>congrm?</h2><p><p>Display a widget panel allowing to generate a <code>congrm</code> call with holes specified by selecting
subexpressions in the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/CongrM.html#tacticCongrm?">Mathlib.Tactic.Widget.CongrM</a></dd></dl></div><div id="Mathlib.Tactic.constructorM"><h2>constructorm</h2><p><p><code>constructorm p_1, ..., p_n</code>, where the main goal has type <code>type</code>, applies the first matching
constructor for <code>type</code>, if <code>type</code> matches one of the given patterns. If <code>type</code> does not match any
of the patterns, <code>constructorm</code> fails.</p><ul><li><code>constructorm* p_1, ..., p_n</code> repeatedly applies a constructor until the goal no longer matches
<code>p_1</code>, ..., <code>p_n</code>. This is a more efficient and compact version of
<code>¬∑ repeat constructorm p_1, ..., p_n</code>. It is more efficient because the pattern is compiled once.</li></ul><p>Examples:</p><pre><code>example : True ‚àß (True ‚à® True) := by
  constructorm* _ ‚à® _, _ ‚àß _, True
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="tacticContinuity"><h2>continuity</h2><p><p><code>continuity</code> solves goals of the form <code><a href="./Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> f</code> by applying lemmas tagged with the attribute
<code>@[continuity]</code>. If the goal is not solved after attempting all rules, <code>continuity</code> fails.</p><p><code>fun_prop</code> is a (usually more powerful) alternative to <code>continuity</code>.</p><p>This tactic is extensible. Tagging lemmas with the <code>@[continuity]</code> attribute can allow <code>continuity</code>
to solve more goals.</p><ul><li><code>continuity?</code> reports the proof script found by <code>continuity</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Continuity.html#tacticContinuity">Mathlib.Tactic.Continuity</a></dd></dl></div><div id="Mathlib.Tactic.Contrapose.contrapose"><h2>contrapose</h2><p><p><code>contrapose</code> transforms the main goal into its contrapositive. If the goal has the form <code>‚ä¢ P ‚Üí Q</code>,
then <code>contrapose turns it into </code>‚ä¢ ¬¨ Q ‚Üí ¬¨ P<code>. If the goal has the form </code>‚ä¢ P ‚Üî Q<code>, then </code>contrapose<code>turns it into</code>‚ä¢ ¬¨ P ‚Üî ¬¨ Q`.</p><ul><li><code>contrapose h</code> on a goal of the form <code>h : P ‚ä¢ Q</code> turns the goal into <code>h : ¬¨ Q ‚ä¢ ¬¨ P</code>. This is
equivalent to <code>revert h; contrapose; intro h</code>.</li><li><code>contrapose h with new_h</code> uses the name <code>new_h</code> for the introduced hypothesis. This is equivalent
to <code>revert h; contrapose; intro new_h</code>.</li><li><code>contrapose!</code>, <code>contrapose! h</code> and <code>contrapose! h with new_h</code> push negation deeper into the goal
after contraposing (but before introducing the new hypothesis). See the <code>push_neg</code> tactic for more
details on the pushing algorithm.</li><li><code>contrapose! (config := cfg)</code> controls the options for negation pushing. All options for
<code><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.Config">Mathlib.Tactic.Push.Config</a></code> are supported:<ul><li><code>contrapose! +distrib</code> rewrites <code>¬¨ (p ‚àß q)</code> into <code>¬¨ p ‚à® ¬¨ q</code> instead of <code>p ‚Üí ¬¨ q</code>.</li></ul></li></ul><p>Examples:</p><pre><code class="language-lean4">variables (P Q R : Prop)

example (H : ¬¨ Q ‚Üí ¬¨ P) : P ‚Üí Q := by
  contrapose
  exact H

example (H : ¬¨ P ‚Üî ¬¨ Q) : P ‚Üî Q := by
  contrapose
  exact H

example (H : ¬¨ Q ‚Üí ¬¨ P) (h : P) : Q := by
  contrapose h
  exact H h

example (H : ¬¨ R ‚Üí P ‚Üí ¬¨ Q) : (P ‚àß Q) ‚Üí R := by
  contrapose!
  exact H

example (H : ¬¨ R ‚Üí ¬¨ P ‚à® ¬¨ Q) : (P ‚àß Q) ‚Üí R := by
  contrapose! +distrib
  exact H
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Contrapose.html#Mathlib.Tactic.Contrapose.contrapose">Mathlib.Tactic.Contrapose</a></dd></dl></div><div id="Mathlib.Tactic.Conv.tacticConv?"><h2>conv?</h2><p><p>Display a widget panel allowing to generate a <code>conv</code> call zooming to the subexpression selected
in the goal or in the type of a local hypothesis or let-decl.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/Conv.html#Mathlib.Tactic.Conv.tacticConv?">Mathlib.Tactic.Widget.Conv</a></dd></dl></div><div id="Mathlib.Tactic.Conv.convLHS"><h2>conv_lhs</h2><p><p><code>conv_lhs =&gt; cs</code> runs the <code>conv</code> tactic sequence <code>cs</code> on the left hand side of the target.</p><p>In general, for an <code>n</code>-ary operator as the target, it traverses into the second to last argument.
It is a synonym for <code>conv =&gt; arg -2; cs</code>.</p><ul><li><code>conv_lhs at h =&gt; cs</code> runs <code>cs</code> on the left hand side of hypothesis <code>h</code>.</li><li><code>conv_lhs in pat =&gt; cs</code> first looks for a subexpression matching <code>pat</code> (see also the <code>pattern</code>
conv tactic) and then traverses into the left hand side of this subexpression.
This syntax also supports the <code>occs</code> clause for the pattern.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convLHS">Mathlib.Tactic.Conv</a></dd></dl></div><div id="Mathlib.Tactic.Conv.convRHS"><h2>conv_rhs</h2><p><p><code>conv_rhs =&gt; cs</code> runs the <code>conv</code> tactic sequence <code>cs</code> on the right hand side of the target.</p><p>In general, for an <code>n</code>-ary operator as the target, it traverses into the last argument.
It is a synonym for <code>conv =&gt; arg -1; cs</code>.</p><ul><li><code>conv_rhs at h =&gt; cs</code> runs <code>cs</code> on the right hand side of hypothesis <code>h</code>.</li><li><code>conv_rhs in pat =&gt; cs</code> first looks for a subexpression matching <code>pat</code> (see the <code>pattern</code>
conv tactic) and then traverses into the right hand side of this subexpression.
This syntax also supports the <code>occs</code> clause for the pattern.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRHS">Mathlib.Tactic.Conv</a></dd></dl></div><div id="Mathlib.Tactic.convert"><h2>convert</h2><p><p><code>convert e</code>, where the term <code>e</code> is inferred to have type <code>t</code>, replaces the main goal <code>‚ä¢ t'</code> with new
goals for proving the equality <code>t' = t</code> using congruence. The goals are created like <code>congr!</code> would.
Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>e</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><p>See also <code>convert_to t</code>, where <code>t</code> specifies the expected type, instead of a proof term of type <code>t</code>.
In other words, <code>convert_to t</code> works like <code>convert (?_ : t)</code>. Both tactics use the same options.</p><ul><li><code>convert ‚Üê e</code> creates equality goals in the opposite direction (with the goal type on the right).</li><li><code>convert e using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence is
applied. For example, if the main goal is <code>‚ä¢ <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (n + n + 1)</code> and <code>e : <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (2 * n + 1)</code>, then
<code>convert e using 2</code> results in one goal, <code>‚ä¢ n + n = 2 * n</code>, and <code>convert e using 3</code> (or more)
results in two (impossible) goals <code>‚ä¢ HAdd.hAdd = HMul.hMul</code> and <code>‚ä¢ n = 2</code>.
By default, the depth is unlimited.</li><li><code>convert e with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>convert (config := cfg) e</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul><p>Examples:</p><pre><code class="language-lean">-- `convert using` controls the depth of congruence.
example {n : ‚Ñï} (e : <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (2 * n + 1)) :
    <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (n + n + 1) := by
  convert e using 2
  -- One goal: ‚ä¢ n + n = 2 * n
  ring
</code></pre><pre><code class="language-lean">-- `convert` can fail where `exact` succeeds.
example (h : p 0) : p 1 := by
  fail_if_success
    convert h -- fails, left-over goal 1 = 0
    done
  exact h -- <a href="./Mathlib/Control/Basic.html#succeeds">succeeds</a>

```lean
-- `convert with` names introduced variables.
example (p q : Nat ‚Üí Prop) (h : ‚àÄ Œµ &gt; 0, p Œµ) :
    ‚àÄ Œµ &gt; 0, q Œµ := by
  convert h using 2 with Œµ hŒµ
  -- Goal now looks like:
  -- hŒµ : Œµ &gt; 0
  -- ‚ä¢ q Œµ ‚Üî p Œµ
  sorry


</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert">Mathlib.Tactic.Convert</a></dd></dl></div><div id="Mathlib.Tactic.convertTo"><h2>convert_to</h2><p><p><code>convert_to t</code> on a goal <code>‚ä¢ t'</code> changes the goal to <code>‚ä¢ t</code> and adds new goals for proving the
equality <code>t' = t</code> using congruence. The goals are created like <code>congr!</code> would.
Any remaining congruence goals come before the main goal.
Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>t</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert_to</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><p><code>convert e</code>, where <code>e</code> is a term of type <code>t</code>, uses <code>e</code> to close the new main goal. In other words,
<code>convert e</code> works like <code>convert_to t; refine e</code>. Both tactics use the same options.</p><ul><li><code>convert_to ty at h</code> changes the type of the local hypothesis <code>h</code> to <code>ty</code>. If later local
hypotheses or the goal depend on <code>h</code>, then <code>convert_to t at h</code> may leave a copy of <code>h</code>.</li><li><code>convert_to ‚Üê t</code> creates equality goals in the opposite direction (with the original goal type on
the right).</li><li><code>convert_to t using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence
is applied. For example, if the main goal is <code>‚ä¢ <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (n + n + 1)</code>,
then <code>convert_to <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (2 * n + 1) using 2</code> results in one goal, <code>‚ä¢ n + n = 2 * n</code>, and
<code>convert_to <a href="./Mathlib/Algebra/Prime/Defs.html#Prime">Prime</a> (2 * n + 1) using 3</code> (or more) results in two (impossible) goals
<code>‚ä¢ HAdd.hAdd = HMul.hMul</code> and <code>‚ä¢ n = 2</code>.
The default value for <code>n</code> is 1.</li><li><code>convert_to t with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>convert_to (config := cfg) t</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo">Mathlib.Tactic.Convert</a></dd></dl></div><div id="CategoryTheory.Discrete.tacticDiscrete_cases"><h2>discrete_cases</h2><p><p>A simple tactic to run <code>cases</code> on any <code>Discrete Œ±</code> hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete.tacticDiscrete_cases">Mathlib.CategoryTheory.Discrete.Basic</a></dd></dl></div><div id="tacticEconstructor"><h2>econstructor</h2><p><p><code>econstructor</code>, on a goal which is an inductive type, solves it by applying the first matching
constructor, creating new goals for non-dependent arguments to the constructor in the same order.
This is like <code>constructor</code> except only non-dependent arguments are shown as new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Constructor.html#tacticEconstructor">Mathlib.Tactic.Constructor</a></dd></dl></div><div id="Mathlib.Tactic.ENatToNat.tacticEnat_to_nat"><h2>enat_to_nat</h2><p><p><code>enat_to_nat</code> shifts all <code><a href="./Mathlib/Data/ENat/Defs.html#ENat">ENat</a></code>s in the context to <code>Nat</code>, rewriting propositions about them.
A typical use case is <code>enat_to_nat; lia</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ENatToNat.html#Mathlib.Tactic.ENatToNat.tacticEnat_to_nat">Mathlib.Tactic.ENatToNat</a></dd></dl></div><div id="Mathlib.Tactic.Erw?.erw?"><h2>erw?</h2><p><p><code>erw? [r, ...]</code> calls <code>erw [r, ...]</code> (at hypothesis <code>h</code> if written <code>erw [r, ...] at h</code>),
and then attempts to identify any subexpression which would block the use of <code>rw</code> instead.
It does so by identifying subexpressions which are defeq, but not at reducible transparency.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.erw?">Mathlib.Tactic.ErwQuestion</a></dd></dl></div><div id="Mathlib.Tactic.etaExpandStx"><h2>eta_expand</h2><p><p><code>eta_expand at loc</code> eta expands all sub-expressions at the given location.
It also beta reduces any applications of eta expanded terms, so it puts it
into an eta-expanded &quot;normal form.&quot;
This also exists as a <code>conv</code>-mode tactic.</p><p>For example, if <code>f</code> takes two arguments, then <code>f</code> becomes <code>fun x y =&gt; f x y</code>
and <code>f x</code> becomes <code>fun y =&gt; f x y</code>.</p><p>This can be useful to turn, for example, a raw <code>HAdd.hAdd</code> into <code>fun x y =&gt; x + y</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.etaReduceStx"><h2>eta_reduce</h2><p><p><code>eta_reduce at loc</code> eta reduces all sub-expressions at the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>For example, <code>fun x y =&gt; f x y</code> becomes <code>f</code> after eta reduction.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.etaStructStx"><h2>eta_struct</h2><p><p><code>eta_struct at loc</code> transforms structure constructor applications such as <code>S.mk x.1 ... x.n</code>
(pretty printed as, for example, <code>{a := x.a, b := x.b, ...}</code>) into <code>x</code>.
This also exists as a <code>conv</code>-mode tactic.</p><p>The transformation is known as eta reduction for structures, and it yields definitionally
equal expressions.</p><p>For example, given <code>x : Œ± √ó Œ≤</code>, then <code>(x.1, x.2)</code> becomes <code>x</code> after this transformation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticExistsi_,,¬ª"><h2>existsi</h2><p><p><code>existsi e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> instantiates existential quantifiers in the main goal by using <code>e‚ÇÅ</code>, <code>e‚ÇÇ</code>, ...
as witnesses. <code>existsi e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> is equivalent to <code>refine ‚ü®e‚ÇÅ, e‚ÇÇ, ‚ãØ, ?_‚ü©</code>.</p><p>See also <code>exists</code>: <code>exists e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> is equivalent to <code>existsi e‚ÇÅ, e‚ÇÇ, ‚ãØ; try trivial</code>.</p><p>Examples:</p><pre><code class="language-lean">example : ‚àÉ x : Nat, x = x := by
  existsi 42
  rfl

example : ‚àÉ x : Nat, ‚àÉ y : Nat, x = y := by
  existsi 42, 42
  rfl
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ExistsI.html#Mathlib.Tactic.¬´tacticExistsi_,,¬ª">Mathlib.Tactic.ExistsI</a></dd></dl></div><div id="Mathlib.Tactic.ExtractGoal.extractGoal"><h2>extract_goal</h2><p><p><code>extract_goal</code> formats the current goal as a stand-alone theorem or definition after
cleaning up the local context of irrelevant variables.</p><p>A variable is <em>relevant</em> if (1) it occurs in the target type, (2) there is a relevant variable
that depends on it, or (3) the type of the variable is a proposition that depends on a
relevant variable.
If the target is <code>False</code>, then for convenience <code>extract_goal</code> includes all variables.</p><p>The tactic tries to produce an output that can be copy-pasted and just work,
but its success depends on whether the expressions are amenable
to being unambiguously pretty printed.
The tactic responds to pretty printing options.
For example, <code>set_option pp.all true in extract_goal</code> gives the <code>pp.all</code> form.</p><ul><li><code>extract_goal *</code> formats the current goal without cleaning up the local context.</li><li><code>extract_goal a b c ...</code> formats the current goal after removing everything that the given
variables <code>a</code>, <code>b</code>, <code>c</code>, ... do not depend on.</li><li><code>extract_goal ... using name</code> uses the name <code>name</code> for the theorem or definition rather than
the autogenerated name.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.extractGoal">Mathlib.Tactic.ExtractGoal</a></dd></dl></div><div id="Mathlib.Tactic.failIfNoProgress"><h2>fail_if_no_progress</h2><p><p><code>fail_if_no_progress tacs</code> evaluates <code>tacs</code>, and fails if no progress is made on the main goal
or the local context at reducible transparency.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FailIfNoProgress.html#Mathlib.Tactic.failIfNoProgress">Mathlib.Tactic.FailIfNoProgress</a></dd></dl></div><div id="tacticFconstructor"><h2>fconstructor</h2><p><p><code>fconstructor</code>, on a goal which is an inductive type, solves it by applying the first matching
constructor, creating new goals for all arguments to the constructor in the same order.
This is like <code>constructor</code> except the goals are not reordered.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Constructor.html#tacticFconstructor">Mathlib.Tactic.Constructor</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.field"><h2>field</h2><p><p>The <code>field</code> tactic proves equality goals in (semi-)fields. For example:</p><pre><code>example {x y : ‚Ñö} (hx : x + y ‚â† 0) : x / (x + y) + y / (x + y) = 1 := by
  field
example {a b : ‚Ñù} (ha : a ‚â† 0) : a / (a * b) - 1 / b = 0 := by field
</code></pre><p>The scope of the tactic is equality goals which are <em>universal</em>, in the sense that they are true in
any field in which the appropriate denominators don't vanish. (That is, they are consequences purely
of the field axioms.)</p><p>Checking the nonvanishing of the necessary denominators is done using a variety of tricks -- in
particular this part of the reasoning is non-universal, i.e. can be specific to the field at hand
(order properties, explicit <code>‚â† 0</code> hypotheses, <code><a href="./Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a></code> if that is known, etc).  The user can also
provide additional terms to help with the nonzeroness proofs. For example:</p><pre><code>example {K : Type*} [Field K] (hK : ‚àÄ x : K, x ^ 2 + 1 ‚â† 0) (x : K) :
    1 / (x ^ 2 + 1) + x ^ 2 / (x ^ 2 + 1) = 1 := by
  field [hK]
</code></pre><p>The <code>field</code> tactic is built from the tactics <code>field_simp</code> (which clears the denominators) and <code>ring</code>
(which proves equality goals universally true in commutative (semi-)rings). If <code>field</code> fails to
prove your goal, you may still be able to prove your goal by running the <code>field_simp</code> and <code>ring_nf</code>
normalizations in some order.  For example, this statement:</p><pre><code>example {a b : ‚Ñö} (H : b + a ‚â† 0) : a / (a + b) + b / (b + a) = 1
</code></pre><p>is not proved by <code>field</code> but is proved by <code>ring_nf at *; field</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Field.html#Mathlib.Tactic.FieldSimp.field">Mathlib.Tactic.Field</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.fieldSimp"><h2>field_simp</h2><p><p>The goal of <code>field_simp</code> is to bring expressions in (semi-)fields over a common denominator, i.e. to
reduce them to expressions of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code> contains any division
symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to <code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : ‚Ñö) (hy : 1 - y ‚â† 0) :
    ‚åäx / (1 - y) / (1 + y / (1 - y))‚åã &lt; 3 := by
  field_simp
  -- new goal: `‚ä¢ ‚åäx / (1 - y + y)‚åã &lt; 3`
</code></pre><p>The <code>field_simp</code> tactic will also clear denominators in field <em>(in)equalities</em>, by
cross-multiplying. For example, <code>field_simp</code> will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ‚â† 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  field_simp
  -- new goal: `‚ä¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>A very common pattern is <code>field_simp; ring</code> (clear denominators, then the resulting goal is
solvable by the axioms of a commutative ring). The finishing tactic <code>field</code> is a shorthand for this
pattern.</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
(e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>, check the
denominators of the resulting expression and provide proofs that they are nonzero/positive to enable
further progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp">Mathlib.Tactic.FieldSimp</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.tacticField_simp_discharge"><h2>field_simp_discharge</h2><p><p>Discharge strategy for the <code>field_simp</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FieldSimp/Discharger.html#Mathlib.Tactic.FieldSimp.tacticField_simp_discharge">Mathlib.Tactic.FieldSimp.Discharger</a></dd></dl></div><div id="Mathlib.Tactic.filterUpwards"><h2>filter_upwards</h2><p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô]</code> replaces a goal of the form <code>s ‚àà f</code> and terms
<code>h‚ÇÅ : t‚ÇÅ ‚àà f, ‚ãØ, h‚Çô : t‚Çô ‚àà f</code> with <code>‚àÄ x, x ‚àà t‚ÇÅ ‚Üí ‚ãØ ‚Üí x ‚àà t‚Çô ‚Üí x ‚àà s</code>.
The list is an optional parameter, <code>[]</code> being its default value.</p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ</code> is a short form for
<code>{ filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô], intro a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ }</code>.</p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] using e</code> is a short form for
<code>{ filter_upwards [h1, ‚ãØ, hn], exact e }</code>.</p><p>Combining both shortcuts is done by writing <code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ using e</code>.
Note that in this case, the <code>a·µ¢</code> terms can be used in <code>e</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Filter/Defs.html#Mathlib.Tactic.filterUpwards">Mathlib.Order.Filter.Defs</a></dd></dl></div><div id="Lean.Elab.Tactic.finCases"><h2>fin_cases</h2><p><p><code>fin_cases h</code> performs case analysis on a hypothesis of the form
<code>h : A</code>, where <code>[Fintype A]</code> is available, or
<code>h : a ‚àà A</code>, where <code>A : <a href="./Mathlib/Data/Finset/Defs.html#Finset">Finset</a> X</code>, <code>A : <a href="./Mathlib/Data/Multiset/Defs.html#Multiset">Multiset</a> X</code> or <code>A : List X</code>.</p><p>As an example, in</p><pre><code>example (f : ‚Ñï ‚Üí Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by
  fin_cases p; simp
  all_goals assumption
</code></pre><p>after <code>fin_cases p; simp</code>, there are three goals, <code>f 0</code>, <code>f 1</code>, and <code>f 2</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCases">Mathlib.Tactic.FinCases</a></dd></dl></div><div id="Fin.tacticFin_omega"><h2>fin_omega</h2><p><p>Preprocessor for <code>omega</code> to handle inequalities in <code>Fin</code>.
Note that this involves a lot of case splitting, so may be slow.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Fin/Basic.html#Fin.tacticFin_omega">Mathlib.Data.Fin.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Find.tacticFind"><h2>find</h2><p><p><code>find</code> finds definitions and theorems whose result type matches the current goal exactly,
and prints them as info lines.
In other words, <code>find</code> lists definitions and theorems that are <code>apply</code>able against the current goal.
<code>find</code> will not affect the goal by itself and should be removed from the finished proof.</p><p>For a command or tactic that takes the type to search for as an argument, see <code>#find</code>.</p><p>Example:</p><pre><code class="language-lean">example : True := by
  find
  -- True.intro: True
  -- trivial: True
  -- ...
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Find.html#Mathlib.Tactic.Find.tacticFind">Mathlib.Tactic.Find</a></dd></dl></div><div id="finiteness"><h2>finiteness</h2><p><p><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> proves goals of the form <code>*** &lt; ‚àû</code> and (equivalently) <code>*** ‚â† ‚àû</code> in the extended
nonnegative reals (<code>‚Ñù‚â•0‚àû</code>). Supports passing additional expressions as local hypotheses.</p><ul><li><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness?">finiteness?</a></code> additionally shows the proof that <code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> found</li><li><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness_nonterminal">finiteness_nonterminal</a></code> is a version of <code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> that may (but doesn't have to) close the
goal.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Finiteness.html#finiteness">Mathlib.Tactic.Finiteness</a></dd></dl></div><div id="RatFunc.tacticFrac_tac"><h2>frac_tac</h2><p><p>Solve equations for <code><a href="./Mathlib/FieldTheory/RatFunc/Defs.html#RatFunc">RatFunc</a> K</code> by working in <code><a href="./Mathlib/RingTheory/Localization/FractionRing.html#FractionRing">FractionRing</a> K[X]</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/FieldTheory/RatFunc/Basic.html#RatFunc.tacticFrac_tac">Mathlib.FieldTheory.RatFunc.Basic</a></dd></dl></div><div id="Mathlib.Meta.FunProp.funPropTacStx"><h2>fun_prop</h2><p><p><code>fun_prop</code> solves a goal of the form <code>P f</code>, where <code>P</code> is a predicate and <code>f</code> is a function,
by decomposing <code>f</code> into a composition of elementary functions, and proving <code>P</code> on each of those
by matching against a set of <code>@[fun_prop]</code> lemmas.</p><p>If <code>fun_prop</code> fails to solve a goal with the error &quot;No theorems found&quot;, you can solve this issue
by importing or adding new theorems tagged with the <code>@[fun_prop]</code> attribute. See the module
documentation for <code><a href="./Mathlib/Tactic/FunProp.html">Mathlib/Tactic/FunProp.lean</a></code> for a detailed explanation.</p><ul><li><code>fun_prop (disch := tac)</code> uses <code>tac</code> to solve potential side goals. Setting this option is
required to solve <code>ContinuousAt/On/Within</code> goals.</li><li><code>fun_prop [c, ...]</code> will unfold the constant(s) <code>c</code>, ... before decomposing <code>f</code>.</li><li><code>fun_prop (config := cfg)</code> sets advanced configuration options using <code>cfg : FunProp.Config</code>
(see <code>FunProp.Config</code> for details).</li></ul><p>Examples:</p><pre><code class="language-lean">example : <a href="./Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> (fun x : ‚Ñù ‚Ü¶ x * sin x) := by fun_prop
</code></pre><pre><code class="language-lean">-- Specify a discharger to solve `ContinuousAt`/`Within`/`On` goals:
example (y : ‚Ñù) (hy : y ‚â† 0) : <a href="./Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> (fun x : ‚Ñù ‚Ü¶ 1/x) y := by
  fun_prop (disch := assumption)

example (y : ‚Ñù) (hy : y ‚â† 0) : <a href="./Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> (fun x =&gt; x * (Real.log x) ^ 2 - <a href="./Mathlib/Analysis/Complex/Exponential.html#Real.exp">Real.exp</a> x / x) y := by
  fun_prop (disch := aesop)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FunProp/Elab.html#Mathlib.Meta.FunProp.funPropTacStx">Mathlib.Tactic.FunProp.Elab</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.tacticGcongr___With___"><h2>gcongr</h2><p><p>The <code>gcongr</code> tactic applies &quot;generalized congruence&quot; rules, reducing a relational goal
between an LHS and RHS.  For example,</p><pre><code>example {a b x c d : ‚Ñù} (h1 : a + 1 ‚â§ b + 1) (h2 : c + 2 ‚â§ d + 2) :
    x ^ 2 * a + c ‚â§ x ^ 2 * b + d := by
  gcongr
  ¬∑ linarith
  ¬∑ linarith
</code></pre><p>This example has the goal of proving the relation <code>‚â§</code> between an LHS and RHS both of the pattern</p><pre><code>x ^ 2 * ?_ + ?_
</code></pre><p>(with inputs <code>a</code>, <code>c</code> on the left and <code>b</code>, <code>d</code> on the right); after the use of
<code>gcongr</code>, we have the simpler goals <code>a ‚â§ b</code> and <code>c ‚â§ d</code>.</p><p>A depth limit or a pattern can be provided explicitly;
this is useful if a non-maximal match is desired:</p><pre><code>example {a b c d x : ‚Ñù} (h : a + c + 1 ‚â§ b + d + 1) :
    x ^ 2 * (a + c) + 5 ‚â§ x ^ 2 * (b + d) + 5 := by
  gcongr x ^ 2 * ?_ + 5 -- or `gcongr 2`
  linarith
</code></pre><p>The &quot;generalized congruence&quot; rules are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code><a href="./Mathlib/Algebra/Order/Monoid/Unbundled/Basic.html#add_le_add">add_le_add</a> (mul_le_mul_of_nonneg_left ?_ (Even.<a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#pow_nonneg">pow_nonneg</a> (even_two_mul 1) x)) ?_
</code></pre><p>using the generalized congruence lemmas <code><a href="./Mathlib/Algebra/Order/Monoid/Unbundled/Basic.html#add_le_add">add_le_add</a></code> and <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_left">mul_le_mul_of_nonneg_left</a></code>.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ‚â§ x ^ 2</code> in the above application of <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_left">mul_le_mul_of_nonneg_left</a></code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> but can also be extended. Side goals not discharged
in this way are left for the user.</p><p><code>gcongr</code> will descend into binders (for example sums or suprema). To name the bound variables,
use <code>with</code>:</p><pre><code>example {f g : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ n, f n ‚â§ g n) : ‚®Ü n, f n ‚â§ ‚®Ü n, g n := by
  gcongr with i
  exact h i
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr___With___">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="tacticGcongr?"><h2>gcongr?</h2><p><p>Display a widget panel allowing to generate a <code>gcongr</code> call with holes specified by selecting
subexpressions in the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/GCongr.html#tacticGcongr?">Mathlib.Tactic.Widget.GCongr</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.tacticGcongr_discharger"><h2>gcongr_discharger</h2><p><p><code>gcongr_discharger</code> is used by <code>gcongr</code> to discharge side goals.</p><p>This is an extensible tactic using <a href="https://lean-lang.org/doc/reference/4.29.0-rc2/find/?domain=Verso.Genre.Manual.section&amp;name=tactic-macro-extension"><code>macro_rules</code></a>.
By default it calls <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> (after importing the <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> tactic).
Example: <code>macro_rules | `(tactic| gcongr_discharger) =&gt; `(tactic| positivity)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="¬´tacticGeneralize'_:_=_¬ª"><h2>generalize'</h2><p><p>Backwards compatibility shim for <code>generalize</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Generalize.html#¬´tacticGeneralize'_:_=_¬ª">Mathlib.Tactic.Generalize</a></dd></dl></div><div id="WittVector.Tactic.ghostCalc"><h2>ghost_calc</h2><p><p><code>ghost_calc</code> is a tactic for proving identities between polynomial functions.
Typically, when faced with a goal like</p><pre><code class="language-lean">‚àÄ (x y : ùïé R), verschiebung (x * <a href="./Mathlib/Algebra/CharP/Lemmas.html#frobenius">frobenius</a> y) = verschiebung x * y
</code></pre><p>you can</p><ol><li>call <code>ghost_calc</code></li><li>do a small amount of manual work -- maybe nothing, maybe <code>rintro</code>, etc</li><li>call <code>ghost_simp</code></li></ol><p>and this will close the goal.</p><p><code>ghost_calc</code> cannot detect whether you are dealing with unary or binary polynomial functions.
You must give it arguments to determine this.
If you are proving a universally quantified goal like the above,
call <code>ghost_calc _ _</code>.
If the variables are introduced already, call <code>ghost_calc x y</code>.
In the unary case, use <code>ghost_calc _</code> or <code>ghost_calc x</code>.</p><p><code>ghost_calc</code> is a light wrapper around type class inference.
All it does is apply the appropriate extensionality lemma and try to infer the resulting goals.
This is subtle and Lean's elaborator doesn't like it because of the HO unification involved,
so it is easier (and prettier) to put it in a tactic script.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/IsPoly.html#WittVector.Tactic.ghostCalc">Mathlib.RingTheory.WittVector.IsPoly</a></dd></dl></div><div id="WittVector.¬´tacticGhost_fun_tac_,_¬ª"><h2>ghost_fun_tac</h2><p><p>An auxiliary tactic for proving that <code>ghostFun</code> respects the ring operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/Basic.html#WittVector.¬´tacticGhost_fun_tac_,_¬ª">Mathlib.RingTheory.WittVector.Basic</a></dd></dl></div><div id="WittVector.Tactic.ghostSimp"><h2>ghost_simp</h2><p><p>A macro for a common simplification when rewriting with ghost component equations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/IsPoly.html#WittVector.Tactic.ghostSimp">Mathlib.RingTheory.WittVector.IsPoly</a></dd></dl></div><div id="Mathlib.Tactic.grewriteSeq"><h2>grewrite</h2><p><p><code>grewrite [e]</code> is like <code>grw [e]</code>, but it doesn't try to close the goal with <code>rfl</code>.
This is analogous to <code>rw</code> and <code>rewrite</code>, where <code>rewrite</code> doesn't try to close the goal with <code>rfl</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.grewriteSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.Group.group"><h2>group</h2><p><p>Tactic for normalizing expressions in multiplicative groups, without assuming
commutativity, using only the group axioms without any information about which group
is manipulated.</p><p>(For additive commutative groups, use the <code>abel</code> tactic instead.)</p><p>Example:</p><pre><code class="language-lean">example {G : Type} [Group G] (a b c d : G) (h : c = (a*b^2)*((b*b)‚Åª¬π*a‚Åª¬π)*d) : a*c*d‚Åª¬π = a := by
  group at h -- normalizes `h` which becomes `h : c = d`
  rw [h]     -- the goal is now `a*d*d‚Åª¬π = a`
  group      -- which then normalized and closed
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.group">Mathlib.Tactic.Group</a></dd></dl></div><div id="Mathlib.Tactic.grwSeq"><h2>grw</h2><p><p><code>grw [e]</code> works just like <code>rw [e]</code>, but <code>e</code> can be a relation other than <code>=</code> or <code>‚Üî</code>.</p><p>For example:</p><pre><code class="language-lean">variable {a b c d n : ‚Ñ§}

example (h‚ÇÅ : a &lt; b) (h‚ÇÇ : b ‚â§ c) : a + d ‚â§ c + d := by
  grw [h‚ÇÅ, h‚ÇÇ]

example (h : a ‚â° b [ZMOD n]) : a ^ 2 ‚â° b ^ 2 [ZMOD n] := by
  grw [h]

example (h‚ÇÅ : a ‚à£ b) (h‚ÇÇ : b ‚à£ a ^ 2 * c) : a ‚à£ b ^ 2 * c := by
  grw [h‚ÇÅ] at *
  exact h‚ÇÇ
</code></pre><p>To replace the RHS with the LHS of the given relation, use the <code>‚Üê</code> notation (just like in <code>rw</code>):</p><pre><code>example (h‚ÇÅ : a &lt; b) (h‚ÇÇ : b ‚â§ c) : a + d ‚â§ c + d := by
  grw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ]
</code></pre><p>The strict inequality <code>a &lt; b</code> is turned into the non-strict inequality <code>a ‚â§ b</code> to rewrite with it.
A future version of <code>grw</code> may get special support for making better use of strict inequalities.</p><p>To rewrite only in the <code>n</code>-th position, use <code>nth_grw n</code>.
This is useful when <code>grw</code> tries to rewrite in a position that is not valid for the given relation.</p><p>To be able to use <code>grw</code>, the relevant lemmas need to be tagged with <code>@[gcongr]</code>.
To rewrite inside a transitive relation, you can also give it an <code><a href="./Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a></code> instance.</p><p>To let <code>grw</code> unfold more aggressively, as in <code>erw</code>, use <code>grw (transparency := default)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.grwSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="guardGoalNums"><h2>guard_goal_nums</h2><p><p><code>guard_goal_nums n</code> succeeds if there are exactly <code>n</code> goals and fails otherwise.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GuardGoalNums.html#guardGoalNums">Mathlib.Tactic.GuardGoalNums</a></dd></dl></div><div id="guardHypNums"><h2>guard_hyp_nums</h2><p><p><code>guard_hyp_nums n</code> succeeds if there are exactly <code>n</code> hypotheses and fails otherwise.</p><p>Note that, depending on what options are set, some hypotheses in the local context might
not be printed in the goal view. This tactic computes the total number of hypotheses,
not the number of visible hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GuardHypNums.html#guardHypNums">Mathlib.Tactic.GuardHypNums</a></dd></dl></div><div id="Mathlib.Tactic.Hint.hintStx"><h2>hint</h2><p><p>The <code>hint</code> tactic tries every tactic registered using <code>register_hint &lt;prio&gt; tac</code>,
and reports any that succeed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Hint.html#Mathlib.Tactic.Hint.hintStx">Mathlib.Tactic.Hint</a></dd></dl></div><div id="Mathlib.Tactic.induction'"><h2>induction'</h2><p><p><code>induction' x</code> applies induction on the variable <code>x</code> of the inductive type <code>t</code> to the main goal,
producing one goal for each constructor of <code>t</code>, in which <code>x</code> is replaced by that constructor
applied to newly introduced variables. <code>induction'</code> adds an inductive hypothesis for
each recursive argument to the constructor. This is a backwards-compatible variant of the
<code>induction</code> tactic in Lean 4 core.</p><p>Prefer <code>induction</code> when possible, because it promotes structured proofs.</p><ul><li><code>induction' x with n1 n2 ...</code> names the introduced hypotheses: arguments to constructors and
inductive hypotheses. This is the main difference with <code>induction</code> in core Lean.</li><li><code>induction' e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then performs induction on the resulting variable.</li><li><code>induction' h : e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then performs induction on the resulting variable, adding to each goal the hypothesis
<code>h : e = _</code> where <code>_</code> is the constructor instance.</li><li><code>induction' x using r</code> uses <code>r</code> as the principle of induction. Here <code>r</code> should be a term whose
result type is of the form <code>C t1 t2 ...</code>, where <code>C</code> is a bound variable and <code>t1</code>, <code>t2</code>, ... (if
present) are bound variables.</li><li><code>induction' x generalizing z1 z2 ...</code> generalizes over the local variables <code>z1</code>, <code>z2</code>, ... in the
inductive hypothesis.</li></ul><p>Example:</p><pre><code>open Nat

example (n : ‚Ñï) : 0 &lt; factorial n := by
  induction' n with n ih
  ¬∑ rw [factorial_zero]
    simp
  ¬∑ rw [factorial_succ]
    apply <a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#mul_pos">mul_pos</a> (succ_pos n) ih

-- Though the following equivalent spellings should be preferred
example (n : ‚Ñï) : 0 &lt; factorial n := by
  induction n
  case zero =&gt;
    rw [factorial_zero]
    simp
  case succ n ih =&gt;
    rw [factorial_succ]
    apply <a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#mul_pos">mul_pos</a> (succ_pos n) ih
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Cases.html#Mathlib.Tactic.induction'">Mathlib.Tactic.Cases</a></dd></dl></div><div id="Mathlib.Tactic.inferOptParam"><h2>infer_param</h2><p><p>Close a goal of the form <code>optParam Œ± a</code> or <code>autoParam Œ± stx</code> by using <code>a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/InferParam.html#Mathlib.Tactic.inferOptParam">Mathlib.Tactic.InferParam</a></dd></dl></div><div id="Lean.Elab.Tactic.inhabit"><h2>inhabit</h2><p><p><code>inhabit Œ±</code> tries to derive a <code>Nonempty Œ±</code> instance and
then uses it to make an <code>Inhabited Œ±</code> instance.
If the target is a <code>Prop</code>, this is done constructively. Otherwise, it uses <code>Classical.choice</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit">Mathlib.Tactic.Inhabit</a></dd></dl></div><div id="WittVector.initRing"><h2>init_ring</h2><p><p><code>init_ring</code> is an auxiliary tactic that discharges goals factoring <code>init</code> over ring operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/InitTail.html#WittVector.initRing">Mathlib.RingTheory.WittVector.InitTail</a></dd></dl></div><div id="Mathlib.Tactic.intervalCases"><h2>interval_cases</h2><p><p><code>interval_cases n</code> searches for upper and lower bounds on a variable <code>n</code>,
and if bounds are found,
splits into separate cases for each possible value of <code>n</code>.</p><p>As an example, in</p><pre><code>example (n : ‚Ñï) (w‚ÇÅ : n ‚â• 3) (w‚ÇÇ : n &lt; 5) : n = 3 ‚à® n = 4 := by
  interval_cases n
  all_goals simp
</code></pre><p>after <code>interval_cases n</code>, the goals are <code>3 = 3 ‚à® 3 = 4</code> and <code>4 = 3 ‚à® 4 = 4</code>.</p><p>You can also explicitly specify a lower and upper bound to use,
as <code>interval_cases using hl, hu</code>.
The hypotheses should be in the form <code>hl : a ‚â§ n</code> and <code>hu : n &lt; b</code>,
in which case <code>interval_cases</code> calls <code>fin_cases</code> on the resulting fact <code>n ‚àà <a href="./Mathlib/Order/Interval/Set/Defs.html#Set.Ico">Set.Ico</a> a b</code>.</p><p>You can specify a name <code>h</code> for the new hypothesis,
as <code>interval_cases h : n</code> or <code>interval_cases h : n using hl, hu</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases">Mathlib.Tactic.IntervalCases</a></dd></dl></div><div id="Mathlib.Tactic.introv"><h2>introv</h2><p><p>The tactic <code>introv</code> allows the user to automatically introduce the variables of a theorem and
explicitly name the non-dependent hypotheses.
Any dependent hypotheses are assigned their default names.</p><p>Examples:</p><pre><code>example : ‚àÄ a b : Nat, a = b ‚Üí b = a := by
  introv h,
  exact h.<a href="./Mathlib/Order/Defs/Unbundled.html#symm">symm</a>
</code></pre><p>The state after <code>introv h</code> is</p><pre><code>a b : ‚Ñï,
h : a = b
‚ä¢ b = a
</code></pre><pre><code>example : ‚àÄ a b : Nat, a = b ‚Üí ‚àÄ c, b = c ‚Üí a = c := by
  introv h‚ÇÅ h‚ÇÇ,
  exact h‚ÇÅ.<a href="./Mathlib/Order/Defs/Unbundled.html#trans">trans</a> h‚ÇÇ
</code></pre><p>The state after <code>introv h‚ÇÅ h‚ÇÇ</code> is</p><pre><code>a b : ‚Ñï,
h‚ÇÅ : a = b,
c : ‚Ñï,
h‚ÇÇ : b = c
‚ä¢ a = c
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.introv">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Filter.tacticIsBoundedDefault"><h2>isBoundedDefault</h2><p><p>Filters are automatically bounded or cobounded in complete lattices. To use the same statements
in complete and conditionally complete lattices but let automation fill automatically the
boundedness proofs in complete lattices, we use the tactic <code>isBoundedDefault</code> in the statements,
in the form <code>(hf : f.IsBounded (‚â•) := by isBoundedDefault)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Filter/IsBounded.html#Filter.tacticIsBoundedDefault">Mathlib.Order.Filter.IsBounded</a></dd></dl></div><div id="Mathlib.Tactic.ITauto.itauto"><h2>itauto</h2><p><p><code>itauto</code> solves the main goal when it is a tautology of intuitionistic propositional logic.
Unlike <code>grind</code> and <code>tauto!</code> this tactic never uses the law of excluded middle (without the <code>!</code>
option), and the proof search is tailored for this use case. <code>itauto</code> is complete for intuitionistic
propositional logic: it will solve any goal that is provable in this logic.</p><ul><li><code>itauto [a, b]</code> will additionally attempt case analysis on <code>a</code> and <code>b</code> assuming that it can derive
<code>Decidable a</code> and <code>Decidable b</code>.</li><li><code>itauto *</code> will case on all decidable propositions that it can find among the atomic propositions.</li><li><code>itauto!</code> will work as a classical SAT solver, but the algorithm is not very good in this
situation.</li><li><code>itauto! *</code> will case on all propositional atoms. <em>Warning:</em> This can blow up the proof search, so
it should be used sparingly.</li></ul><p>Example:</p><pre><code class="language-lean">example (p : Prop) : ¬¨ (p ‚Üî ¬¨ p) := by itauto
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto">Mathlib.Tactic.ITauto</a></dd></dl></div><div id="Mathlib.Tactic.lift"><h2>lift</h2><p><p>Lift an expression to another type.</p><ul><li>Usage: <code>'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?</code>.</li><li>If <code>n : ‚Ñ§</code> and <code>hn : n ‚â• 0</code> then the tactic <code>lift n to ‚Ñï using hn</code> creates a new
constant of type <code>‚Ñï</code>, also named <code>n</code> and replaces all occurrences of the old variable <code>(n : ‚Ñ§)</code>
with <code>‚Üën</code> (where <code>n</code> in the new variable). It will clear <code>n</code> from the context and
try to clear <code>hn</code> from the context.<ul><li>So for example the tactic <code>lift n to ‚Ñï using hn</code> transforms the goal
<code>n : ‚Ñ§, hn : n ‚â• 0, h : P n ‚ä¢ n = 3</code> to <code>n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3</code>
(here <code>P</code> is some term of type <code>‚Ñ§ ‚Üí Prop</code>).</li></ul></li><li>The argument <code>using hn</code> is optional, the tactic <code>lift n to ‚Ñï</code> does the same, but also creates a
new subgoal that <code>n ‚â• 0</code> (where <code>n</code> is the old variable).
This subgoal will be placed at the top of the goal list.<ul><li>So for example the tactic <code>lift n to ‚Ñï</code> transforms the goal
<code>n : ‚Ñ§, h : P n ‚ä¢ n = 3</code> to two goals
<code>n : ‚Ñ§, h : P n ‚ä¢ n ‚â• 0</code> and <code>n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3</code>.</li></ul></li><li>You can also use <code>lift n to ‚Ñï using e</code> where <code>e</code> is any expression of type <code>n ‚â• 0</code>.</li><li>Use <code>lift n to ‚Ñï with k</code> to specify the name of the new variable.</li><li>Use <code>lift n to ‚Ñï with k hk</code> to also specify the name of the equality <code>‚Üëk = n</code>. In this case, <code>n</code>
will remain in the context. You can use <code>rfl</code> for the name of <code>hk</code> to substitute <code>n</code> away
(i.e. the default behavior).</li><li>You can also use <code>lift e to ‚Ñï with k hk</code> where <code>e</code> is any expression of type <code>‚Ñ§</code>.
In this case, the <code>hk</code> will always stay in the context, but it will be used to rewrite <code>e</code> in
all hypotheses and the target.<ul><li>So for example the tactic <code>lift n + 3 to ‚Ñï using hn with k hk</code> transforms the goal
<code>n : ‚Ñ§, hn : n + 3 ‚â• 0, h : P (n + 3) ‚ä¢ n + 3 = 2 * n</code> to the goal
<code>n : ‚Ñ§, k : ‚Ñï, hk : ‚Üëk = n + 3, h : P ‚Üëk ‚ä¢ ‚Üëk = 2 * n</code>.</li></ul></li><li>The tactic <code>lift n to ‚Ñï using h</code> will remove <code>h</code> from the context. If you want to keep it,
specify it again as the third argument to <code>with</code>, like this: <code>lift n to ‚Ñï using h with n rfl h</code>.</li><li>More generally, this can lift an expression from <code>Œ±</code> to <code>Œ≤</code> assuming that there is an instance
of <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> Œ± Œ≤</code>. In this case the proof obligation is specified by <code><a href="./Mathlib/Tactic/Lift.html#CanLift.prf">CanLift.prf</a></code>.</li><li>Given an instance <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> Œ≤ Œ≥</code>, it can also lift <code>Œ± ‚Üí Œ≤</code> to <code>Œ± ‚Üí Œ≥</code>; more generally, given
<code>Œ≤ : Œ† a : Œ±, Type*</code>, <code>Œ≥ : Œ† a : Œ±, Type*</code>, and <code>[Œ† a : Œ±, <a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> (Œ≤ a) (Œ≥ a)]</code>, it
automatically generates an instance <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> (Œ† a, Œ≤ a) (Œ† a, Œ≥ a)</code>.</li></ul><p><code>lift</code> is in some sense dual to the <code>zify</code> tactic. <code>lift (z : ‚Ñ§) to ‚Ñï</code> will change the type of an
integer <code>z</code> (in the supertype) to <code>‚Ñï</code> (the subtype), given a proof that <code>z ‚â• 0</code>;
propositions concerning <code>z</code> will still be over <code>‚Ñ§</code>. <code>zify</code> changes propositions about <code>‚Ñï</code> (the
subtype) to propositions about <code>‚Ñ§</code> (the supertype), without changing the type of any variable.</p><p>The <code>norm_cast</code> tactic can be used after <code>lift</code> to normalize introduced casts.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Lift.html#Mathlib.Tactic.lift">Mathlib.Tactic.Lift</a></dd></dl></div><div id="Mathlib.Tactic.Coherence.liftable_prefixes"><h2>liftable_prefixes</h2><p><p>Internal tactic used in <code>coherence</code>.</p><p>Rewrites an equation <code>f = g</code> as <code>f‚ÇÄ ‚â´ f‚ÇÅ = g‚ÇÄ ‚â´ g‚ÇÅ</code>,
where <code>f‚ÇÄ</code> and <code>g‚ÇÄ</code> are maximal prefixes of <code>f</code> and <code>g</code> (possibly after reassociating)
which are &quot;liftable&quot; (i.e. expressible as compositions of unitors and associators).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Coherence.html#Mathlib.Tactic.Coherence.liftable_prefixes">Mathlib.Tactic.CategoryTheory.Coherence</a></dd></dl></div><div id="Mathlib.Tactic.linarith"><h2>linarith</h2><p><p><code>linarith</code> attempts to find a contradiction between hypotheses that are linear (in)equalities.
Equivalently, it can prove a linear inequality by assuming its negation and proving <code>False</code>.</p><p>In theory, <code>linarith</code> should prove any goal that is true in the theory of linear arithmetic over
the rationals. While there is some special handling for non-dense orders like <code>Nat</code> and <code>Int</code>,
this tactic is not complete for these theories and will not prove every true goal. It will solve
goals over arbitrary types that instantiate <code><a href="./Mathlib/Algebra/Ring/Defs.html#CommRing">CommRing</a></code>, <code><a href="./Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code> and <code><a href="./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing">IsStrictOrderedRing</a></code>.</p><p>An example:</p><pre><code class="language-lean">example (x y z : ‚Ñö) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)
        (h3 : 12*y - 4* z &lt; 0) : False := by
  linarith
</code></pre><p><code>linarith</code> will use all appropriate hypotheses and the negation of the goal, if applicable.
Disequality hypotheses require case splitting and are not normally considered
(see the <code>splitNe</code> option below).</p><p><code>linarith [t1, t2, t3]</code> will additionally use proof terms <code>t1, t2, t3</code>.</p><p><code>linarith only [h1, h2, h3, t1, t2, t3]</code> will use only the goal (if relevant), local hypotheses
<code>h1</code>, <code>h2</code>, <code>h3</code>, and proofs <code>t1</code>, <code>t2</code>, <code>t3</code>. It will ignore the rest of the local context.</p><p><code>linarith!</code> will use a stronger reducibility setting to try to identify atoms. For example,</p><pre><code class="language-lean">example (x : ‚Ñö) : id x ‚â• x := by
  linarith
</code></pre><p>will fail, because <code>linarith</code> will not identify <code>x</code> and <code>id x</code>. <code>linarith!</code> will.
This can sometimes be expensive.</p><p><code>linarith (config := { .. })</code> takes a config object with five
optional arguments:</p><ul><li><code>discharger</code> specifies a tactic to be used for reducing an algebraic equation in the
proof stage. The default is <code>ring</code>. Other options include <code>simp</code> for basic
problems.</li><li><code>transparency</code> controls how hard <code>linarith</code> will try to match atoms to each other. By default
it will only unfold <code>reducible</code> definitions.</li><li>If <code>splitHypotheses</code> is true, <code>linarith</code> will split conjunctions in the context into separate
hypotheses.</li><li>If <code>splitNe</code> is <code>true</code>, <code>linarith</code> will case split on disequality hypotheses.
For a given <code>x ‚â† y</code> hypothesis, <code>linarith</code> is run with both <code>x &lt; y</code> and <code>x &gt; y</code>,
and so this runs linarith exponentially many times with respect to the number of
disequality hypotheses. (<code>false</code> by default.)</li><li>If <code>exfalso</code> is <code>false</code>, <code>linarith</code> will fail when the goal is neither an inequality nor <code>False</code>.
(<code>true</code> by default.)</li><li>If <code>minimize</code> is <code>false</code>, <code>linarith?</code> will report all hypotheses appearing in its initial
proof without attempting to drop redundancies. (<code>true</code> by default.)</li><li><code>restrict_type</code> (not yet implemented in mathlib4)
will only use hypotheses that are inequalities over <code>tp</code>. This is useful
if you have e.g. both integer- and rational-valued inequalities in the local context, which can
sometimes confuse the tactic.</li></ul><p>A variant, <code>nlinarith</code>, does some basic preprocessing to handle some nonlinear goals.</p><p>The option <code>set_option trace.linarith true</code> will trace certain intermediate stages of the <code>linarith</code>
routine.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Mathlib.Tactic.linarith?"><h2>linarith?</h2><p><p><code>linarith?</code> behaves like <code>linarith</code> but, on success, it prints a suggestion of
the form <code>linarith only [...]</code> listing a minimized set of hypotheses used in the
final proof.  Use <code>linarith?!</code> for the higher-reducibility variant and set the
<code>minimize</code> flag in the configuration to control whether greedy minimization is
performed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith?">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Mathlib.Tactic.LinearCombination.linearCombination"><h2>linear_combination</h2><p><p>The <code>linear_combination</code> tactic attempts to prove an (in)equality goal by exhibiting it as a
specified linear combination of (in)equality hypotheses, or other (in)equality proof terms, modulo
(A) moving terms between the LHS and RHS of the (in)equalities, and (B) a normalization tactic
which by default is ring-normalization.</p><p>Example usage:</p><pre><code>example {a b : ‚Ñö} (h1 : a = 1) (h2 : b = 3) : (a + b) / 2 = 2 := by
  linear_combination (h1 + h2) / 2

example {a b : ‚Ñö} (h1 : a ‚â§ 1) (h2 : b ‚â§ 3) : (a + b) / 2 ‚â§ 2 := by
  linear_combination (h1 + h2) / 2

example {a b : ‚Ñö} : 2 * a * b ‚â§ a ^ 2 + b ^ 2 := by
  linear_combination <a href="./Mathlib/Algebra/Order/Ring/Unbundled/Basic.html#sq_nonneg">sq_nonneg</a> (a - b)

example {x y z w : ‚Ñ§} (h‚ÇÅ : x * z = y ^ 2) (h‚ÇÇ : y * w = z ^ 2) :
    z * (x * w - y * z) = 0 := by
  linear_combination w * h‚ÇÅ + y * h‚ÇÇ

example {x : ‚Ñö} (h : x ‚â• 5) : x ^ 2 &gt; 2 * x + 11 := by
  linear_combination (x + 3) * h

example {R : Type*} [CommRing R] {a b : R} (h : a = b) : a ^ 2 = b ^ 2 := by
  linear_combination (a + b) * h

example {A : Type*} [AddCommGroup A]
    {x y z : A} (h1 : x + y = 10 ‚Ä¢ z) (h2 : x - y = 6 ‚Ä¢ z) :
    2 ‚Ä¢ x = 2 ‚Ä¢ (8 ‚Ä¢ z) := by
  linear_combination (norm := abel) h1 + h2

example (x y : ‚Ñ§) (h1 : x * y + 2 * x = 1) (h2 : x = y) :
    x * y = -2 * y + 1 := by
  linear_combination (norm := ring_nf) -2 * h2
  -- leaves goal `‚ä¢ x * y + x * 2 - 1 = 0`
</code></pre><p>The input <code>e</code> in <code>linear_combination e</code> is a linear combination of proofs of (in)equalities,
given as a sum/difference of coefficients multiplied by expressions.
The coefficients may be arbitrary expressions (with nonnegativity constraints in the case of
inequalities).
The expressions can be arbitrary proof terms proving (in)equalities;
most commonly they are hypothesis names <code>h1</code>, <code>h2</code>, ....</p><p>The left and right sides of all the (in)equalities should have the same type <code>Œ±</code>, and the
coefficients should also have type <code>Œ±</code>.  For full functionality <code>Œ±</code> should be a commutative ring --
strictly speaking, a commutative semiring with &quot;cancellative&quot; addition (in the semiring case,
negation and subtraction will be handled &quot;formally&quot; as if operating in the enveloping ring). If a
nonstandard normalization is used (for example <code>abel</code> or <code>skip</code>), the tactic will work over types
<code>Œ±</code> with less algebraic structure: for equalities, the minimum is instances of
<code>[Add Œ±] [IsRightCancelAdd Œ±]</code> together with instances of whatever operations are used in the tactic
call.</p><p>The variant <code>linear_combination (norm := tac) e</code> specifies explicitly the &quot;normalization tactic&quot;
<code>tac</code> to be run on the subgoal(s) after constructing the linear combination.</p><ul><li>The default normalization tactic is <code>ring1</code> (for equalities) or <code>Mathlib.Tactic.Ring.prove{LE,LT}</code>
(for inequalities). These are finishing tactics: they close the goal or fail.</li><li>When working in algebraic categories other than commutative rings -- for example fields, abelian
groups, modules -- it is sometimes useful to use normalization tactics adapted to those categories
(<code>field_simp</code>, <code>abel</code>, <code>module</code>).</li><li>To skip normalization entirely, use <code>skip</code> as the normalization tactic.</li><li>The <code>linear_combination</code> tactic creates a linear combination by adding the provided (in)equalities
together from left to right, so if <code>tac</code> is not invariant under commutation of additive
expressions, then the order of the input hypotheses can matter.</li></ul><p>The variant <code>linear_combination (exp := n) e</code> will take the goal to the <code>n</code>th power before
subtracting the combination <code>e</code>. In other words, if the goal is <code>t1 = t2</code>,
<code>linear_combination (exp := n) e</code> will change the goal to <code>(t1 - t2)^n = 0</code> before proceeding as
above.  This variant is implemented only for linear combinations of equalities (i.e., not for
inequalities).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination">Mathlib.Tactic.LinearCombination</a></dd></dl></div><div id="Mathlib.Tactic.LinearCombination'.linearCombination'"><h2>linear_combination'</h2><p><p><code>linear_combination'</code> attempts to simplify the target by creating a linear combination
of a list of equalities and subtracting it from the target.
The tactic will create a linear
combination by adding the equalities together from left to right, so the order
of the input hypotheses does matter.  If the <code>norm</code> field of the
tactic is set to <code>skip</code>, then the tactic will simply set the user up to
prove their target using the linear combination instead of normalizing the subtraction.</p><p>Note: There is also a similar tactic <code>linear_combination</code> (no prime); this version is
provided for backward compatibility.  Compared to this tactic, <code>linear_combination</code>:</p><ul><li>drops the <code>‚Üê</code> syntax for reversing an equation, instead offering this operation using the <code>-</code>
syntax</li><li>does not support multiplication of two hypotheses (<code>h1 * h2</code>), division by a hypothesis (<code>3 / h</code>),
or inversion of a hypothesis (<code>h‚Åª¬π</code>)</li><li>produces noisy output when the user adds or subtracts a constant to a hypothesis (<code>h + 3</code>)</li></ul><p>Note: The left and right sides of all the equalities should have the same
type, and the coefficients should also have this type.  There must be
instances of <code>Mul</code> and <code><a href="./Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a></code> for this type.</p><ul><li>The input <code>e</code> in <code>linear_combination' e</code> is a linear combination of proofs of equalities,
given as a sum/difference of coefficients multiplied by expressions.
The coefficients may be arbitrary expressions.
The expressions can be arbitrary proof terms proving equalities.
Most commonly they are hypothesis names <code>h1, h2, ...</code>.</li><li><code>linear_combination' (norm := tac) e</code> runs the &quot;normalization tactic&quot; <code>tac</code>
on the subgoal(s) after constructing the linear combination.<ul><li>The default normalization tactic is <code>ring1</code>, which closes the goal or fails.</li><li>To get a subgoal in the case that it is not immediately provable, use
<code>ring_nf</code> as the normalization tactic.</li><li>To avoid normalization entirely, use <code>skip</code> as the normalization tactic.</li></ul></li><li><code>linear_combination' (exp := n) e</code> will take the goal to the <code>n</code>th power before subtracting the
combination <code>e</code>. In other words, if the goal is <code>t1 = t2</code>, <code>linear_combination' (exp := n) e</code>
will change the goal to <code>(t1 - t2)^n = 0</code> before proceeding as above.
This feature is not supported for <code>linear_combination2</code>.</li><li><code>linear_combination2 e</code> is the same as <code>linear_combination' e</code> but it produces two
subgoals instead of one: rather than proving that <code>(a - b) - (a' - b') = 0</code> where
<code>a' = b'</code> is the linear combination from <code>e</code> and <code>a = b</code> is the goal,
it instead attempts to prove <code>a = a'</code> and <code>b = b'</code>.
Because it does not use subtraction, this form is applicable also to semirings.<ul><li>Note that a goal which is provable by <code>linear_combination' e</code> may not be provable
by <code>linear_combination2 e</code>; in general you may need to add a coefficient to <code>e</code>
to make both sides match, as in <code>linear_combination2 e + c</code>.</li><li>You can also reverse equalities using <code>‚Üê h</code>, so for example if <code>h‚ÇÅ : a = b</code>
then <code>2 * (‚Üê h)</code> is a proof of <code>2 * b = 2 * a</code>.</li></ul></li></ul><p>Example Usage:</p><pre><code>example (x y : ‚Ñ§) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination' 1*h1 - 2*h2

example (x y : ‚Ñ§) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination' h1 - 2*h2

example (x y : ‚Ñ§) (h1 : x*y + 2*x = 1) (h2 : x = y) : x*y = -2*y + 1 := by
  linear_combination' (norm := ring_nf) -2*h2
  /- Goal: x * y + x * 2 - 1 = 0 -/

example (x y z : ‚Ñù) (ha : x + 2*y - z = 4) (hb : 2*x + y + z = -2)
    (hc : x + 2*y + z = 2) :
    -3*x - 3*y - 4*z = 2 := by
  linear_combination' ha - hb - 2*hc

example (x y : ‚Ñö) (h1 : x + y = 3) (h2 : 3*x = 7) :
    x*x*y + y*x*y + 6*x = 3*x*y + 14 := by
  linear_combination' x*y*h1 + 2*h2

example (x y : ‚Ñ§) (h1 : x = -3) (h2 : y = 10) : 2*x = -6 := by
  linear_combination' (norm := skip) 2*h1
  simp

axiom qc : ‚Ñö
axiom hqc : qc = 2*qc

example (a b : ‚Ñö) (h : ‚àÄ p q : ‚Ñö, p = q) : 3*a + qc = 3*b + 2*qc := by
  linear_combination' 3 * h a b + hqc
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/LinearCombination'.html#Mathlib.Tactic.LinearCombination'.linearCombination'">Mathlib.Tactic.LinearCombination'</a></dd></dl></div><div id="WittVector.mapFun.tacticMap_fun_tac"><h2>map_fun_tac</h2><p><p>Auxiliary tactic for showing that <code>mapFun</code> respects the ring operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/Basic.html#WittVector.mapFun.tacticMap_fun_tac">Mathlib.RingTheory.WittVector.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Module.tacticMatch_scalars"><h2>match_scalars</h2><p><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="./Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>For example, this produces the goal <code>‚ä¢ a * 1 + b * 1 = (b + a) * 1</code>:</p><pre><code>example [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  match_scalars
</code></pre><p>This produces the two goals <code>‚ä¢ a * (a * 1) + b * (b * 1) = 1</code> (from the <code>x</code> atom) and
<code>‚ä¢ a * -(b * 1) + b * (a * 1) = 0</code> (from the <code>y</code> atom):</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ (a ‚Ä¢ x - b ‚Ä¢ y) + (b ‚Ä¢ a ‚Ä¢ y + b ‚Ä¢ b ‚Ä¢ x) = x := by
  match_scalars
</code></pre><p>This produces the goal <code>‚ä¢ -2 * (a * 1) = a * (-2 * 1)</code>:</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :
    -(2:R) ‚Ä¢ a ‚Ä¢ x = a ‚Ä¢ (-2:‚Ñ§) ‚Ä¢ x  := by
  match_scalars
</code></pre><p>The scalar type for the goals produced by the <code>match_scalars</code> tactic is the largest scalar type
encountered; for example, if <code>‚Ñï</code>, <code>‚Ñö</code> and a characteristic-zero field <code>K</code> all occur as scalars, then
the goals produced are equalities in <code>K</code>.  A variant of <code>push_cast</code> is used internally in
<code>match_scalars</code> to interpret scalars from the other types in this largest type.</p><p>If the set of scalar types encountered is not totally ordered (in the sense that for all rings <code>R</code>,
<code>S</code> encountered, it holds that either <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>), then the <code>match_scalars</code>
tactic fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars">Mathlib.Tactic.Module</a></dd></dl></div><div id="Mathlib.Tactic.tacticMatch_target_"><h2>match_target</h2><p><p>Deprecated: use <code>guard_target =~ t</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticMatch_target_">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Mathlib.Tactic.measurability"><h2>measurability</h2><p><p>The tactic <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> solves goals of the form <code><a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#Measurable">Measurable</a> f</code>, <code><a href="./Mathlib/MeasureTheory/Measure/MeasureSpaceDef.html#AEMeasurable">AEMeasurable</a> f</code>,
<code>StronglyMeasurable f</code>, <code>AEStronglyMeasurable f Œº</code>, or <code><a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#MeasurableSet">MeasurableSet</a> s</code> by applying lemmas tagged
with the <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> user attribute.</p><p>Note that <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> uses <code>fun_prop</code> for solving measurability of functions, so statements
about <code><a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#Measurable">Measurable</a></code>, <code><a href="./Mathlib/MeasureTheory/Measure/MeasureSpaceDef.html#AEMeasurable">AEMeasurable</a></code>, <code>StronglyMeasurable</code> and <code>AEStronglyMeasurable</code> should be tagged
with <code>fun_prop</code> rather that <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code>. The <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> attribute is equivalent to
<code>fun_prop</code> in these cases for backward compatibility with the earlier implementation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Measurability.html#Mathlib.Tactic.measurability">Mathlib.Tactic.Measurability</a></dd></dl></div><div id="Mathlib.Tactic.measurability?"><h2>measurability?</h2><p><p>The tactic <code>measurability?</code> solves goals of the form <code><a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#Measurable">Measurable</a> f</code>, <code><a href="./Mathlib/MeasureTheory/Measure/MeasureSpaceDef.html#AEMeasurable">AEMeasurable</a> f</code>,
<code>StronglyMeasurable f</code>, <code>AEStronglyMeasurable f Œº</code>, or <code><a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#MeasurableSet">MeasurableSet</a> s</code> by applying lemmas tagged
with the <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> user attribute, and suggests a faster proof script that can be substituted
for the tactic call in case of success.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Measurability.html#Mathlib.Tactic.measurability?">Mathlib.Tactic.Measurability</a></dd></dl></div><div id="AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.tacticMem_tac"><h2>mem_tac</h2><p><p><code>mem_tac</code> tries to prove goals of the form <code>x ‚àà ùíú i</code> when <code>x</code> has the form of:</p><ul><li><code>y ^ n</code> where <code>i = n ‚Ä¢ j</code> and <code>y ‚àà ùíú j</code>.</li><li>a natural number <code>n</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.html#AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.tacticMem_tac">Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme</a></dd></dl></div><div id="Tactic.MfldSetTac.mfldSetTac"><h2>mfld_set_tac</h2><p><p>A very basic tactic to show that sets showing up in manifolds coincide or are included
in one another.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Logic/Equiv/PartialEquiv.html#Tactic.MfldSetTac.mfldSetTac">Mathlib.Logic.Equiv.PartialEquiv</a></dd></dl></div><div id="Mathlib.Tactic.ModCases.¬´tacticMod_cases_:_%_¬ª"><h2>mod_cases</h2><p><ul><li>The tactic <code>mod_cases h : e % 3</code> will perform a case disjunction on <code>e</code>.
If <code>e : ‚Ñ§</code>, then it will yield subgoals containing the assumptions
<code>h : e ‚â° 0 [ZMOD 3]</code>, <code>h : e ‚â° 1 [ZMOD 3]</code>, <code>h : e ‚â° 2 [ZMOD 3]</code>
respectively. If <code>e : ‚Ñï</code> instead, then it works similarly, except with
<code>[MOD 3]</code> instead of <code>[ZMOD 3]</code>.</li><li>In general, <code>mod_cases h : e % n</code> works
when <code>n</code> is a positive numeral and <code>e</code> is an expression of type <code>‚Ñï</code> or <code>‚Ñ§</code>.</li><li>If <code>h</code> is omitted as in <code>mod_cases e % n</code>, it will be default-named <code>H</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.¬´tacticMod_cases_:_%_¬ª">Mathlib.Tactic.ModCases</a></dd></dl></div><div id="Mathlib.Tactic.Module.tacticModule"><h2>module</h2><p><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="./Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some commutative semiring <code>R</code>, and prove
the goal by checking that the LHS- and RHS-coefficients of each atom are the same up to
ring-normalization in <code>R</code>.</p><p>(If the proofs of coefficient-wise equality will require more reasoning than just
ring-normalization, use the tactic <code>match_scalars</code> instead, and then prove coefficient-wise equality
by hand.)</p><p>Example uses of the <code>module</code> tactic:</p><pre><code>example [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  module

example [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :
    (2:K)‚Åª¬π ‚Ä¢ x + (3:K)‚Åª¬π ‚Ä¢ x + (6:K)‚Åª¬π ‚Ä¢ x = x := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :
    (1 + a ^ 2) ‚Ä¢ (v + w) - a ‚Ä¢ (a ‚Ä¢ v - w) = v + (1 + a + a ^ 2) ‚Ä¢ w := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a b Œº ŒΩ : R) (x y : M) :
    (Œº - ŒΩ) ‚Ä¢ a ‚Ä¢ x = (a ‚Ä¢ Œº ‚Ä¢ x + b ‚Ä¢ ŒΩ ‚Ä¢ y) - ŒΩ ‚Ä¢ (a ‚Ä¢ x + b ‚Ä¢ y) := by
  module
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule">Mathlib.Tactic.Module</a></dd></dl></div><div id="Mathlib.Tactic.ComputeDegree.monicityMacro"><h2>monicity</h2><p><p><code>monicity</code> tries to solve a goal of the form <code>Monic f</code>.
It converts the goal into a goal of the form <code>natDegree f ‚â§ n</code> and one of the form <code>f.coeff n = 1</code>
and calls <code>compute_degree</code> on those two goals.</p><p>The variant <code>monicity!</code> starts like <code>monicity</code>, but calls <code>compute_degree!</code> on the two side-goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ComputeDegree.html#Mathlib.Tactic.ComputeDegree.monicityMacro">Mathlib.Tactic.ComputeDegree</a></dd></dl></div><div id="Mathlib.Tactic.Monotonicity.mono"><h2>mono</h2><p><p><code>mono</code> applies monotonicity rules and local hypotheses repetitively.  For example,</p><pre><code class="language-lean">example (x y z k : ‚Ñ§)
    (h : 3 ‚â§ (4 : ‚Ñ§))
    (h' : z ‚â§ y) :
    (k + 3 + x) - y ‚â§ (k + 4 + x) - z := by
  mono
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Monotonicity/Basic.html#Mathlib.Tactic.Monotonicity.mono">Mathlib.Tactic.Monotonicity.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Monoidal.tacticMonoidal"><h2>monoidal</h2><p><p>Use the coherence theorem for monoidal categories to solve equations in a monoidal category,
where the two sides only differ by replacing strings of monoidal structural morphisms
(that is, associators, unitors, and identities)
with different strings of structural morphisms with the same source and target.</p><p>That is, <code>monoidal</code> can handle goals of the form
<code>a ‚â´ f ‚â´ b ‚â´ g ‚â´ c = a' ‚â´ f ‚â´ b' ‚â´ g ‚â´ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>monoidal_coherence</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal">Mathlib.Tactic.CategoryTheory.Monoidal.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Coherence.tacticMonoidal_coherence"><h2>monoidal_coherence</h2><p><p>Coherence tactic for monoidal categories.
Use <code>pure_coherence</code> instead, which is a frontend to this one.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Coherence.html#Mathlib.Tactic.Coherence.tacticMonoidal_coherence">Mathlib.Tactic.CategoryTheory.Coherence</a></dd></dl></div><div id="Mathlib.Tactic.Monoidal.tacticMonoidal_coherence"><h2>monoidal_coherence</h2><p><p>Close the goal of the form <code>Œ∑ = Œ∏</code>, where <code>Œ∑</code> and <code>Œ∏</code> are 2-isomorphisms made up only of
associators, unitors, and identities.</p><pre><code class="language-lean">example {C : Type} [Category* C] [MonoidalCategory C] :
  (Œª_ (ùüô_ C)).hom = (œÅ_ (ùüô_ C)).hom := by
  monoidal_coherence
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Monoidal/PureCoherence.html#Mathlib.Tactic.Monoidal.tacticMonoidal_coherence">Mathlib.Tactic.CategoryTheory.Monoidal.PureCoherence</a></dd></dl></div><div id="Mathlib.Tactic.Monoidal.tacticMonoidal_nf"><h2>monoidal_nf</h2><p><p>Normalize the both sides of an equality.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal_nf">Mathlib.Tactic.CategoryTheory.Monoidal.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Coherence.monoidal_simps"><h2>monoidal_simps</h2><p><p>Simp lemmas for rewriting a hom in monoidal categories into a normal form.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Coherence.html#Mathlib.Tactic.Coherence.monoidal_simps">Mathlib.Tactic.CategoryTheory.Coherence</a></dd></dl></div><div id="Mathlib.MoveAdd.moveOperTac"><h2>move_oper</h2><p><p>The tactic <code>move_add</code> rearranges summands of expressions.
Calling <code>move_add [a, ‚Üê b, ...]</code> matches <code>a, b,...</code> with summands in the main goal.
It then moves <code>a</code> to the far right and <code>b</code> to the far left of each addition in which they appear.
The side to which the summands are moved is determined by the presence or absence of the arrow <code>‚Üê</code>.</p><p>The inputs <code>a, b,...</code> can be any terms, also with underscores.
The tactic uses the first &quot;new&quot; summand that unifies with each one of the given inputs.</p><p>There is a multiplicative variant, called <code>move_mul</code>.</p><p>There is also a general tactic for a &quot;binary associative commutative operation&quot;: <code>move_oper</code>.
In this case the syntax requires providing first a term whose head symbol is the operation.
E.g. <code>move_oper HAdd.hAdd [...]</code> is the same as <code>move_add</code>, while <code>move_oper <a href="./Mathlib/Algebra/Order/AddGroupWithTop.html#Max.max">Max.max</a> [...]</code>
rearranges <code>max</code>s.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperTac">Mathlib.Tactic.MoveAdd</a></dd></dl></div><div id="Mathlib.Tactic.MvBisim.tacticMv_bisim___With___"><h2>mv_bisim</h2><p><p>tactic for proof by bisimulation</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/QPF/Multivariate/Constructions/Cofix.html#Mathlib.Tactic.MvBisim.tacticMv_bisim___With___">Mathlib.Data.QPF.Multivariate.Constructions.Cofix</a></dd></dl></div><div id="Mathlib.Tactic.nlinarith"><h2>nlinarith</h2><p><p>An extension of <code>linarith</code> with some preprocessing to allow it to solve some nonlinear arithmetic
problems. (Based on Coq's <code>nra</code> tactic.) See <code>linarith</code> for the available syntax of options,
which are inherited by <code>nlinarith</code>; that is, <code>nlinarith!</code> and <code>nlinarith only [h1, h2]</code> all work as
in <code>linarith</code>. The preprocessing is as follows:</p><ul><li>For every subterm <code>a ^ 2</code> or <code>a * a</code> in a hypothesis or the goal,
the assumption <code>0 ‚â§ a ^ 2</code> or <code>0 ‚â§ a * a</code> is added to the context.</li><li>For every pair of hypotheses <code>a1 R1 b1</code>, <code>a2 R2 b2</code> in the context, <code>R1, R2 ‚àà {&lt;, ‚â§, =}</code>,
the assumption <code>0 R' (b1 - a1) * (b2 - a2)</code> is added to the context (non-recursively),
where <code>R ‚àà {&lt;, ‚â§, =}</code> is the appropriate comparison derived from <code>R1, R2</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.nlinarith">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Mathlib.Tactic.NoncommRing.noncomm_ring"><h2>noncomm_ring</h2><p><p>A tactic for simplifying identities in not-necessarily-commutative rings.</p><p>An example:</p><pre><code class="language-lean">example {R : Type*} [Ring R] (a b c : R) : a * (b + c + c - b) = 2 * a * c := by
  noncomm_ring
</code></pre><p>You can use <code>noncomm_ring [h]</code> to also simplify using <code>h</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NoncommRing.html#Mathlib.Tactic.NoncommRing.noncomm_ring">Mathlib.Tactic.NoncommRing</a></dd></dl></div><div id="Mathlib.Tactic.Nontriviality.nontriviality"><h2>nontriviality</h2><p><p>Attempts to generate a <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code> hypothesis.</p><p>The tactic first checks to see that there is not already a <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code> instance
before trying to synthesize one using other techniques.</p><p>If the goal is an (in)equality, the type <code>Œ±</code> is inferred from the goal.
Otherwise, the type needs to be specified in the tactic invocation, as <code>nontriviality Œ±</code>.</p><p>The <code>nontriviality</code> tactic will first look for strict inequalities amongst the hypotheses,
and use these to derive the <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a></code> instance directly.</p><p>Otherwise, it will perform a case split on <code>Subsingleton Œ± ‚à® <a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code>, and attempt to discharge
the <code>Subsingleton</code> goal using <code>simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô, nontriviality]</code>, where <code>[h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]</code> is
a list of additional <code>simp</code> lemmas that can be passed to <code>nontriviality</code> using the syntax
<code>nontriviality Œ± using h‚ÇÅ, h‚ÇÇ, ..., h‚Çô</code>.</p><pre><code>example {R : Type} [OrderedRing R] {a : R} (h : 0 &lt; a) : 0 &lt; a := by
  nontriviality -- There is now a `Nontrivial R` hypothesis available.
  assumption
</code></pre><pre><code>example {R : Type} [CommRing R] {r s : R} : r * s = s * r := by
  nontriviality -- There is now a `Nontrivial R` hypothesis available.
  apply <a href="./Mathlib/Algebra/Group/Defs.html#mul_comm">mul_comm</a>
</code></pre><pre><code>example {R : Type} [OrderedRing R] {a : R} (h : 0 &lt; a) : (2 : ‚Ñï) ‚à£ 4 := by
  nontriviality R -- there is now a `Nontrivial R` hypothesis available.
  dec_trivial
</code></pre><pre><code>def myeq {Œ± : Type} (a b : Œ±) : Prop := a = b

example {Œ± : Type} (a b : Œ±) (h : a = b) : myeq a b := by
  success_if_fail nontriviality Œ± -- Fails
  nontriviality Œ± using myeq -- There is now a `Nontrivial Œ±` hypothesis available
  assumption
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Nontriviality/Core.html#Mathlib.Tactic.Nontriviality.nontriviality">Mathlib.Tactic.Nontriviality.Core</a></dd></dl></div><div id="Mathlib.Tactic.normNum"><h2>norm_num</h2><p><p><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> normalizes numerical expressions in the goal. By default, it supports the operations
<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>‚Åª¬π</code> <code>^</code> and <code>%</code> over types with (at least) an <code><a href="./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne">AddMonoidWithOne</a></code> instance, such as
<code>‚Ñï</code>, <code>‚Ñ§</code>, <code>‚Ñö</code>, <code>‚Ñù</code>, <code>‚ÑÇ</code>. In addition to evaluating numerical expressions, <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> will use <code>simp</code>
to simplify the goal. If the goal has the form <code>A = B</code>, <code>A ‚â† B</code>, <code>A &lt; B</code> or <code>A ‚â§ B</code>, where <code>A</code> and
<code>B</code> are numerical expressions, <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> will try to close it. It also has a relatively simple
primality prover.</p><p>This tactic is extensible. Extensions can allow <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> to evaluate more kinds of expressions, or
to prove more kinds of propositions. See the <code>@[norm_num]</code> attribute for further information on
extending <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.</p><ul><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> at l</code> normalizes at location(s) <code>l</code>.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> [h1, ...]</code> adds the arguments <code>h1, ...</code> to the <code>simp</code> set in addition to the default
<code>simp</code> set. All options for <code>simp</code> arguments are supported, in particular <code>‚Üê</code>, <code>‚Üë</code> and <code>‚Üì</code>.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only</code> does not use the default <code>simp</code> set for simplification. <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only [h1, ...]</code>
uses only the arguments <code>h1, ...</code> in addition to the routines tagged <code>@[norm_num]</code>.
<code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only</code> still performs post-processing steps, like <code>simp only</code>, use <code>norm_num1</code> if you
exclusively want to normalize numerical expressions.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> (config := cfg)</code> uses <code>cfg</code> as configuration for <code>simp</code> calls (see the <code>simp</code> tactic for
further details).</li></ul><p>Examples:</p><pre><code class="language-lean">example : 43 ‚â§ 74 + (33 : ‚Ñ§) := by <a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a>
example : ¬¨ (7-2)/(2*3) ‚â• (1:‚Ñù) + 2/(3^2) := by <a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum">Mathlib.Tactic.NormNum.Core</a></dd></dl></div><div id="Mathlib.Tactic.normNum1"><h2>norm_num1</h2><p><p><code>norm_num1</code> normalizes numerical expressions in the goal. It is a basic version of <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>
that does not call <code>simp</code>.</p><p>By default, it supports the operations <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>‚Åª¬π</code> <code>^</code> and <code>%</code> over types with (at least)
an <code><a href="./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne">AddMonoidWithOne</a></code> instance, such as <code>‚Ñï</code>, <code>‚Ñ§</code>, <code>‚Ñö</code>, <code>‚Ñù</code>, <code>‚ÑÇ</code>. If the goal has the form <code>A = B</code>,
<code>A ‚â† B</code>, <code>A &lt; B</code> or <code>A ‚â§ B</code>, where <code>A</code> and <code>B</code> are numerical expressions, <code>norm_num1</code> will try to
close it. It also has a relatively simple primality prover.
:e
This tactic is extensible. Extensions can allow <code>norm_num1</code> to evaluate more kinds of expressions,
or to prove more kinds of propositions. See the <code>@[norm_num]</code> attribute for further information on
extending <code>norm_num1</code>.</p><ul><li><code>norm_num1 at l</code> normalizes at location(s) <code>l</code>.</li></ul><p>Examples:</p><pre><code class="language-lean">example : 43 ‚â§ 74 + (33 : ‚Ñ§) := by norm_num1
example : ¬¨ (7-2)/(2*3) ‚â• (1:‚Ñù) + 2/(3^2) := by norm_num1
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum1">Mathlib.Tactic.NormNum.Core</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_grewrite_____"><h2>nth_grewrite</h2><p><p><code>nth_grewrite</code> is just like <code>nth_rewrite</code>, but for <code>grewrite</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticNth_grewrite_____">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_grw_____"><h2>nth_grw</h2><p><p><code>nth_grw</code> is just like <code>nth_rw</code>, but for <code>grw</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticNth_grw_____">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_rewrite_____"><h2>nth_rewrite</h2><p><p><code>nth_rewrite</code> is a variant of <code>rewrite</code> that only changes the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of
the expression to be rewritten. <code>nth_rewrite n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]</code> will rewrite the
<code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of each of the <code>m</code> equalities <code>eq·µ¢</code>in that order. Occurrences are
counted beginning with <code>1</code> in order of precedence.</p><p>For example,</p><pre><code class="language-lean">example (h : a = 1) : a + a + a + a + a = 5 := by
  nth_rewrite 2 3 [h]
/-
a: ‚Ñï
h: a = 1
‚ä¢ a + 1 + 1 + a + a = 5
-/
</code></pre><p>Notice that the second and third occurrences of <code>a</code> from the left have been rewritten by
<code>nth_rewrite</code>.</p><p>To understand the importance of order of precedence, consider the example below</p><pre><code class="language-lean">example (a b c : Nat) : (a + b) + c = (b + a) + c := by
  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c
</code></pre><p>Here, although the occurrence parameter is <code>2</code>, <code>(a + b)</code> is rewritten to <code>(b + a)</code>. This happens
because in order of precedence, the first occurrence of <code>_ + _</code> is the one that adds <code>a + b</code> to <code>c</code>.
The occurrence in <code>a + b</code> counts as the second occurrence.</p><p>If a term <code>t</code> is introduced by rewriting with <code>eq·µ¢</code>, then this instance of <code>t</code> will be counted as an
<em>occurrence</em> of <code>t</code> for all subsequent rewrites of <code>t</code> with <code>eq‚±º</code> for <code>j &gt; i</code>. This behaviour is
illustrated by the example below</p><pre><code class="language-lean">example (h : a = a + b) : a + a + a + a + a = 0 := by
  nth_rewrite 3 [h, h]
/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b + b) + a + a = 0
-/
</code></pre><p>Here, the first <code>nth_rewrite</code> with <code>h</code> introduces an additional occurrence of <code>a</code> in the goal.
That is, the goal state after the first rewrite looks like below</p><pre><code class="language-lean">/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b) + a + a = 0
-/
</code></pre><p>This new instance of <code>a</code> also turns out to be the third <em>occurrence</em> of <code>a</code>.  Therefore,
the next <code>nth_rewrite</code> with <code>h</code> rewrites this <code>a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NthRewrite.html#Mathlib.Tactic.tacticNth_rewrite_____">Mathlib.Tactic.NthRewrite</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_rw_____"><h2>nth_rw</h2><p><p><code>nth_rw</code> is a variant of <code>rw</code> that only changes the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of the expression
to be rewritten. Like <code>rw</code>, and unlike <code>nth_rewrite</code>, it will try to close the goal by trying <code>rfl</code>
afterwards. <code>nth_rw n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]</code> will rewrite the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of
each of the <code>m</code> equalities <code>eq·µ¢</code>in that order. Occurrences are counted beginning with <code>1</code> in
order of precedence. For example,</p><pre><code class="language-lean">example (h : a = 1) : a + a + a + a + a = 5 := by
  nth_rw 2 3 [h]
/-
a: ‚Ñï
h: a = 1
‚ä¢ a + 1 + 1 + a + a = 5
-/
</code></pre><p>Notice that the second and third occurrences of <code>a</code> from the left have been rewritten by
<code>nth_rw</code>.</p><p>To understand the importance of order of precedence, consider the example below</p><pre><code class="language-lean">example (a b c : Nat) : (a + b) + c = (b + a) + c := by
  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c
</code></pre><p>Here, although the occurrence parameter is <code>2</code>, <code>(a + b)</code> is rewritten to <code>(b + a)</code>. This happens
because in order of precedence, the first occurrence of <code>_ + _</code> is the one that adds <code>a + b</code> to <code>c</code>.
The occurrence in <code>a + b</code> counts as the second occurrence.</p><p>If a term <code>t</code> is introduced by rewriting with <code>eq·µ¢</code>, then this instance of <code>t</code> will be counted as an
<em>occurrence</em> of <code>t</code> for all subsequent rewrites of <code>t</code> with <code>eq‚±º</code> for <code>j &gt; i</code>. This behaviour is
illustrated by the example below</p><pre><code class="language-lean">example (h : a = a + b) : a + a + a + a + a = 0 := by
  nth_rw 3 [h, h]
/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b + b) + a + a = 0
-/
</code></pre><p>Here, the first <code>nth_rw</code> with <code>h</code> introduces an additional occurrence of <code>a</code> in the goal. That is,
the goal state after the first rewrite looks like below</p><pre><code class="language-lean">/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b) + a + a = 0
-/
</code></pre><p>This new instance of <code>a</code> also turns out to be the third <em>occurrence</em> of <code>a</code>.  Therefore,
the next <code>nth_rw</code> with <code>h</code> rewrites this <code>a</code>.</p><p>Further, <code>nth_rw</code> will close the remaining goal with <code>rfl</code> if possible.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NthRewrite.html#Mathlib.Tactic.tacticNth_rw_____">Mathlib.Tactic.NthRewrite</a></dd></dl></div><div id="Mathlib.Tactic.LibrarySearch.observe"><h2>observe</h2><p><p><code>observe hp : p</code> asserts the proposition <code>p</code> as a hypothesis named <code>hp</code>, and tries to prove it
using <code>exact?</code>.
If no proof is found, the tactic fails.
In other words, this tactic is equivalent to <code>have hp : p := by exact?</code>.</p><ul><li><code>observe : p</code> uses the name <code>this</code> for the new hypothesis.</li><li><code>observe? hp : p</code> will emit a trace message of the form <code>have hp : p := proof_term</code>.
This may be particularly useful to speed up proofs.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Observe.html#Mathlib.Tactic.LibrarySearch.observe">Mathlib.Tactic.Observe</a></dd></dl></div><div id="Mathlib.Tactic.Order.tacticOrder_"><h2>order</h2><p><p>A finishing tactic for solving goals in arbitrary <code><a href="./Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code>, <code><a href="./Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a></code>,
or <code><a href="./Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code>. Supports <code>‚ä§</code>, <code>‚ä•</code>, and lattice operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_">Mathlib.Tactic.Order</a></dd></dl></div><div id="Mathlib.Tactic.Order.order_core"><h2>order_core</h2><p><p><code>order_core</code> is the part of the <code>order</code> tactic that tries to find a contradiction.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core">Mathlib.Tactic.Order</a></dd></dl></div><div id="Mathlib.Tactic.Peel.peel"><h2>peel</h2><p><p>Peels matching quantifiers off of a given term and the goal and introduces the relevant variables.</p><ul><li><code>peel e</code> peels all quantifiers (at reducible transparency),
using <code>this</code> for the name of the peeled hypothesis.</li><li><code>peel e with h</code> is <code>peel e</code> but names the peeled hypothesis <code>h</code>.
If <code>h</code> is <code>_</code> then uses <code>this</code> for the name of the peeled hypothesis.</li><li><code>peel n e</code> peels <code>n</code> quantifiers (at default transparency).</li><li><code>peel n e with x y z ... h</code> peels <code>n</code> quantifiers, names the peeled hypothesis <code>h</code>,
and uses <code>x</code>, <code>y</code>, <code>z</code>, and so on to name the introduced variables; these names may be <code>_</code>.
If <code>h</code> is <code>_</code> then uses <code>this</code> for the name of the peeled hypothesis.
The length of the list of variables does not need to equal <code>n</code>.</li><li><code>peel e with x‚ÇÅ ... x‚Çô h</code> is <code>peel n e with x‚ÇÅ ... x‚Çô h</code>.</li></ul><p>There are also variants that apply to an iff in the goal:</p><ul><li><code>peel n</code> peels <code>n</code> quantifiers in an iff.</li><li><code>peel with x‚ÇÅ ... x‚Çô</code> peels <code>n</code> quantifiers in an iff and names them.</li></ul><p>Given <code>p q : ‚Ñï ‚Üí Prop</code>, <code>h : ‚àÄ x, p x</code>, and a goal <code>‚ä¢ : ‚àÄ x, q x</code>, the tactic <code>peel h with x h'</code>
will introduce <code>x : ‚Ñï</code>, <code>h' : p x</code> into the context and the new goal will be <code>‚ä¢ q x</code>. This works
with <code>‚àÉ</code>, as well as <code>‚àÄ·∂†</code> and <code>‚àÉ·∂†</code>, and it can even be applied to a sequence of quantifiers. Note
that this is a logically weaker setup, so using this tactic is not always feasible.</p><p>For a more complex example, given a hypothesis and a goal:</p><pre><code>h : ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) &lt; Œµ
‚ä¢ ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) ‚â§ Œµ
</code></pre><p>(which differ only in <code>&lt;</code>/<code>‚â§</code>), applying <code>peel h with Œµ hŒµ N n hn h_peel</code> will yield a tactic state:</p><pre><code>h : ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) &lt; Œµ
Œµ : ‚Ñù
hŒµ : 0 &lt; Œµ
N n : ‚Ñï
hn : N ‚â§ n
h_peel : 1 / (n + 1 : ‚Ñù) &lt; Œµ
‚ä¢ 1 / (n + 1 : ‚Ñù) ‚â§ Œµ
</code></pre><p>and the goal can be closed with <code>exact h_peel.le</code>.
Note that in this example, <code>h</code> and the goal are logically equivalent statements, but <code>peel</code>
<em>cannot</em> be immediately applied to show that the goal implies <code>h</code>.</p><p>In addition, <code>peel</code> supports goals of the form <code>(‚àÄ x, p x) ‚Üî ‚àÄ x, q x</code>, or likewise for any
other quantifier. In this case, there is no hypothesis or term to supply, but otherwise the syntax
is the same. So for such goals, the syntax is <code>peel 1</code> or <code>peel with x</code>, and after which the
resulting goal is <code>p x ‚Üî q x</code>. The <code>congr!</code> tactic can also be applied to goals of this form using
<code>congr! 1 with x</code>. While <code>congr!</code> applies congruence lemmas in general, <code>peel</code> can be relied upon
to only apply to outermost quantifiers.</p><p>Finally, the user may supply a term <code>e</code> via <code>... using e</code> in order to close the goal
immediately. In particular, <code>peel h using e</code> is equivalent to <code>peel h; exact e</code>. The <code>using</code> syntax
may be paired with any of the other features of <code>peel</code>.</p><p>This tactic works by repeatedly applying lemmas such as <code>forall_imp</code>, <code>Exists.imp</code>,
<code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Eventually.mp">Filter.Eventually.mp</a></code>, <code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Frequently.mp">Filter.Frequently.mp</a></code>, and <code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Eventually.of_forall">Filter.Eventually.of_forall</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peel">Mathlib.Tactic.Peel</a></dd></dl></div><div id="Real.¬´tacticPi_lower_bound[_,,]¬ª"><h2>pi_lower_bound</h2><p><p>Create a proof of <code>a &lt; œÄ</code> for a fixed rational number <code>a</code>, given a witness, which is a
sequence of rational numbers <code>‚àö2 &lt; r 1 &lt; r 2 &lt; ... &lt; r n &lt; 2</code> satisfying the property that
<code>‚àö(2 + r i) ‚â§ r(i+1)</code>, where <code>r 0 = 0</code> and <code>‚àö(2 - r n) ‚â• a/2^(n+1)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Analysis/Real/Pi/Bounds.html#Real.¬´tacticPi_lower_bound[_,,]¬ª">Mathlib.Analysis.Real.Pi.Bounds</a></dd></dl></div><div id="Real.¬´tacticPi_upper_bound[_,,]¬ª"><h2>pi_upper_bound</h2><p><p>Create a proof of <code>œÄ &lt; a</code> for a fixed rational number <code>a</code>, given a witness, which is a
sequence of rational numbers <code>‚àö2 &lt; r 1 &lt; r 2 &lt; ... &lt; r n &lt; 2</code> satisfying the property that
<code>‚àö(2 + r i) ‚â• r(i+1)</code>, where <code>r 0 = 0</code> and <code>‚àö(2 - r n) ‚â§ (a - 1/4^n) / 2^(n+1)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Analysis/Real/Pi/Bounds.html#Real.¬´tacticPi_upper_bound[_,,]¬ª">Mathlib.Analysis.Real.Pi.Bounds</a></dd></dl></div><div id="Mathlib.Tactic.PNatToNat.tacticPnat_positivity"><h2>pnat_positivity</h2><p><p>For each <code>x : <a href="./Mathlib/Data/PNat/Notation.html#PNat">PNat</a></code> in the context, add the hypothesis <code>0 &lt; (‚Üëx : ‚Ñï)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/PNatToNat.html#Mathlib.Tactic.PNatToNat.tacticPnat_positivity">Mathlib.Tactic.PNatToNat</a></dd></dl></div><div id="Mathlib.Tactic.PNatToNat.tacticPnat_to_nat"><h2>pnat_to_nat</h2><p><p><code>pnat_to_nat</code> shifts all <code><a href="./Mathlib/Data/PNat/Notation.html#PNat">PNat</a></code>s in the context to <code>Nat</code>, rewriting propositions about them.
A typical use case is <code>pnat_to_nat; lia</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/PNatToNat.html#Mathlib.Tactic.PNatToNat.tacticPnat_to_nat">Mathlib.Tactic.PNatToNat</a></dd></dl></div><div id="Mathlib.Tactic.Polyrith.¬´tacticPolyrithOnly[_]¬ª"><h2>polyrith</h2><p><p>The <code>polyrith</code> tactic is no longer supported in Mathlib,
because it relied on a defunct external service.</p><hr>
<p>Attempts to prove polynomial equality goals through polynomial arithmetic
on the hypotheses (and additional proof terms if the user specifies them).
It proves the goal by generating an appropriate call to the tactic
<code>linear_combination</code>. If this call succeeds, the call to <code>linear_combination</code>
is suggested to the user.</p><ul><li><code>polyrith</code> will use all relevant hypotheses in the local context.</li><li><code>polyrith [t1, t2, t3]</code> will add proof terms t1, t2, t3 to the local context.</li><li><code>polyrith only [h1, h2, h3, t1, t2, t3]</code> will use only local hypotheses
<code>h1</code>, <code>h2</code>, <code>h3</code>, and proofs <code>t1</code>, <code>t2</code>, <code>t3</code>. It will ignore the rest of the local context.</li></ul><p>Notes:</p><ul><li>This tactic only works with a working internet connection, since it calls Sage
using the SageCell web API at <a href="https://sagecell.sagemath.org/">https://sagecell.sagemath.org/</a>.
Many thanks to the Sage team and organization for allowing this use.</li><li>This tactic assumes that the user has <code>curl</code> available on path.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Polyrith.html#Mathlib.Tactic.Polyrith.¬´tacticPolyrithOnly[_]¬ª">Mathlib.Tactic.Polyrith</a></dd></dl></div><div id="Mathlib.Tactic.Positivity.positivity"><h2>positivity</h2><p><p>Tactic solving goals of the form <code>0 ‚â§ x</code>, <code>0 &lt; x</code> and <code>x ‚â† 0</code>.  The tactic works recursively
according to the syntax of the expression <code>x</code>, if the atoms composing the expression all have
numeric lower bounds which can be proved positive/nonnegative/nonzero by <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.  This tactic
either closes the goal or fails.</p><p><code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a> [t‚ÇÅ, ‚Ä¶, t‚Çô]</code> first executes <code>have := t‚ÇÅ; ‚Ä¶; have := t‚Çô</code> in the current goal,
then runs <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code>. This is useful when <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> needs derived premises such as <code>0 &lt; y</code>
for division/reciprocal, or <code>0 ‚â§ x</code> for real powers.</p><p>Examples:</p><pre><code>example {a : ‚Ñ§} (ha : 3 &lt; a) : 0 ‚â§ a ^ 3 + a := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {a : ‚Ñ§} (ha : 1 &lt; a) : 0 &lt; |(3:‚Ñ§) + a| := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {b : ‚Ñ§} : 0 ‚â§ max (-3) (b ^ 2) := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {a b c d : ‚Ñù} (hab : 0 &lt; a * b) (hb : 0 ‚â§ b) (hcd : c &lt; d) :
    0 &lt; a ^ c + 1 / (d - c) := by
  <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a> [sub_pos_of_lt hcd, <a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#pos_of_mul_pos_left">pos_of_mul_pos_left</a> hab hb]
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Positivity/Core.html#Mathlib.Tactic.Positivity.positivity">Mathlib.Tactic.Positivity.Core</a></dd></dl></div><div id="Mathlib.Tactic.Push.pull"><h2>pull</h2><p><p><code>pull c</code> rewrites the goal by pulling the constant <code>c</code> closer to the head of the expression.
For instance, <code>pull _ ‚àà _</code> rewrites <code>x ‚àà y ‚à® ¬¨ x ‚àà z</code> into <code>x ‚àà y ‚à™ z·∂ú</code>.
More precisely, the <code>pull</code> tactic repeatedly rewrites an expression by applying lemmas
of the form <code>... (c ...) = c ...</code> (where <code>c</code> can appear 1 or more times on the left hand side).
<code>pull</code> is the inverse tactic to <code>push</code>. To extend the <code>pull</code> tactic, you can tag a lemma
with the <code>@[push]</code> attribute. <code>pull</code> works as both a tactic and a conv tactic.</p><p>A lemma is considered a <code>pull</code> lemma if its reverse direction is a <code>push</code> lemma
that actually moves the given constant away from the head. For example</p><ul><li><code>not_or : ¬¨ (p ‚à® q) ‚Üî ¬¨ p ‚àß ¬¨ q</code> is a <code>pull</code> lemma, but <code>not_not : ¬¨ ¬¨ p ‚Üî p</code> is not.</li><li><code>log_mul : log (x * y) = log x + log y</code> is a <code>pull</code> lemma, but <code>log_abs : log |x| = log x</code> is not.</li><li><code><a href="./Mathlib/Algebra/Notation/Pi/Defs.html#Pi.mul_def">Pi.mul_def</a> : f * g = fun (i : Œπ) =&gt; f i * g i</code> and <code><a href="./Mathlib/Algebra/Notation/Pi/Defs.html#Pi.one_def">Pi.one_def</a> : 1 = fun (x : Œπ) =&gt; 1</code> are both
<code>pull</code> lemmas for <code>fun</code>, because every <code>push fun _ ‚Ü¶ _</code> lemma is also considered a <code>pull</code> lemma.</li></ul><p>TODO: define a <code>@[pull]</code> attribute for tagging <code>pull</code> lemmas that are not <code>push</code> lemmas.</p><ul><li><code>pull _ ~ _</code> pulls the operator or relation <code>~</code>.</li><li><code>pull c at l1 l2 ...</code> rewrites at the given locations.</li><li><code>pull c at *</code> rewrites at all hypotheses and the goal.</li><li><code>pull (disch := tac) c</code> uses the tactic <code>tac</code> to discharge any hypotheses for <code>@[push]</code> lemmas.</li></ul><p>Examples:</p><ul><li><code>pull _ ‚àà _</code> rewrites <code>x ‚àà y ‚à® ¬¨ x ‚àà z</code> into <code>x ‚àà y ‚à™ z·∂ú</code>.</li><li><code>pull (disch := positivity) <a href="./Mathlib/Analysis/SpecialFunctions/Log/Basic.html#Real.log">Real.log</a></code> rewrites <code>log a + 2 * log b</code> into <code>log (a * b ^ 2)</code>.</li><li><code>pull fun _ ‚Ü¶ _</code> rewrites <code>f ^ 2 + 5</code> into <code>fun x =&gt; f x ^ 2 + 5</code> where <code>f</code> is a function.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull">Mathlib.Tactic.Push</a></dd></dl></div><div id="Mathlib.Tactic.Coherence.pure_coherence"><h2>pure_coherence</h2><p><p><code>pure_coherence</code> uses the coherence theorem for monoidal categories to prove the goal.
It can prove any equality made up only of associators, unitors, and identities.</p><pre><code class="language-lean">example {C : Type} [Category* C] [MonoidalCategory C] :
  (Œª_ (ùüô_ C)).hom = (œÅ_ (ùüô_ C)).hom := by
  pure_coherence
</code></pre><p>Users will typically just use the <code>coherence</code> tactic,
which can also cope with identities of the form
<code>a ‚â´ f ‚â´ b ‚â´ g ‚â´ c = a' ‚â´ f ‚â´ b' ‚â´ g ‚â´ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>pure_coherence</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Coherence.html#Mathlib.Tactic.Coherence.pure_coherence">Mathlib.Tactic.CategoryTheory.Coherence</a></dd></dl></div><div id="Mathlib.Tactic.Push.pushStx"><h2>push</h2><p><p><code>push c</code> rewrites the goal by pushing the constant <code>c</code> deeper into an expression.
For instance, <code>push _ ‚àà _</code> rewrites <code>x ‚àà {y} ‚à™ z·∂ú</code> into <code>x = y ‚à® ¬¨ x ‚àà z</code>.
More precisely, the <code>push</code> tactic repeatedly rewrites an expression by applying lemmas
of the form <code>c ... = ... (c ...)</code> (where <code>c</code> can appear 0 or more times on the right hand side).
To extend the <code>push</code> tactic, you can tag a lemma of this form with the <code>@[push]</code> attribute.</p><p>To instead move a constant closer to the head of the expression, use the <code>pull</code> tactic.</p><p><code>push</code> works as both a tactic and a conv tactic.</p><ul><li><code>push _ ~ _</code> pushes the (binary) operator <code>~</code>, <code>push ~ _</code> pushes the (unary) operator <code>~</code>.</li><li><code>push c at l1 l2 ...</code> rewrites at the given locations.</li><li><code>push c at *</code> rewrites at all hypotheses and the goal.</li><li><code>push (disch := tac) c</code> uses the tactic <code>tac</code> to discharge any hypotheses for <code>@[push]</code> lemmas.</li></ul><p>Examples:</p><ul><li><code>push _ ‚àà _</code> rewrites <code>x ‚àà {y} ‚à™ z·∂ú</code> into <code>x = y ‚à® ¬¨ x ‚àà z</code>.</li><li><code>push (disch := positivity) <a href="./Mathlib/Analysis/SpecialFunctions/Log/Basic.html#Real.log">Real.log</a></code> rewrites <code>log (a * b ^ 2)</code> into <code>log a + 2 * log b</code>.</li><li><code>push ¬¨ _</code> is the same as <code>push_neg</code> or <code>push Not</code>, and it rewrites
<code>¬¨ ‚àÄ Œµ &gt; 0, ‚àÉ Œ¥ &gt; 0, Œ¥ &lt; Œµ</code> into <code>‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, Œµ ‚â§ Œ¥</code>.</li><li><code>push fun _ ‚Ü¶ _</code> rewrites <code>fun x =&gt; f x ^ 2 + 5</code> into <code>f ^ 2 + 5</code></li><li><code>push ‚àÄ _, _</code> rewrites <code>‚àÄ a, p a ‚àß q a</code> into <code>(‚àÄ a, p a) ‚àß (‚àÄ a, q a)</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx">Mathlib.Tactic.Push</a></dd></dl></div><div id="Mathlib.Tactic.Push.push_neg"><h2>push_neg</h2><p><p><code>push_neg</code> rewrites the goal by pushing negations deeper into an expression.
For instance, the goal <code>¬¨ ‚àÄ x, ‚àÉ y, x ‚â§ y</code> will be transformed by <code>push_neg</code> into
<code>‚àÉ x, ‚àÄ y, y &lt; x</code>. Binder names are preserved (contrary to what would happen with <code>simp</code>
using the relevant lemmas). <code>push_neg</code> works as both a tactic and a conv tactic.</p><p><code>push_neg</code> is a special case of the more general <code>push</code> tactic, namely <code>push Not</code>.
The <code>push</code> tactic can be extended using the <code>@[push]</code> attribute. <code>push</code> has special-casing
built in for <code>push Not</code>.</p><p>Tactics that introduce a negation usually have a version that automatically calls <code>push_neg</code> on
that negation. These include <code>by_cases!</code>, <code>contrapose!</code> and <code>by_contra!</code>.</p><ul><li><code>push_neg at l1 l2 ...</code> rewrites at the given locations.</li><li><code>push_neg at *</code> rewrites at each hypothesis and the goal.</li><li><code>push_neg +distrib</code> rewrites <code>¬¨ (p ‚àß q)</code> into <code>¬¨ p ‚à® ¬¨ q</code> (by default, the tactic rewrites it
into <code>p ‚Üí ¬¨ q</code> instead).</li></ul><p>Example:</p><pre><code class="language-lean">example (h : ¬¨ ‚àÄ Œµ &gt; 0, ‚àÉ Œ¥ &gt; 0, ‚àÄ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚Üí |f x - y‚ÇÄ| ‚â§ Œµ) :
    ‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, ‚àÉ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚àß Œµ &lt; |f x - y‚ÇÄ| := by
  push_neg at h
  -- Now we have the hypothesis `h : ‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, ‚àÉ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚àß Œµ &lt; |f x - y‚ÇÄ|`
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg">Mathlib.Tactic.Push</a></dd></dl></div><div id="Mathlib.Tactic.Qify.qify"><h2>qify</h2><p><p>The <code>qify</code> tactic is used to shift propositions from <code>‚Ñï</code> or <code>‚Ñ§</code> to <code>‚Ñö</code>.
This is often useful since <code>‚Ñö</code> has well-behaved division.</p><pre><code>example (a b c x y z : ‚Ñï) (h : ¬¨ x*y*z &lt; 0) : c &lt; a + 3*b := by
  qify
  qify at h
  /-
  h : ¬¨‚Üëx * ‚Üëy * ‚Üëz &lt; 0
  ‚ä¢ ‚Üëc &lt; ‚Üëa + 3 * ‚Üëb
  -/
  sorry
</code></pre><p><code>qify</code> can be given extra lemmas to use in simplification. This is especially useful in the
presence of nat subtraction: passing <code>‚â§</code> arguments will allow <code>push_cast</code> to do more work.</p><pre><code>example (a b c : ‚Ñ§) (h : a / b = c) (hab : b ‚à£ a) (hb : b ‚â† 0) : a = c * b := by
  qify [hab] at h hb ‚ä¢
  exact (div_eq_iff hb).1 h
</code></pre><p><code>qify</code> makes use of the <code>@[zify_simps]</code> and <code>@[qify_simps]</code> attributes to move propositions,
and the <code>push_cast</code> tactic to simplify the <code>‚Ñö</code>-valued expressions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Qify.html#Mathlib.Tactic.Qify.qify">Mathlib.Tactic.Qify</a></dd></dl></div><div id="Mathlib.Tactic.tacticRecover_"><h2>recover</h2><p><p><code>recover tacs</code> applies the tactic (sequence) <code>tacs</code> and then re-adds goals that were
incorrectly marked as closed. This helps to debug issues where a tactic closes goals without
solving them (i.e. goals were removed from the MetaM state without the metavariable
being assigned), resulting in the error &quot;(kernel) declaration has metavariables&quot;.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Recover.html#Mathlib.Tactic.tacticRecover_">Mathlib.Tactic.Recover</a></dd></dl></div><div id="Mathlib.Tactic.tacticReduce__"><h2>reduce</h2><p><p><code>reduce at loc</code> completely reduces the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>This does the same transformation as the <code>#reduce</code> command.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Tactic.ReduceModChar.reduce_mod_char"><h2>reduce_mod_char</h2><p><p>The tactic <code>reduce_mod_char</code> looks for numeric expressions in characteristic <code>p</code>
and reduces these to lie between <code>0</code> and <code>p</code>.</p><p>For example:</p><pre><code>example : (5 : <a href="./Mathlib/Data/ZMod/Defs.html#ZMod">ZMod</a> 4) = 1 := by reduce_mod_char
example : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char
</code></pre><p>It also handles negation, turning it into multiplication by <code>p - 1</code>,
and similarly subtraction.</p><p>This tactic uses the type of the subexpression to figure out if it is indeed of positive
characteristic, for improved performance compared to trying to synthesise a <code><a href="./Mathlib/Algebra/CharP/Defs.html#CharP">CharP</a></code> instance.
The variant <code>reduce_mod_char!</code> also tries to use <code><a href="./Mathlib/Algebra/CharP/Defs.html#CharP">CharP</a> R n</code> hypotheses in the context.
(Limitations of the typeclass system mean the tactic can't search for a <code><a href="./Mathlib/Algebra/CharP/Defs.html#CharP">CharP</a> R n</code> instance if
<code>n</code> is not yet known; use <code>have : <a href="./Mathlib/Algebra/CharP/Defs.html#CharP">CharP</a> R n := inferInstance; reduce_mod_char!</code> as a workaround.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char">Mathlib.Tactic.ReduceModChar</a></dd></dl></div><div id="Mathlib.Tactic.refoldLetStx"><h2>refold_let</h2><p><p><code>refold_let x y z at loc</code> looks for the bodies of local definitions <code>x</code>, <code>y</code>, and <code>z</code> at the given
location and replaces them with <code>x</code>, <code>y</code>, or <code>z</code>. This is the inverse of &quot;zeta reduction.&quot;
This also exists as a <code>conv</code>-mode tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª"><h2>rel</h2><p><p>The <code>rel</code> tactic applies &quot;generalized congruence&quot; rules to solve a relational goal by
&quot;substitution&quot;.  For example,</p><pre><code>example {a b x c d : ‚Ñù} (h1 : a ‚â§ b) (h2 : c ‚â§ d) :
    x ^ 2 * a + c ‚â§ x ^ 2 * b + d := by
  rel [h1, h2]
</code></pre><p>In this example we &quot;substitute&quot; the hypotheses <code>a ‚â§ b</code> and <code>c ‚â§ d</code> into the LHS <code>x ^ 2 * a + c</code> of
the goal and obtain the RHS <code>x ^ 2 * b + d</code>, thus proving the goal.</p><p>The &quot;generalized congruence&quot; rules used are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code><a href="./Mathlib/Algebra/Order/Monoid/Unbundled/Basic.html#add_le_add">add_le_add</a> (mul_le_mul_of_nonneg_left h1 (pow_bit0_nonneg x 1)) h2
</code></pre><p>using the generalized congruence lemmas <code><a href="./Mathlib/Algebra/Order/Monoid/Unbundled/Basic.html#add_le_add">add_le_add</a></code> and <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_left">mul_le_mul_of_nonneg_left</a></code>.  If there are
no applicable generalized congruence lemmas, the tactic fails.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ‚â§ x ^ 2</code> in the above application of <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_left">mul_le_mul_of_nonneg_left</a></code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> but can also be extended. If the side goals cannot
be discharged in this way, the tactic fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="Mathlib.Tactic.rename'"><h2>rename'</h2><p><p><code>rename' h =&gt; hnew</code> renames the hypothesis named <code>h</code> to <code>hnew</code>.
To rename several hypothesis, use <code>rename' h‚ÇÅ =&gt; h‚ÇÅnew, h‚ÇÇ =&gt; h‚ÇÇnew</code>.
You can use <code>rename' a =&gt; b, b =&gt; a</code> to swap two variables.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Rename.html#Mathlib.Tactic.rename'">Mathlib.Tactic.Rename</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª"><h2>rename_bvar</h2><p><ul><li><code>rename_bvar old ‚Üí new</code> renames all bound variables named <code>old</code> to <code>new</code> in the target.</li><li><code>rename_bvar old ‚Üí new at h</code> does the same in hypothesis <code>h</code>.</li></ul><pre><code class="language-lean">example (P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) (h : ‚àÄ n, ‚àÉ m, P n m) : ‚àÄ l, ‚àÉ m, P l m := by
  rename_bvar n ‚Üí q at h -- h is now ‚àÄ (q : ‚Ñï), ‚àÉ (m : ‚Ñï), P q m,
  rename_bvar m ‚Üí n -- target is now ‚àÄ (l : ‚Ñï), ‚àÉ (n : ‚Ñï), P k n,
  exact h -- Lean does not care about those bound variable names
</code></pre><p>Note: name clashes are resolved automatically.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/RenameBVar.html#Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª">Mathlib.Tactic.RenameBVar</a></dd></dl></div><div id="Mathlib.Tactic.tacticRepeat1_"><h2>repeat1</h2><p><p><code>repeat1 tac</code> applies <code>tac</code> to main goal at least once. If the application succeeds,
the tactic is applied recursively to the generated subgoals until it eventually fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Core.html#Mathlib.Tactic.tacticRepeat1_">Mathlib.Tactic.Core</a></dd></dl></div><div id="Mathlib.Tactic.replace'"><h2>replace</h2><p><p>Acts like <code>have</code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p><p>Then after <code>replace h : Œ≤</code> the state will be:</p><pre><code class="language-lean">case h
f : Œ± ‚Üí Œ≤
h : Œ±
‚ä¢ Œ≤

f : Œ± ‚Üí Œ≤
h : Œ≤
‚ä¢ goal
</code></pre><p>whereas <code>have h : Œ≤</code> would result in:</p><pre><code class="language-lean">case h
f : Œ± ‚Üí Œ≤
h : Œ±
‚ä¢ Œ≤

f : Œ± ‚Üí Œ≤
h‚úù : Œ±
h : Œ≤
‚ä¢ goal
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Replace.html#Mathlib.Tactic.replace'">Mathlib.Tactic.Replace</a></dd></dl></div><div id="TopCat.Presheaf.restrict_tac"><h2>restrict_tac</h2><p><p><code>restrict_tac</code> solves relations among subsets (copied from <code>aesop cat</code>)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf.restrict_tac">Mathlib.Topology.Sheaves.Presheaf</a></dd></dl></div><div id="TopCat.Presheaf.restrict_tac?"><h2>restrict_tac?</h2><p><p><code>restrict_tac?</code> passes along <code>Try this</code> from <code>aesop</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf.restrict_tac?">Mathlib.Topology.Sheaves.Presheaf</a></dd></dl></div><div id="Mathlib.Tactic.DepRewrite.depRewriteSeq"><h2>rewrite!</h2><p><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code>castMode</code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteSeq">Mathlib.Tactic.DepRewrite</a></dd></dl></div><div id="CategoryTheory.rfl_cat"><h2>rfl_cat</h2><p><p><code>rfl_cat</code> is a macro for <code>intros; rfl</code> which is attempted in <code>aesop_cat</code> before
doing the more expensive <code>aesop</code> tactic.</p><p>This gives a speedup because <code>simp</code> (called by <code>aesop</code>) can be very slow.
<a href="https://github.com/leanprover-community/mathlib4/pull/25475">https://github.com/leanprover-community/mathlib4/pull/25475</a> contains measurements from June 2025.</p><p>Implementation notes:</p><ul><li><code>refine id ?_</code>:
In some cases it is important that the type of the proof matches the expected type exactly.
e.g. if the goal is <code>2 = 1 + 1</code>, the <code>rfl</code> tactic will give a proof of type <code>2 = 2</code>.
Starting a proof with <code>refine id ?_</code> is a trick to make sure that the proof has exactly
the expected type, in this case <code>2 = 1 + 1</code>. See also
https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/changing.20a.20proof.20can.20break.20a.20later.20proof</li><li><code>apply_rfl</code>:
<code>rfl</code> is a macro that attempts both <code>eq_refl</code> and <code>apply_rfl</code>. Since <code>apply_rfl</code>
subsumes <code>eq_refl</code>, we can use <code>apply_rfl</code> instead. This fails twice as fast as <code>rfl</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.rfl_cat">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Rify.rify"><h2>rify</h2><p><p>The <code>rify</code> tactic is used to shift propositions from <code>‚Ñï</code>, <code>‚Ñ§</code> or <code>‚Ñö</code> to <code>‚Ñù</code>.
Although less useful than its cousins <code>zify</code> and <code>qify</code>, it can be useful when your
goal or context already involves real numbers.</p><p>In the example below, assumption <code>hn</code> is about natural numbers, <code>hk</code> is about integers
and involves casting a natural number to <code>‚Ñ§</code>, and the conclusion is about real numbers.
The proof uses <code>rify</code> to lift both assumptions to <code>‚Ñù</code> before calling <code>linarith</code>.</p><pre><code>example {n : ‚Ñï} {k : ‚Ñ§} (hn : 8 ‚â§ n) (hk : 2 * k ‚â§ n + 2) :
    (0 : ‚Ñù) &lt; n - k - 1 := by
  rify at hn hk /- Now have hn : 8 ‚â§ (n : ‚Ñù)   hk : 2 * (k : ‚Ñù) ‚â§ (n : ‚Ñù) + 2 -/
  linarith
</code></pre><p><code>rify</code> makes use of the <code>@[zify_simps]</code>, <code>@[qify_simps]</code> and <code>@[rify_simps]</code> attributes to move
propositions, and the <code>push_cast</code> tactic to simplify the <code>‚Ñù</code>-valued expressions.</p><p><code>rify</code> can be given extra lemmas to use in simplification. This is especially useful in the
presence of nat subtraction: passing <code>‚â§</code> arguments will allow <code>push_cast</code> to do more work.</p><pre><code>example (a b c : ‚Ñï) (h : a - b &lt; c) (hab : b ‚â§ a) : a &lt; b + c := by
  rify [hab] at h ‚ä¢
  linarith
</code></pre><p>Note that <code>zify</code> or <code>qify</code> would work just as well in the above example (and <code>zify</code> is the natural
choice since it is enough to get rid of the pathological <code>‚Ñï</code> subtraction).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Rify.html#Mathlib.Tactic.Rify.rify">Mathlib.Tactic.Rify</a></dd></dl></div><div id="Mathlib.Tactic.RingNF.ring"><h2>ring</h2><p><p><code>ring</code> solves equations in <em>commutative</em> (semi)rings, allowing for variables in the
exponent. If the goal is not appropriate for <code>ring</code> (e.g. not an equality) <code>ring_nf</code> will be
suggested. See also <code>ring1</code>, which fails if the goal is not an equality.</p><ul><li><code>ring!</code> will use a more aggressive reducibility setting to determine equality of atoms.</li></ul><p>Examples:</p><pre><code>example (n : ‚Ñï) (m : ‚Ñ§) : 2^(n+1) * m = 2 * 2^n * m := by ring
example (a b : ‚Ñ§) (n : ‚Ñï) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring
example (x y : ‚Ñï) : x + id y = y + id x := by ring!
example (x : ‚Ñï) (h : x * 2 &gt; 5): x + x &gt; 5 := by ring; assumption -- suggests ring_nf
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring">Mathlib.Tactic.Ring.RingNF</a></dd></dl></div><div id="Mathlib.Tactic.Ring.ring1"><h2>ring1</h2><p><p><code>ring1</code> solves the goal when it is an equality in <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><p>This version of <code>ring</code> fails if the target is not an equality.</p><ul><li><code>ring1!</code> uses a more aggressive reducibility setting to determine equality of atoms.</li></ul><p>Extensions:</p><ul><li><ul><li><code>ring1_nf</code> additionally uses <code>ring_nf</code> to simplify in atoms.</li><li><code>ring1_nf!</code> will use a more aggressive reducibility setting
to determine equality of atoms.* <code>ring1_nf</code> additionally uses <code>ring_nf</code> to simplify in atoms.</li></ul></li><li><code>ring1_nf!</code> will use a more aggressive reducibility setting
to determine equality of atoms.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">Mathlib.Tactic.Ring.Basic</a></dd></dl></div><div id="Mathlib.Tactic.RingNF.ringNF"><h2>ring_nf</h2><p><p><code>ring_nf</code> simplifies expressions in the language of commutative (semi)rings,
which rewrites all ring expressions into a normal form, allowing variables in the exponents.</p><p><code>ring_nf</code> works as both a tactic and a conv tactic.</p><p>See also the <code>ring</code> tactic for solving a goal which is an equation in the language
of commutative (semi)rings.</p><ul><li><code>ring_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li><li><code>ring_nf (config := cfg)</code> allows for additional configuration (see <code>RingNF.Config</code>):<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li><li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li><li><code>recursive</code>: if true, <code>ring_nf</code> will also recurse into atoms</li></ul></li><li><code>ring_nf at l1 l2 ...</code> can be used to rewrite at the given locations.</li></ul><p>Examples:
This can be used non-terminally to normalize ring expressions in the goal such as
<code>‚ä¢ P (x + x + x)</code> ~&gt; <code>‚ä¢ P (x * 3)</code>, as well as being able to prove some equations that
<code>ring</code> cannot because they involve ring reasoning inside a subterm, such as
<code>sin (x + y) + sin (y + x) = 2 * sin (x + y)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF">Mathlib.Tactic.Ring.RingNF</a></dd></dl></div><div id="Mathlib.Tactic.rsuffices"><h2>rsuffices</h2><p><p>The <code>rsuffices</code> tactic is an alternative version of <code>suffices</code>, that allows the usage
of any syntax that would be valid in an <code>obtain</code> block. This tactic just calls <code>obtain</code>
on the expression, and then <code>rotate_left</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/RSuffices.html#Mathlib.Tactic.rsuffices">Mathlib.Tactic.RSuffices</a></dd></dl></div><div id="Mathlib.Tactic.DepRewrite.depRwSeq"><h2>rw!</h2><p><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwSeq">Mathlib.Tactic.DepRewrite</a></dd></dl></div><div id="Mathlib.Tactic.LibraryRewrite.tacticRw??"><h2>rw??</h2><p><p><code>rw??</code> is an interactive tactic that suggests rewrites for any expression selected by the user.
To use it, shift-click an expression in the goal or a hypothesis that you want to rewrite.
Clicking on one of the rewrite suggestions will paste the relevant rewrite tactic into the editor.</p><p>The rewrite suggestions are grouped and sorted by the pattern that the rewrite lemmas match with.
Rewrites that don't change the goal and rewrites that create the same goal as another rewrite
are filtered out, as well as rewrites that have new metavariables in the replacement expression.
To see all suggestions, click on the filter button (‚ñº) in the top right.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/LibraryRewrite.html#Mathlib.Tactic.LibraryRewrite.tacticRw??">Mathlib.Tactic.Widget.LibraryRewrite</a></dd></dl></div><div id="Mathlib.Tactic.RewriteSearch.tacticRw_search_"><h2>rw_search</h2><p><p><code>rw_search</code> has been removed from Mathlib.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/RewriteSearch.html#Mathlib.Tactic.RewriteSearch.tacticRw_search_">Mathlib.Tactic.RewriteSearch</a></dd></dl></div><div id="Mathlib.Tactic.Says.says"><h2>says</h2><p><p>If you write <code>X says</code>, where <code>X</code> is a tactic that produces a &quot;Try this: Y&quot; message,
then you will get a message &quot;Try this: X says Y&quot;.
Once you've clicked to replace <code>X says</code> with <code>X says Y</code>,
afterwards <code>X says Y</code> will only run <code>Y</code>.</p><p>The typical usage case is:</p><pre><code>simp? [X] says simp only [X, Y, Z]
</code></pre><p>If you use <code>set_option says.verify true</code> (set automatically during CI) then <code>X says Y</code>
runs <code>X</code> and verifies that it still prints &quot;Try this: Y&quot;.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Says.html#Mathlib.Tactic.Says.says">Mathlib.Tactic.Says</a></dd></dl></div><div id="Mathlib.Tactic.setTactic"><h2>set</h2><p><p><code>set a := t with h</code> is a variant of <code>let a := t</code>. It adds the hypothesis <code>h : a = t</code> to
the local context and replaces <code>t</code> with <code>a</code> everywhere it can.</p><p><code>set a := t with ‚Üê h</code> will add <code>h : t = a</code> instead.</p><p><code>set! a := t with h</code> does not do any replacing.</p><pre><code class="language-lean">example (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by
  set y := x with ‚Üê h2
  sorry
/-
x : Nat
y : Nat := x
h : y + y - y = 3
h2 : x = y
‚ä¢ y + y - y = 3
-/
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Set.html#Mathlib.Tactic.setTactic">Mathlib.Tactic.Set</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª"><h2>simp_intro</h2><p><p>The <code>simp_intro</code> tactic is a combination of <code>simp</code> and <code>intro</code>: it will simplify the types of
variables as it introduces them and uses the new variables to simplify later arguments
and the goal.</p><ul><li><code>simp_intro x y z</code> introduces variables named <code>x y z</code></li><li><code>simp_intro x y z ..</code> introduces variables named <code>x y z</code> and then keeps introducing <code>_</code> binders</li><li><code>simp_intro (config := cfg) (discharger := tac) x y .. only [h‚ÇÅ, h‚ÇÇ]</code>:
<code>simp_intro</code> takes the same options as <code>simp</code> (see <code>simp</code>)</li></ul><pre><code>example : x + 0 = y ‚Üí x = z := by
  simp_intro h
  -- h: x = y ‚ä¢ y = z
  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SimpIntro.html#Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª">Mathlib.Tactic.SimpIntro</a></dd></dl></div><div id="Mathlib.Tactic.tacticSimp_rw___"><h2>simp_rw</h2><p><p><code>simp_rw</code> functions as a mix of <code>simp</code> and <code>rw</code>. Like <code>rw</code>, it applies each
rewrite rule in the given order, but like <code>simp</code> it repeatedly applies these
rules and also under binders like <code>‚àÄ x, ...</code>, <code>‚àÉ x, ...</code> and <code>fun x ‚Ü¶...</code>.
Usage:</p><ul><li><code>simp_rw [lemma_1, ..., lemma_n]</code> will rewrite the goal by applying the
lemmas in that order. A lemma preceded by <code>‚Üê</code> is applied in the reverse direction.</li><li><code>simp_rw [lemma_1, ..., lemma_n] at h‚ÇÅ ... h‚Çô</code> will rewrite the given hypotheses.</li><li><code>simp_rw [...] at *</code> rewrites in the whole context: all hypotheses and the goal.</li></ul><p>Lemmas passed to <code>simp_rw</code> must be expressions that are valid arguments to <code>simp</code>.
For example, neither <code>simp</code> nor <code>rw</code> can solve the following, but <code>simp_rw</code> can:</p><pre><code class="language-lean">example {a : ‚Ñï}
    (h1 : ‚àÄ a b : ‚Ñï, a - 1 ‚â§ b ‚Üî a ‚â§ b + 1)
    (h2 : ‚àÄ a b : ‚Ñï, a ‚â§ b ‚Üî ‚àÄ c, c &lt; a ‚Üí c &lt; b) :
    (‚àÄ b, a - 1 ‚â§ b) = ‚àÄ b c : ‚Ñï, c &lt; a ‚Üí c &lt; b + 1 := by
  simp_rw [h1, h2]
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SimpRw.html#Mathlib.Tactic.tacticSimp_rw___">Mathlib.Tactic.SimpRw</a></dd></dl></div><div id="tacticSleep_heartbeats_"><h2>sleep_heartbeats</h2><p><p>do nothing for at least n heartbeats</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Util/SleepHeartbeats.html#tacticSleep_heartbeats_">Mathlib.Util.SleepHeartbeats</a></dd></dl></div><div id="Mathlib.Tactic.Slice.sliceLHS"><h2>slice_lhs</h2><p><p><code>slice_lhs a b =&gt; tac</code> zooms to the left-hand side, uses associativity for categorical
composition as needed, zooms in on the <code>a</code>-th through <code>b</code>-th morphisms, and invokes <code>tac</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Slice.html#Mathlib.Tactic.Slice.sliceLHS">Mathlib.Tactic.CategoryTheory.Slice</a></dd></dl></div><div id="Mathlib.Tactic.Slice.sliceRHS"><h2>slice_rhs</h2><p><p><code>slice_rhs a b =&gt; tac</code> zooms to the right-hand side, uses associativity for categorical
composition as needed, zooms in on the <code>a</code>-th through <code>b</code>-th morphisms, and invokes <code>tac</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/Slice.html#Mathlib.Tactic.Slice.sliceRHS">Mathlib.Tactic.CategoryTheory.Slice</a></dd></dl></div><div id="RatFunc.tacticSmul_tac"><h2>smul_tac</h2><p><p>Solve equations for <code><a href="./Mathlib/FieldTheory/RatFunc/Defs.html#RatFunc">RatFunc</a> K</code> by applying <code><a href="./Mathlib/FieldTheory/RatFunc/Basic.html#RatFunc.induction_on">RatFunc.induction_on</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/FieldTheory/RatFunc/Basic.html#RatFunc.tacticSmul_tac">Mathlib.FieldTheory.RatFunc.Basic</a></dd></dl></div><div id="CategoryTheory.sorryIfSorry"><h2>sorry_if_sorry</h2><p><p>Close the main goal with <code>sorry</code> if its type contains <code>sorry</code>, and fail otherwise.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.sorryIfSorry">Mathlib.CategoryTheory.Category.Basic</a></dd></dl></div><div id="Mathlib.Tactic.TautoSet.specialize_all"><h2>specialize_all</h2><p><p><code>specialize_all x</code> runs <code>specialize h x</code> for all hypotheses <code>h</code> where this tactic succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TautoSet.html#Mathlib.Tactic.TautoSet.specialize_all">Mathlib.Tactic.TautoSet</a></dd></dl></div><div id="Mathlib.Tactic.splitIfs"><h2>split_ifs</h2><p><p>Splits all if-then-else-expressions into multiple goals.
Given a goal of the form <code>g (if p then x else y)</code>, <code>split_ifs</code> will produce
two goals: <code>p ‚ä¢ g x</code> and <code>¬¨p ‚ä¢ g y</code>.
If there are multiple ite-expressions, then <code>split_ifs</code> will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.
<code>split_ifs at *</code> splits all ite-expressions in all hypotheses as well as the goal.
<code>split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ</code> overrides the default names for the hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SplitIfs.html#Mathlib.Tactic.splitIfs">Mathlib.Tactic.SplitIfs</a></dd></dl></div><div id="Mathlib.Tactic.subsingletonStx"><h2>subsingleton</h2><p><p>The <code>subsingleton</code> tactic tries to prove a goal of the form <code>x = y</code> or <code>x ‚âç y</code>
using the fact that the types involved are <em>subsingletons</em>
(a type with exactly zero or one terms).
To a first approximation, it does <code>apply Subsingleton.elim</code>.
As a nicety, <code>subsingleton</code> first runs the <code>intros</code> tactic.</p><ul><li>If the goal is an equality, it either closes the goal or fails.</li><li><code>subsingleton [inst1, inst2, ...]</code> can be used to add additional <code>Subsingleton</code> instances
to the local context. This can be more flexible than
<code>have := inst1; have := inst2; ...; subsingleton</code> since the tactic does not require that
all placeholders be solved for.</li></ul><p>Techniques the <code>subsingleton</code> tactic can apply:</p><ul><li>proof irrelevance</li><li>heterogeneous proof irrelevance (via <code>proof_irrel_heq</code>)</li><li>using <code>Subsingleton</code> (via <code>Subsingleton.elim</code>)</li><li>proving <code>BEq</code> instances are equal if they are both lawful (via <code><a href="./Mathlib/Logic/Basic.html#lawful_beq_subsingleton">lawful_beq_subsingleton</a></code>)</li></ul><h3 id="Properties" class="markdown-heading">Properties <a class="hover-link" href="#Properties">#</a></h3><p>The tactic is careful not to accidentally specialize <code>Sort _</code> to <code>Prop</code>,
avoiding the following surprising behavior of <code>apply Subsingleton.elim</code>:</p><pre><code class="language-lean">example (Œ± : Sort _) (x y : Œ±) : x = y := by apply Subsingleton.elim
</code></pre><p>The reason this <code>example</code> goes through is that
it applies the <code>‚àÄ (p : Prop), Subsingleton p</code> instance,
specializing the universe level metavariable in <code>Sort _</code> to <code>0</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx">Mathlib.Tactic.Subsingleton</a></dd></dl></div><div id="CategoryTheory.tacticSubst_hom_lift___"><h2>subst_hom_lift</h2><p><p><code>subst_hom_lift p f œÜ</code> tries to substitute <code>f</code> with <code>p(œÜ)</code> by using <code>p.IsHomLift f œÜ</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/FiberedCategory/HomLift.html#CategoryTheory.tacticSubst_hom_lift___">Mathlib.CategoryTheory.FiberedCategory.HomLift</a></dd></dl></div><div id="Mathlib.Tactic.Substs.substs"><h2>substs</h2><p><p>Applies the <code>subst</code> tactic to all given hypotheses from left to right.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Substs.html#Mathlib.Tactic.Substs.substs">Mathlib.Tactic.Substs</a></dd></dl></div><div id="Mathlib.Tactic.successIfFailWithMsg"><h2>success_if_fail_with_msg</h2><p><p><code>success_if_fail_with_msg msg tacs</code> runs <code>tacs</code> and succeeds only if they fail with the message
<code>msg</code>.</p><p><code>msg</code> can be any term that evaluates to an explicit <code>String</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SuccessIfFailWithMsg.html#Mathlib.Tactic.successIfFailWithMsg">Mathlib.Tactic.SuccessIfFailWithMsg</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticSwap_var__,,¬ª"><h2>swap_var</h2><p><p><code>swap_var swap_rule‚ÇÅ, swap_rule‚ÇÇ, ‚ãØ</code> applies <code>swap_rule‚ÇÅ</code> then <code>swap_rule‚ÇÇ</code> then <code>‚ãØ</code>.</p><p>A <em>swap_rule</em> is of the form <code>x y</code> or <code>x ‚Üî y</code>, and &quot;applying it&quot; means swapping the variable name
<code>x</code> by <code>y</code> and vice-versa on all hypotheses and the goal.</p><pre><code class="language-lean">example {P Q : Prop} (q : P) (p : Q) : P ‚àß Q := by
  swap_var p ‚Üî q
  exact ‚ü®p, q‚ü©
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SwapVar.html#Mathlib.Tactic.¬´tacticSwap_var__,,¬ª">Mathlib.Tactic.SwapVar</a></dd></dl></div><div id="Mathlib.Tactic.Tauto.tauto"><h2>tauto</h2><p><p><code>tauto</code> breaks down assumptions of the form <code>_ ‚àß _</code>, <code>_ ‚à® _</code>, <code>_ ‚Üî _</code> and <code>‚àÉ _, _</code>
and splits a goal of the form <code>_ ‚àß _</code>, <code>_ ‚Üî _</code> or <code>‚àÉ _, _</code> until it can be discharged
using <code>rfl</code> or <code>solve_by_elim</code>.
This is a finishing tactic: it either closes the goal or raises an error.</p><p>The Lean 3 version of this tactic by default attempted to avoid classical reasoning
where possible. This Lean 4 version makes no such attempt. The <code>itauto</code> tactic
is designed for that purpose.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.tauto">Mathlib.Tactic.Tauto</a></dd></dl></div><div id="Mathlib.Tactic.TautoSet.tacticTauto_set"><h2>tauto_set</h2><p><p><code>tauto_set</code> attempts to prove tautologies involving hypotheses and goals of the form <code>X ‚äÜ Y</code>
or <code>X = Y</code>, where <code>X</code>, <code>Y</code> are expressions built using ‚à™, ‚à©, , and ·∂ú from finitely many
variables of type <code><a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±</code>. It also unfolds expressions of the form <code><a href="./Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> A B</code> and
<code><a href="./Mathlib/Order/SymmDiff.html#symmDiff">symmDiff</a> A B</code>.</p><p>Examples:</p><pre><code class="language-lean">example {Œ±} (A B C D : <a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±) (h1 : A ‚äÜ B) (h2 : C ‚äÜ D) : C \ B ‚äÜ D \ A := by
  tauto_set

example {Œ±} (A B C : <a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±) (h1 : A ‚äÜ B ‚à™ C) : (A ‚à© B) ‚à™ (A ‚à© C) = A := by
  tauto_set
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TautoSet.html#Mathlib.Tactic.TautoSet.tacticTauto_set">Mathlib.Tactic.TautoSet</a></dd></dl></div><div id="Mathlib.Tactic.TFAE.tfaeFinish"><h2>tfae_finish</h2><p><p><code>tfae_finish</code> closes goals of the form <code>TFAE [P‚ÇÅ, P‚ÇÇ, ...]</code> once a sufficient collection
of hypotheses of the form <code>P·µ¢ ‚Üí P‚±º</code> or <code>P·µ¢ ‚Üî P‚±º</code> have been introduced to the local context.</p><p><code>tfae_have</code> can be used to conveniently introduce these hypotheses; see <code>tfae_have</code>.</p><p>Example:</p><pre><code class="language-lean4">example : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/
  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/
  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/
  tfae_finish
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish">Mathlib.Tactic.TFAE</a></dd></dl></div><div id="Mathlib.Tactic.TFAE.tfaeHave"><h2>tfae_have</h2><p><p><code>tfae_have i ‚Üí j := t</code>, where the goal is <code>TFAE [P‚ÇÅ, P‚ÇÇ, ...]</code> introduces a hypothesis
<code>tfae_i_to_j : P·µ¢ ‚Üí P‚±º</code> and proof <code>t</code> to the local context. Note that <code>i</code> and <code>j</code> are
natural number literals (beginning at 1) used as indices to specify the propositions
<code>P‚ÇÅ, P‚ÇÇ, ...</code> that appear in the goal.</p><p>Once sufficient hypotheses have been introduced by <code>tfae_have</code>, <code>tfae_finish</code> can be used to close
the goal.</p><p>All features of <code>have</code> are supported by <code>tfae_have</code>, including naming, matching,
destructuring, and goal creation.</p><ul><li><code>tfae_have i ‚Üê j := t</code> adds a hypothesis in the reverse direction, of type <code>P‚±º ‚Üí P·µ¢</code>.</li><li><code>tfae_have i ‚Üî j := t</code> adds a hypothesis in the both directions, of type <code>P·µ¢ ‚Üî P‚±º</code>.</li><li><code>tfae_have hij : i ‚Üí j := t</code> names the introduced hypothesis <code>hij</code> instead of <code>tfae_i_to_j</code>.</li><li><code>tfae_have i j | p‚ÇÅ =&gt; t‚ÇÅ | ...</code> matches on the assumption <code>p : P·µ¢</code>.</li><li><code>tfae_have ‚ü®hij, hji‚ü© : i ‚Üî j := t</code> destructures the bi-implication into <code>hij : P·µ¢ ‚Üí P‚±º</code>
and <code>hji : P‚±º ‚Üí P‚±º</code>.</li><li><code>tfae_have i ‚Üí j := t ?a</code> creates a new goal for <code>?a</code>.</li></ul><p>Examples:</p><pre><code class="language-lean4">example (h : P ‚Üí R) : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 3 := h
  -- The resulting context now includes `tfae_1_to_3 : P ‚Üí R`.
  sorry
</code></pre><pre><code class="language-lean4">-- An example of `tfae_have` and `tfae_finish`:
example : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/
  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/
  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/
  tfae_finish
</code></pre><pre><code class="language-lean4">-- All features of `have` are supported by `tfae_have`:
example : TFAE [P, Q] := by
  -- assert `tfae_1_to_2 : P ‚Üí Q`:
  tfae_have 1 ‚Üí 2 := sorry

  -- assert `hpq : P ‚Üí Q`:
  tfae_have hpq : 1 ‚Üí 2 := sorry

  -- match on `p : P` and prove `Q` via `f p`:
  tfae_have 1 ‚Üí 2
  | p =&gt; f p

  -- assert `pq : P ‚Üí Q`, `qp : Q ‚Üí P`:
  tfae_have ‚ü®pq, qp‚ü© : 1 ‚Üî 2 := sorry

  -- assert `h : P ‚Üí Q`; `?a` is a new goal:
  tfae_have h : 1 ‚Üí 2 := f ?a

  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave">Mathlib.Tactic.TFAE</a></dd></dl></div><div id="Set.tacticToFinite_tac"><h2>toFinite_tac</h2><p><p>A tactic (for use in default params) that applies <code><a href="./Mathlib/Data/Finite/Defs.html#Set.toFinite">Set.toFinite</a></code> to synthesize a <code><a href="./Mathlib/Data/Finite/Defs.html#Set.Finite">Set.Finite</a></code>
term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Set/Card.html#Set.tacticToFinite_tac">Mathlib.Data.Set.Card</a></dd></dl></div><div id="Set.tacticTo_encard_tac"><h2>to_encard_tac</h2><p><p>A tactic useful for transferring proofs for <code>encard</code> to their corresponding <code>card</code> statements</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Set/Card.html#Set.tacticTo_encard_tac">Mathlib.Data.Set.Card</a></dd></dl></div><div id="Lean.Parser.Tactic.trace"><h2>trace</h2><p><p>Evaluates a term to a string (when possible), and prints it as a trace message.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Trace.html#Lean.Parser.Tactic.trace">Mathlib.Tactic.Trace</a></dd></dl></div><div id="Mathlib.Tactic.tacticTry_this__"><h2>try_this</h2><p><p>Produces the text <code>Try this: &lt;tac&gt;</code> with the given tactic, and then executes it.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TryThis.html#Mathlib.Tactic.tacticTry_this__">Mathlib.Tactic.TryThis</a></dd></dl></div><div id="tacticType_check_"><h2>type_check</h2><p><p>Type check the given expression, and trace its type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TypeCheck.html#tacticType_check_">Mathlib.Tactic.TypeCheck</a></dd></dl></div><div id="Mathlib.Tactic.InteractiveUnfold.tacticUnfold?"><h2>unfold?</h2><p><p>Replace the selected expression with a definitional unfolding.</p><ul><li>After each unfolding, we apply <code>whnfCore</code> to simplify the expression.</li><li>Explicit natural number expressions are evaluated.</li><li>Unfolds of class projections of instances marked with <code>@[default_instance]</code> are not shown.
This is relevant for notational type classes like <code>+</code>: we don't want to suggest <code><a href="./Mathlib/Algebra/Order/Kleene.html#Add.add">Add.add</a> a b</code>
as an unfolding of <code>a + b</code>. Similarly for <code>OfNat n : Nat</code> which unfolds into <code>n : Nat</code>.</li></ul><p>To use <code>unfold?</code>, shift-click an expression in the tactic state.
This gives a list of rewrite suggestions for the selected expression.
Click on a suggestion to replace <code>unfold?</code> by a tactic that performs this rewrite.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/InteractiveUnfold.html#Mathlib.Tactic.InteractiveUnfold.tacticUnfold?">Mathlib.Tactic.Widget.InteractiveUnfold</a></dd></dl></div><div id="Mathlib.Tactic.unfoldProjsStx"><h2>unfold_projs</h2><p><p><code>unfold_projs at loc</code> unfolds projections of class instances at the given location.
This also exists as a <code>conv</code>-mode tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="intervalIntegral.tacticUniqueDiffWithinAt_Ici_Iic_univ"><h2>uniqueDiffWithinAt_Ici_Iic_univ</h2><p><p>An auxiliary tactic closing goals <code><a href="./Mathlib/Analysis/Calculus/TangentCone/Defs.html#UniqueDiffWithinAt">UniqueDiffWithinAt</a> ‚Ñù s a</code> where
<code>s ‚àà {Iic a, Ici a, univ}</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.html#intervalIntegral.tacticUniqueDiffWithinAt_Ici_Iic_univ">Mathlib.MeasureTheory.Integral.IntervalIntegral.FundThmCalculus</a></dd></dl></div><div id="Tactic.Interactive.tacticUnit_interval"><h2>unit_interval</h2><p><p>A tactic that solves <code>0 ‚â§ ‚Üëx</code>, <code>0 ‚â§ 1 - ‚Üëx</code>, <code>‚Üëx ‚â§ 1</code>, and <code>1 - ‚Üëx ‚â§ 1</code> for <code>x : I</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Topology/UnitInterval.html#Tactic.Interactive.tacticUnit_interval">Mathlib.Topology.UnitInterval</a></dd></dl></div><div id="Mathlib.Tactic.useSyntax"><h2>use</h2><p><p><code>use e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> instantiates all existential quantifiers in the main goal by using <code>e‚ÇÅ</code>, <code>e‚ÇÇ</code>, ...
as witnesses, creates goals for all the remaining witnesses, and tries to discharge these goals
automatically.</p><p><code>use</code> is similar to <code>exists</code> or <code>existsi</code>, but unlike <code>exists</code> it is equivalent to applying the
tactic <code>refine ‚ü®e‚ÇÅ, e‚ÇÇ, ‚ãØ, ?_, ‚ãØ, ?_‚ü©</code> with any number of placeholders (rather than just one) and
then trying to close goals associated to the placeholders with a configurable discharger (rather
than just <code>try trivial</code>).</p><ul><li><code>use! e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> applies constructors everywhere rather than just for goals that correspond to the
last argument of a constructor. This gives the effect that nested constructors are being flattened
out, with the supplied values being used along the leaves and nodes of the tree of constructors.</li><li><code>use (discharger := tac) e‚ÇÅ, e‚ÇÇ, ...</code> calls <code>tac</code> as a discharger, on all remaining <code>Prop</code>-valued
goals. If this option is omitted, <code>use</code> calls <code>try with_reducible use_discharger</code> as default
discharger.
To turn off the discharger and keep all goals, use <code>(discharger := skip)</code>.
To allow &quot;heavy refls&quot;, use <code>(discharger := try use_discharger)</code>.
If <code>tac</code> fails on the new goal, <code>use (discharger := tac)</code> fails (hint: you might want to use
<code>(discharger := try tac)</code> instead).</li></ul><p>Examples:</p><pre><code class="language-lean">example : ‚àÉ x : Nat, x = x := by use 42

example : ‚àÉ x : Nat, ‚àÉ y : Nat, x = y := by use 42, 42

example : Nonempty Nat := by use 5

example : Nonempty (PNat ‚âÉ Nat) := by
  use PNat.natPred, <a href="./Mathlib/Data/PNat/Defs.html#Nat.succPNat">Nat.succPNat</a>
  ¬∑ exact <a href="./Mathlib/Data/PNat/Defs.html#PNat.succPNat_natPred">PNat.succPNat_natPred</a>
  ¬∑ intro; rfl

-- With `use!` one can feed in each `42` one at a time:
example : ‚àÉ n : {n : Nat // n % 2 = 0}, n.val &gt; 10 := by use! 20; simp

example : ‚àÉ p : Nat √ó Nat, p.1 = p.2 := by use! (42, 42)
/-
The second line makes use of the fact that `use!` tries refining with the argument before
applying a constructor. Also note that `use`/`use!` by default uses a tactic
called `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since
`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.
-/
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Use.html#Mathlib.Tactic.useSyntax">Mathlib.Tactic.Use</a></dd></dl></div><div id="Mathlib.Tactic.tacticUse_discharger"><h2>use_discharger</h2><p><p><code>use_discharger</code> is used by <code>use</code> to discharge side goals.</p><p>This is an extensible tactic using <code>macro_rules</code>. By default it can:</p><ul><li>rewrite a goal <code>‚àÉ _ : p, q</code> into <code>p ‚àß q</code> if <code>p</code> is in Prop;</li><li>solve the goal <code>p ‚àß q</code> by creating subgoals <code>p</code> and <code>q</code>;</li><li>apply <code>rfl</code>;</li><li>solve a goal by applying an assumption;</li><li>solve the goal <code>True</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Use.html#Mathlib.Tactic.tacticUse_discharger">Mathlib.Tactic.Use</a></dd></dl></div><div id="tacticUse_finite_instance"><h2>use_finite_instance</h2><p><p>Try using <code><a href="./Mathlib/Data/Finite/Defs.html#Set.toFinite">Set.toFinite</a></code> to dispatch a <code><a href="./Mathlib/Data/Finite/Defs.html#Set.Finite">Set.Finite</a></code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/LinearAlgebra/Dual/Basis.html#tacticUse_finite_instance">Mathlib.LinearAlgebra.Dual.Basis</a></dd></dl></div><div id="CategoryTheory.ComposableArrows.tacticValid"><h2>valid</h2><p><p>A wrapper for <code>omega</code> which prefaces it with some quick and useful attempts</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/CategoryTheory/ComposableArrows/Basic.html#CategoryTheory.ComposableArrows.tacticValid">Mathlib.CategoryTheory.ComposableArrows.Basic</a></dd></dl></div><div id="MeasureTheory.tacticVolume_tac"><h2>volume_tac</h2><p><p>The tactic <code>exact volume</code>, to be used in optional (<code>autoParam</code>) arguments.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/MeasureTheory/Measure/MeasureSpaceDef.html#MeasureTheory.tacticVolume_tac">Mathlib.MeasureTheory.Measure.MeasureSpaceDef</a></dd></dl></div><div id="Mathlib.Tactic.BicategoryCoherence.whisker_simps"><h2>whisker_simps</h2><p><p>Simp lemmas for rewriting a 2-morphism into a normal form.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CategoryTheory/BicategoryCoherence.html#Mathlib.Tactic.BicategoryCoherence.whisker_simps">Mathlib.Tactic.CategoryTheory.BicategoryCoherence</a></dd></dl></div><div id="Mathlib.Tactic.tacticWhnf__"><h2>whnf</h2><p><p><code>whnf at loc</code> puts the given location into weak-head normal form.
This also exists as a <code>conv</code>-mode tactic.</p><p>Weak-head normal form is when the outer-most expression has been fully reduced, the expression
may contain subexpressions which have not been reduced.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="witt_truncateFun_tac"><h2>witt_truncateFun_tac</h2><p><p>A macro tactic used to prove that <code>truncateFun</code> respects ring operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/RingTheory/WittVector/Truncated.html#witt_truncateFun_tac">Mathlib.RingTheory.WittVector.Truncated</a></dd></dl></div><div id="Mathlib.Tactic.wlog"><h2>wlog</h2><p><p><code>wlog h : P</code> adds an assumption <code>h : P</code> to the main goal, and adds a side goal that
requires showing that the case <code>h : ¬¨ P</code> can be reduced to the case where <code>P</code> holds
(typically by symmetry). The side goal will be at the top of the stack. In this side goal,
there will be two additional assumptions:</p><ul><li><code>h : ¬¨ P</code>: the assumption that <code>P</code> does not hold</li><li><code>this</code>: which is the statement that in the old context <code>P</code> suffices to prove the goal.
By default, the entire context is reverted to produce <code>this</code>.</li></ul><ul><li><code>wlog h : P with H</code> gives the name <code>H</code> to the statement that <code>P</code> proves the goal.</li><li><code>wlog h : P generalizing x y ...</code> reverts certain parts of the context before creating the new
goal. In this way, the wlog-claim <code>this</code> can be applied to <code>x</code> and <code>y</code> in different orders
(exploiting symmetry, which is the typical use case).</li><li><code>wlog! h : P</code> also calls <code>push_neg</code> at the generated hypothesis <code>h</code>.
<code>wlog! h : P ‚àß Q</code> will transform <code>¬¨ (P ‚àß Q)</code> to <code>P ‚Üí ¬¨ Q</code></li><li><code>wlog! +distrib h : P</code> also calls <code>push_neg +distrib</code> at the generated hypothesis <code>h</code>.
<code>wlog! +distrib h : P ‚àß Q</code> will transform <code>¬¨ (P ‚àß Q)</code> to <code>¬¨P ‚à® ¬¨Q</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog">Mathlib.Tactic.WLOG</a></dd></dl></div><div id="Mathlib.Tactic.Zify.zify"><h2>zify</h2><p><p>The <code>zify</code> tactic is used to shift propositions from <code>Nat</code> to <code>Int</code>.
This is often useful since <code>Int</code> has well-behaved subtraction.</p><pre><code>example (a b c x y z : Nat) (h : ¬¨ x*y*z &lt; 0) : c &lt; a + 3*b := by
  zify
  zify at h
  /-
  h : ¬¨‚Üëx * ‚Üëy * ‚Üëz &lt; 0
  ‚ä¢ ‚Üëc &lt; ‚Üëa + 3 * ‚Üëb
  -/
</code></pre><p><code>zify</code> can be given extra lemmas to use in simplification. This is especially useful in the
presence of nat subtraction: passing <code>‚â§</code> arguments will allow <code>push_cast</code> to do more work.</p><pre><code>example (a b c : Nat) (h : a - b &lt; c) (hab : b ‚â§ a) : false := by
  zify [hab] at h
  /- h : ‚Üëa - ‚Üëb &lt; ‚Üëc -/
</code></pre><p><code>zify</code> makes use of the <code>@[zify_simps]</code> attribute to move propositions,
and the <code>push_cast</code> tactic to simplify the <code>Int</code>-valued expressions.
<code>zify</code> is in some sense dual to the <code>lift</code> tactic.
<code>lift (z : Int) to Nat</code> will change the type of an
integer <code>z</code> (in the supertype) to <code>Nat</code> (the subtype), given a proof that <code>z ‚â• 0</code>;
propositions concerning <code>z</code> will still be over <code>Int</code>.
<code>zify</code> changes propositions about <code>Nat</code> (the subtype) to propositions about <code>Int</code> (the supertype),
without changing the type of any variable.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.zify">Mathlib.Tactic.Zify</a></dd></dl></div></main>
<nav class="nav"><iframe src="./navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>