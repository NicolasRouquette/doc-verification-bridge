<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Util.AtomM</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Util.AtomM";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Util</span>.<span class="name">AtomM</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Qq.html">Qq</a></li><li><a href="../.././Mathlib/Init.html">Mathlib.Init</a></li><li><a href="../.././Qq/Typ.html">Qq.Typ</a></li><li><a href="../.././Lean/Meta/Tactic/Simp/Types.html">Lean.Meta.Tactic.Simp.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Util.AtomM" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.instInhabitedContext.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">instInhabitedContext</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.instInhabitedContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">instInhabitedContext</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.State"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.run"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.isDefEqSafe"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">isDefEqSafe</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.containsThenAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">containsThenAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.containsThenAddQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">containsThenAddQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.addAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">addAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.AtomM.addAtomQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">addAtomQ</span></a></div></nav><main>
<div class="mod_doc"><h1 id="A-monad-for-tracking-and-deduplicating-atoms" class="markdown-heading">A monad for tracking and deduplicating atoms <a class="hover-link" href="#A-monad-for-tracking-and-deduplicating-atoms">#</a></h1><p>This monad is used by tactics like <code>ring</code> and <code>abel</code> to keep uninterpreted atoms in a consistent
order, and also to allow unifying atoms up to a specified transparency mode.</p><p>Note: this can become very expensive because it is using <code>isDefEq</code>.
For performance reasons, consider whether <code>Lean.Meta.Canonicalizer.canon</code> can be used instead.
After canonicalizing, a <code>HashMap Expr Nat</code> suffices to keep track of previously seen atoms,
and is much faster as it uses <code>Expr</code> equality rather than <code>isDefEq</code>.</p></div><div class="decl" id="Mathlib.Tactic.AtomM.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L30-L37">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.Context" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The context (read-only state) of the <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a></code> monad.</p><ul class="structure_fields" id="Mathlib.Tactic.AtomM.Context.mk"><li id="Mathlib.Tactic.AtomM.Context.red" class="structure_field"><div class="structure_field_info">red : <span class="fn">Lean.Meta.TransparencyMode</span></div><div class="structure_field_doc"><p>The reducibility setting for definitional equality of atoms</p></div></li><li id="Mathlib.Tactic.AtomM.Context.evalAtom" class="structure_field"><div class="structure_field_info">evalAtom : <span class="fn"><span class="fn">Lean.Expr</span> â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Meta.Simp.Result</span></span></span></div><div class="structure_field_doc"><p>A simplification to apply to atomic expressions when they are encountered,
before interning them in the atom list.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.AtomM.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.instInhabitedContext.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L37-L37">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext.default" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">instInhabitedContext</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context">Context</a></div></div><details id="instances-for-list-Mathlib.Tactic.AtomM.instInhabitedContext.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.instInhabitedContext"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L37-L37">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">instInhabitedContext</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context">Context</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.AtomM.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L39-L42">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.State" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The mutable state of the <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a></code> monad.</p><ul class="structure_fields" id="Mathlib.Tactic.AtomM.State.mk"><li id="Mathlib.Tactic.AtomM.State.atoms" class="structure_field"><div class="structure_field_info">atoms : <span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Expr</span></span></div><div class="structure_field_doc"><p>The list of atoms-up-to-defeq encountered thus far, used for atom sorting.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.AtomM.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L44-L45">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The monad that <code>ring</code> works in. This is only used for collecting atoms.</p><details id="instances-for-list-Mathlib.Tactic.AtomM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L47-L51">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.run" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.run"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">red</span> : <span class="fn">Lean.Meta.TransparencyMode</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">Î±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">evalAtom</span> : <span class="fn"><span class="fn">Lean.Expr</span> â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Meta.Simp.Result</span></span></span> := <span class="fn">fun (<span class="fn">e</span> : <span class="fn">Lean.Expr</span>) =&gt; <span class="fn"><span class="fn">pure</span> <span class="fn"><span class="fn">{</span> <span class="fn">expr</span> := <span class="fn">e</span> <span class="fn">}</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Î±</span></span></div></div><p>Run a computation in the <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a></code> monad.</p><details id="instances-for-list-Mathlib.Tactic.AtomM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.isDefEqSafe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L53-L59">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.isDefEqSafe" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.isDefEqSafe"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">isDefEqSafe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Bool</span></span></div></div><p>A safe version of <code>isDefEq</code> that doesn't throw errors. We use it to avoid
&quot;unknown free variable '_fvar.102937'&quot; errors when there may be out-of-scope free variables.</p><p>TODO: don't catch any other errors</p><details id="instances-for-list-Mathlib.Tactic.isDefEqSafe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.containsThenAdd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L61-L74">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.containsThenAdd" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.containsThenAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">containsThenAdd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<span class="fn">Bool</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span></div></div><p>If an atomic expression has already been encountered, return <code>true</code>, the index and the stored
form of the atom (which will be defeq at the specified transparency, but not necessarily
syntactically equal). If the atomic expression has <em>not</em> already been encountered, store it in the
list of atoms, and return the new index (and the stored form of the atom, which will be itself).</p><p>In a normalizing tactic, the expression returned by <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.containsThenAdd">containsThenAdd</a></code> should be considered
the normal form.</p><details id="instances-for-list-Mathlib.Tactic.AtomM.containsThenAdd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.containsThenAddQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L77-L90">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.containsThenAddQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.containsThenAddQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">containsThenAddQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$Î±Â»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<span class="fn">Bool</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">{</span> <span class="fn">e'</span> <span class="fn">:</span> <span class="fn">Q(<span class="fn">Â«$Î±Â»</span>)</span> <span class="fn">//</span> <span class="fn"><span class="fn">Â«$eÂ»</span> =Q <span class="fn">Â«$e'Â»</span></span> <span class="fn">}</span></span></span>)</span></span></div></div><p>If an atomic expression has already been encountered, return <code>true</code>, the index and the stored
form of the atom (which will be defeq at the specified transparency, but not necessarily
syntactically equal). If the atomic expression has <em>not</em> already been encountered, store it in the
list of atoms, and return the new index (and the stored form of the atom, which will be itself).</p><p>In a normalizing tactic, the expression returned by <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.containsThenAddQ">AtomM.containsThenAddQ</a></code> should be considered
the normal form.</p><p>This is a strongly-typed version of <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.containsThenAdd">AtomM.containsThenAdd</a></code> for code using <code>Qq</code>.</p><details id="instances-for-list-Mathlib.Tactic.AtomM.containsThenAddQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.addAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L92-L100">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.addAtom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">addAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>If an atomic expression has already been encountered, get the index and the stored form of the
atom (which will be defeq at the specified transparency, but not necessarily syntactically equal).
If the atomic expression has <em>not</em> already been encountered, store it in the list of atoms, and
return the new index (and the stored form of the atom, which will be itself).</p><p>In a normalizing tactic, the expression returned by <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom">addAtom</a></code> should be considered the normal form.</p><details id="instances-for-list-Mathlib.Tactic.AtomM.addAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.AtomM.addAtomQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Util/AtomM.lean#L103-L115">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Util_AtomM.html#Mathlib.Tactic.AtomM.addAtomQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtomQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">AtomM</span>.<span class="name">addAtomQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$Î±Â»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">{</span> <span class="fn">e'</span> <span class="fn">:</span> <span class="fn">Q(<span class="fn">Â«$Î±Â»</span>)</span> <span class="fn">//</span> <span class="fn"><span class="fn">Â«$eÂ»</span> =Q <span class="fn">Â«$e'Â»</span></span> <span class="fn">}</span></span>)</span></span></div></div><p>If an atomic expression has already been encountered, get the index and the stored form of the
atom (which will be defeq at the specified transparency, but not necessarily syntactically equal).
If the atomic expression has <em>not</em> already been encountered, store it in the list of atoms, and
return the new index (and the stored form of the atom, which will be itself).</p><p>In a normalizing tactic, the expression returned by <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtomQ">addAtomQ</a></code> should be considered the normal form.</p><p>This is a strongly-typed version of <code><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom">AtomM.addAtom</a></code> for code using <code>Qq</code>.</p><details id="instances-for-list-Mathlib.Tactic.AtomM.addAtomQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>