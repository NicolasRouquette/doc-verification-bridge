<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.Nat.Init</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.Nat.Init";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">Nat</span>.<span class="name">Init</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Init.html">Mathlib.Init</a></li><li><a href="../../.././Batteries/Tactic/Alias.html">Batteries.Tactic.Alias</a></li><li><a href="../../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../../.././Mathlib/Tactic/Lemma.html">Mathlib.Tactic.Lemma</a></li><li><a href="../../.././Mathlib/Tactic/TypeStar.html">Mathlib.Tactic.TypeStar</a></li><li><a href="../../.././Mathlib/Data/Int/Notation.html">Mathlib.Data.Int.Notation</a></li><li><a href="../../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.Nat.Init" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#LibraryNote.foundational_algebra_order_theory"><span class="name">LibraryNote</span>.<span class="name">foundational_algebra_order_theory</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_pos'"><span class="name">Nat</span>.<span class="name">succ_pos'</span></a></div><div class="nav_link"><a class="break_within" href="#LT.lt.nat_succ_le"><span class="name">LT</span>.<span class="name">lt</span>.<span class="name">nat_succ_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.of_le_succ"><span class="name">Nat</span>.<span class="name">of_le_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.forall_lt_succ"><span class="name">Nat</span>.<span class="name">forall_lt_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.two_lt_of_ne"><span class="name">Nat</span>.<span class="name">two_lt_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.two_le_iff"><span class="name">Nat</span>.<span class="name">two_le_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.mul_def"><span class="name">Nat</span>.<span class="name">mul_def</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.two_mul_ne_two_mul_add_one"><span class="name">Nat</span>.<span class="name">two_mul_ne_two_mul_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_div_two_iff_mul_two_le"><span class="name">Nat</span>.<span class="name">le_div_two_iff_mul_two_le</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.div_lt_self'"><span class="name">Nat</span>.<span class="name">div_lt_self'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.two_mul_odd_div_two"><span class="name">Nat</span>.<span class="name">two_mul_odd_div_two</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.one_le_pow'"><span class="name">Nat</span>.<span class="name">one_le_pow'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.sq_sub_sq"><span class="name">Nat</span>.<span class="name">sq_sub_sq</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.rec_zero"><span class="name">Nat</span>.<span class="name">rec_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.rec_add_one"><span class="name">Nat</span>.<span class="name">rec_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.rec_one"><span class="name">Nat</span>.<span class="name">rec_one</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec"><span class="name">Nat</span>.<span class="name">leRec</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_eq_leRec"><span class="name">Nat</span>.<span class="name">leRec_eq_leRec</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_self"><span class="name">Nat</span>.<span class="name">leRec_self</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_succ"><span class="name">Nat</span>.<span class="name">leRec_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_succ'"><span class="name">Nat</span>.<span class="name">leRec_succ'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_trans"><span class="name">Nat</span>.<span class="name">leRec_trans</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRec_succ_left"><span class="name">Nat</span>.<span class="name">leRec_succ_left</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn"><span class="name">Nat</span>.<span class="name">leRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn_self"><span class="name">Nat</span>.<span class="name">leRecOn_self</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn_succ"><span class="name">Nat</span>.<span class="name">leRecOn_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn_succ'"><span class="name">Nat</span>.<span class="name">leRecOn_succ'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn_trans"><span class="name">Nat</span>.<span class="name">leRecOn_trans</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.leRecOn_succ_left"><span class="name">Nat</span>.<span class="name">leRecOn_succ_left</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strongRec'"><span class="name">Nat</span>.<span class="name">strongRec'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strongRec'_spec"><span class="name">Nat</span>.<span class="name">strongRec'_spec</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strongRecOn'"><span class="name">Nat</span>.<span class="name">strongRecOn'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strongRecOn'_beta"><span class="name">Nat</span>.<span class="name">strongRecOn'_beta</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.le_induction"><span class="name">Nat</span>.<span class="name">le_induction</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.twoStepInduction"><span class="name">Nat</span>.<span class="name">twoStepInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strong_induction_on"><span class="name">Nat</span>.<span class="name">strong_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.case_strong_induction_on"><span class="name">Nat</span>.<span class="name">case_strong_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction"><span class="name">Nat</span>.<span class="name">decreasingInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction_self"><span class="name">Nat</span>.<span class="name">decreasingInduction_self</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction_succ"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction_succ'"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction_trans"><span class="name">Nat</span>.<span class="name">decreasingInduction_trans</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction_succ_left"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ_left</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.strongSubRecursion"><span class="name">Nat</span>.<span class="name">strongSubRecursion</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.pincerRecursion"><span class="name">Nat</span>.<span class="name">pincerRecursion</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decreasingInduction'"><span class="name">Nat</span>.<span class="name">decreasingInduction'</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.diag_induction"><span class="name">Nat</span>.<span class="name">diag_induction</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_pos_pow_dvd"><span class="name">Nat</span>.<span class="name">not_pos_pow_dvd</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.not_two_dvd_bit1"><span class="name">Nat</span>.<span class="name">not_two_dvd_bit1</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.dvd_add_self_left"><span class="name">Nat</span>.<span class="name">dvd_add_self_left</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.dvd_add_self_right"><span class="name">Nat</span>.<span class="name">dvd_add_self_right</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.dvd_right_iff_eq"><span class="name">Nat</span>.<span class="name">dvd_right_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.dvd_left_iff_eq"><span class="name">Nat</span>.<span class="name">dvd_left_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decidableLoHi"><span class="name">Nat</span>.<span class="name">decidableLoHi</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.decidableLoHiLe"><span class="name">Nat</span>.<span class="name">decidableLoHiLe</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.instNeZeroNatAbsOfInt_mathlib"><span class="name">Nat</span>.<span class="name">instNeZeroNatAbsOfInt_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.AtLeastTwo"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.instAtLeastTwoHAddOfNat"><span class="name">Nat</span>.<span class="name">instAtLeastTwoHAddOfNat</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.AtLeastTwo.one_lt"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">one_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.AtLeastTwo.ne_one"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">ne_one</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.AtLeastTwo.toNeZero"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">toNeZero</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.AtLeastTwo.neZero_sub_one"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">neZero_sub_one</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Basic-operations-on-the-natural-numbers" class="markdown-heading">Basic operations on the natural numbers <a class="hover-link" href="#Basic-operations-on-the-natural-numbers">#</a></h1><p>This file contains:</p><ul><li>some basic lemmas about natural numbers</li><li>extra recursors:<ul><li><code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a></code>, <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.le_induction">le_induction</a></code>: recursion and induction principles starting at non-zero numbers</li><li><code>decreasing_induction</code>: recursion growing downwards</li><li><code>le_rec_on'</code>, <code>decreasing_induction'</code>: versions with slightly weaker assumptions</li><li><code>strong_rec'</code>: recursion based on strong inequalities</li></ul></li><li>decidability instances on predicates about the natural numbers</li></ul><p>This file should not depend on anything defined in Mathlib (except for notation), so that it can be
upstreamed to Batteries or the Lean standard library easily.</p><p>See note [foundational algebra order theory].</p></div><div class="decl" id="LibraryNote.foundational_algebra_order_theory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L36-L55">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#LibraryNote.foundational_algebra_order_theory" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#LibraryNote.foundational_algebra_order_theory"><span class="name">LibraryNote</span>.<span class="name">foundational_algebra_order_theory</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Batteries.Util.LibraryNote</span></div></div><p>Batteries has a home-baked development of the algebraic and order-theoretic theory of <code>‚Ñï</code> and <code>‚Ñ§</code>
which, in particular, is not typeclass-mediated. This is useful to set up the algebra and finiteness
libraries in mathlib (naturals and integers show up as indices/offsets in lists, cardinality in
finsets, powers in groups, ...).</p><p>Less basic uses of <code>‚Ñï</code> and <code>‚Ñ§</code> should however use the typeclass-mediated development.</p><p>The relevant files are:</p><ul><li><code><a href="../../.././Mathlib/Data/Nat/Basic.html">Mathlib/Data/Nat/Basic.lean</a></code> for the continuation of the home-baked development on <code>‚Ñï</code></li><li><code><a href="../../.././Mathlib/Data/Int/Init.html">Mathlib/Data/Int/Init.lean</a></code> for the continuation of the home-baked development on <code>‚Ñ§</code></li><li><code><a href="../../.././Mathlib/Algebra/Group/Nat/Defs.html">Mathlib/Algebra/Group/Nat/Defs.lean</a></code> for the monoid instances on <code>‚Ñï</code></li><li><code><a href="../../.././Mathlib/Algebra/Group/Int/Defs.html">Mathlib/Algebra/Group/Int/Defs.lean</a></code> for the group instance on <code>‚Ñ§</code></li><li><code><a href="../../.././Mathlib/Algebra/Ring/Nat.html">Mathlib/Algebra/Ring/Nat.lean</a></code> for the semiring instance on <code>‚Ñï</code></li><li><code><a href="../../.././Mathlib/Algebra/Ring/Int/Defs.html">Mathlib/Algebra/Ring/Int/Defs.lean</a></code> for the ring instance on <code>‚Ñ§</code></li><li><code><a href="../../.././Mathlib/Algebra/Order/Group/Nat.html">Mathlib/Algebra/Order/Group/Nat.lean</a></code> for the ordered monoid instance on <code>‚Ñï</code></li><li><code><a href="../../.././Mathlib/Algebra/Order/Group/Int.html">Mathlib/Algebra/Order/Group/Int.lean</a></code> for the ordered group instance on <code>‚Ñ§</code></li><li><code><a href="../../.././Mathlib/Algebra/Order/Ring/Nat.html">Mathlib/Algebra/Order/Ring/Nat.lean</a></code> for the ordered semiring instance on <code>‚Ñï</code></li><li><code><a href="../../.././Mathlib/Algebra/Order/Ring/Int.html">Mathlib/Algebra/Order/Ring/Int.lean</a></code> for the ordered ring instance on <code>‚Ñ§</code></li></ul><details id="instances-for-list-LibraryNote.foundational_algebra_order_theory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="succ-pred" class="markdown-heading"><code>succ</code>, <code>pred</code> <a class="hover-link" href="#succ-pred">#</a></h3></div><div class="decl" id="Nat.succ_pos'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L67-L67">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.succ_pos'"><span class="name">Nat</span>.<span class="name">succ_pos'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<span class="fn">succ</span></span></div></div></div></div><div class="decl" id="LT.lt.nat_succ_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L69-L69">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#LT.lt.nat_succ_le"><span class="name">LT</span>.<span class="name">lt</span>.<span class="name">nat_succ_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span>.<span class="fn">succ</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span></div></div><p><strong>Alias</strong> of <code>Nat.succ_le_of_lt</code>.</p></div></div><div class="decl" id="Nat.of_le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L71-L71">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.of_le_succ"><span class="name">Nat</span>.<span class="name">of_le_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span>.<span class="fn">succ</span></span> ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> <span class="fn">‚à®</span> <span class="fn"><span class="fn">m</span> <span class="fn">=</span> <span class="fn"><span class="fn">n</span>.<span class="fn">succ</span></span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code>Nat.le_succ_iff</code>.</p></div></div><div class="decl" id="Nat.forall_lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L73-L73">source</a></div><div class="attributes">@[deprecated Nat.forall_lt_succ_right (since := &quot;2025-08-21&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.forall_lt_succ"><span class="name">Nat</span>.<span class="name">forall_lt_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ <span class="fn">m</span> &lt; <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span>, <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">(‚àÄ <span class="fn">m</span> &lt; <span class="fn">n</span>, <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span>)</span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></span></span></div></div><p><strong>Alias</strong> of <code>Nat.forall_lt_succ_right</code>.</p></div></div><div class="decl" id="Nat.two_lt_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L75-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.two_lt_of_ne"><span class="name">Nat</span>.<span class="name">two_lt_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">0</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">1</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">2</span></span> ‚Üí <span class="fn">2</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span></span></span></span></div></div></div></div><div class="decl" id="Nat.two_le_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L81-L84">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.two_le_iff"><span class="name">Nat</span>.<span class="name">two_le_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">2</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">0</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">1</span></span></span></span></div></div></div></div><div class="mod_doc"><h3 id="add" class="markdown-heading"><code>add</code> <a class="hover-link" href="#add">#</a></h3></div><div class="mod_doc"><h3 id="sub" class="markdown-heading"><code>sub</code> <a class="hover-link" href="#sub">#</a></h3></div><div class="mod_doc"><h3 id="mul" class="markdown-heading"><code>mul</code> <a class="hover-link" href="#mul">#</a></h3></div><div class="decl" id="Nat.mul_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L92-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.mul_def"><span class="name">Nat</span>.<span class="name">mul_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.<span class="fn">mul</span></span> <span class="fn">n</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">m</span> <span class="fn">*</span> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.two_mul_ne_two_mul_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L94-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.two_mul_ne_two_mul_add_one"><span class="name">Nat</span>.<span class="name">two_mul_ne_two_mul_add_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">2</span> <span class="fn">*</span> <span class="fn">n</span></span> <span class="fn">‚â†</span> <span class="fn"><span class="fn"><span class="fn">2</span> <span class="fn">*</span> <span class="fn">m</span></span> <span class="fn">+</span> <span class="fn">1</span></span></span></div></div></div></div><div class="mod_doc"><h3 id="div" class="markdown-heading"><code>div</code> <a class="hover-link" href="#div">#</a></h3></div><div class="decl" id="Nat.le_div_two_iff_mul_two_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L100-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.le_div_two_iff_mul_two_le"><span class="name">Nat</span>.<span class="name">le_div_two_iff_mul_two_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span> <span class="fn">/</span> <span class="fn">2</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">‚Üë<span class="fn">m</span></span> <span class="fn">*</span> <span class="fn">2</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">‚Üë<span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.div_lt_self'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L103-L105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.div_lt_self'"><span class="name">Nat</span>.<span class="name">div_lt_self'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">/</span> <span class="fn">(<span class="fn">b</span> <span class="fn">+</span> <span class="fn">2</span>)</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span></span></div></div><p>A version of <code>Nat.<a href="../../.././Mathlib/Algebra/Order/Field/Basic.html#div_lt_self">div_lt_self</a></code> using successors, rather than additional hypotheses.</p></div></div><div class="decl" id="Nat.two_mul_odd_div_two"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L107-L108">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.two_mul_odd_div_two"><span class="name">Nat</span>.<span class="name">two_mul_odd_div_two</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">%</span> <span class="fn">2</span></span> <span class="fn">=</span> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">2</span> <span class="fn">*</span> <span class="fn">(<span class="fn">n</span> <span class="fn">/</span> <span class="fn">2</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">n</span> <span class="fn">-</span> <span class="fn">1</span></span></span></div></div></div></div><div class="mod_doc"><h3 id="pow" class="markdown-heading"><code>pow</code> <a class="hover-link" href="#pow">#</a></h3></div><div class="decl" id="Nat.one_le_pow'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L112-L112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.one_le_pow'"><span class="name">Nat</span>.<span class="name">one_le_pow'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">(<span class="fn">m</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">^</span> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.sq_sub_sq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L114-L114">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.sq_sub_sq"><span class="name">Nat</span>.<span class="name">sq_sub_sq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">^</span> <span class="fn">2</span></span> <span class="fn">-</span> <span class="fn"><span class="fn">b</span> <span class="fn">^</span> <span class="fn">2</span></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">b</span>)</span> <span class="fn">*</span> <span class="fn">(<span class="fn">a</span> <span class="fn">-</span> <span class="fn">b</span>)</span></span></span></div></div><p><strong>Alias</strong> of <code>Nat.<a href="../../.././Mathlib/Algebra/Ring/Commute.html#pow_two_sub_pow_two">pow_two_sub_pow_two</a></code>.</p></div></div><div class="mod_doc"><h3 id="Recursion-and-induction-principles" class="markdown-heading">Recursion and induction principles <a class="hover-link" href="#Recursion-and-induction-principles">#</a></h3><p>This section is here due to dependencies -- the lemmas here require some of the lemmas
proved above, and some of the results in later sections depend on the definitions in this section.</p></div><div class="decl" id="Nat.rec_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L123-L124">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.rec_zero"><span class="name">Nat</span>.<span class="name">rec_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h0</span> : <span class="fn"><span class="fn">C</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">n</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">rec</span> <span class="fn">h0</span> <span class="fn">h</span> <span class="fn">0</span></span> <span class="fn">=</span> <span class="fn">h0</span></span></div></div></div></div><div class="decl" id="Nat.rec_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L127-L128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.rec_add_one"><span class="name">Nat</span>.<span class="name">rec_add_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h0</span> : <span class="fn"><span class="fn">C</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">n</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">rec</span> <span class="fn">h0</span> <span class="fn">h</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">h</span> <span class="fn">n</span> <span class="fn">(<span class="fn">rec</span> <span class="fn">h0</span> <span class="fn">h</span> <span class="fn">n</span>)</span></span></span></div></div></div></div><div class="decl" id="Nat.rec_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L130-L131">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.rec_one"><span class="name">Nat</span>.<span class="name">rec_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h0</span> : <span class="fn"><span class="fn">C</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">n</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">rec</span> <span class="fn">h0</span> <span class="fn">h</span> <span class="fn">1</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">h</span> <span class="fn">0</span> <span class="fn">h0</span></span></span></div></div></div></div><div class="decl" id="Nat.leRec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L133-L153">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec"><span class="name">Nat</span>.<span class="name">leRec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">m</span> <span class="fn">h</span></span></div></div><p>Recursion starting at a non-zero number: given a map <code>C k ‚Üí C (k+1)</code> for each <code>k ‚â• n</code>,
there is a map from <code>C n</code> to each <code>C m</code>, <code>n ‚â§ m</code>.</p><p>This is a version of <code>Nat.le.rec</code> that works for <code>Sort u</code>.
Similarly to <code>Nat.le.rec</code>, it can be used as</p><pre><code>induction hle using <a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">Nat.leRec</a> with
| <a href="../../.././Mathlib/Order/Defs/Unbundled.html#refl">refl</a> =&gt; sorry
| le_succ_of_le hle ih =&gt; sorry
</code></pre><details id="instances-for-list-Nat.leRec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.leRec_eq_leRec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L157-L157">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_eq_leRec" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_eq_leRec"><span class="name">Nat</span>.<span class="name">leRec_eq_leRec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">@<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">=</span> <span class="fn">@<span class="fn">le.rec</span></span></span></div></div></div></div><div class="decl" id="Nat.leRec_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L159-L165">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_self" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_self"><span class="name">Nat</span>.<span class="name">leRec_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn">refl</span></span></div></div></div></div><div class="decl" id="Nat.leRec_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L167-L176">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_succ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_succ"><span class="name">Nat</span>.<span class="name">leRec_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h2</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">m</span> <span class="fn">+</span> <span class="fn">1</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">h2</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">le_succ_of_le</span> <span class="fn">h1</span> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">h1</span>)</span></span></span></div></div></div></div><div class="decl" id="Nat.leRec_succ'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L178-L180">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_succ'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_succ'"><span class="name">Nat</span>.<span class="name">leRec_succ'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span> <span class="fn">refl</span></span></span></div></div></div></div><div class="decl" id="Nat.leRec_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L182-L190">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_trans"><span class="name">Nat</span>.<span class="name">leRec_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnm</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmk</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">‚Ñï</span>) (<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x</span>) =&gt; <span class="fn"><span class="fn">le_succ_of_le</span> <span class="fn">h</span></span>)</span> <span class="fn">hnm</span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">‚Ñï</span>) (<span class="fn">h</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x</span>) =&gt; <span class="fn"><span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span></span>)</span> <span class="fn">hmk</span></span></span></div></div></div></div><div class="decl" id="Nat.leRec_succ_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L192-L198">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRec_succ_left" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec_succ_left"><span class="name">Nat</span>.<span class="name">leRec_succ_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">le_succ_of_le</span> : <span class="fn">‚¶É<span class="fn">k</span> : <span class="fn">‚Ñï</span>‚¶Ñ ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">(<span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span> <span class="fn">refl</span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">‚Ñï</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x</span>) (<span class="fn">ih</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">x</span> <span class="fn">‚ãØ</span></span>) =&gt; <span class="fn"><span class="fn">le_succ_of_le</span> <span class="fn">‚ãØ</span> <span class="fn">ih</span></span>)</span> <span class="fn">h2</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">leRec</a> <span class="fn">refl</span> <span class="fn">le_succ_of_le</span> <span class="fn">h1</span></span></span></div></div></div></div><div class="decl" id="Nat.leRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L200-L205">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn"><span class="name">Nat</span>.<span class="name">leRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span> ‚Üí <span class="fn"><span class="fn">({<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span>)</span> ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">n</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">m</span></span></span></span></span></div></div><p>Recursion starting at a non-zero number: given a map <code>C k ‚Üí C (k + 1)</code> for each <code>k</code>,
there is a map from <code>C n</code> to each <code>C m</code>, <code>n ‚â§ m</code>. For a version where the assumption is only made
when <code>k ‚â• n</code>, see <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">Nat.leRec</a></code>.</p><details id="instances-for-list-Nat.leRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.leRecOn_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L207-L209">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn_self" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn_self"><span class="name">Nat</span>.<span class="name">leRecOn_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">next</span> : <span class="fn">{<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">‚ãØ</span> <span class="fn">(fun {<span class="fn">k</span> : <span class="fn">‚Ñï</span>} =&gt; <span class="fn">next</span>)</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Nat.leRecOn_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L211-L213">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn_succ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn_succ"><span class="name">Nat</span>.<span class="name">leRecOn_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h2</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">m</span> <span class="fn">+</span> <span class="fn">1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">next</span> : <span class="fn">{<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">h2</span> <span class="fn">next</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">next</span> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">h1</span> <span class="fn">(fun {<span class="fn">k</span> : <span class="fn">‚Ñï</span>} =&gt; <span class="fn">next</span>)</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Nat.leRecOn_succ'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L215-L217">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn_succ'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn_succ'"><span class="name">Nat</span>.<span class="name">leRecOn_succ'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">next</span> : <span class="fn">{<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">h</span> <span class="fn">(fun {<span class="fn">k</span> : <span class="fn">‚Ñï</span>} =&gt; <span class="fn">next</span>)</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">next</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Nat.leRecOn_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L219-L222">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn_trans"><span class="name">Nat</span>.<span class="name">leRecOn_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m </span><span class="fn">k</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hnm</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmk</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">next</span> : <span class="fn">{<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">‚ãØ</span> <span class="fn">next</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">hmk</span> <span class="fn">next</span> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">hnm</span> <span class="fn">next</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Nat.leRecOn_succ_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L224-L227">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.leRecOn_succ_left" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn_succ_left"><span class="name">Nat</span>.<span class="name">leRecOn_succ_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">next</span> : <span class="fn">{<span class="fn">k</span> : <span class="fn">‚Ñï</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">k</span></span> ‚Üí <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">m</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">h2</span> <span class="fn">(fun {<span class="fn">k</span> : <span class="fn">‚Ñï</span>} =&gt; <span class="fn">next</span>)</span> <span class="fn">(<span class="fn">next</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRecOn">leRecOn</a> <span class="fn">h1</span> <span class="fn">(fun {<span class="fn">k</span> : <span class="fn">‚Ñï</span>} =&gt; <span class="fn">next</span>)</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Nat.strongRec'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L238-L241">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.strongRec'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRec'"><span class="name">Nat</span>.<span class="name">strongRec'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">((<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span></span>)</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></div></div><p>Recursion principle based on <code>&lt;</code>.</p><details id="instances-for-list-Nat.strongRec'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.strongRec'_spec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L255-L257">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.strongRec'_spec" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRec'_spec"><span class="name">Nat</span>.<span class="name">strongRec'_spec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">((<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span></span>)</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRec'">Nat.strongRec'</a> <span class="fn">H</span> <span class="fn">n</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">H</span> <span class="fn">n</span> <span class="fn">fun (<span class="fn">m</span> : <span class="fn">‚Ñï</span>) (<span class="fn">x</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRec'">Nat.strongRec'</a> <span class="fn">H</span> <span class="fn">m</span></span></span></span></span></div></div></div></div><div class="decl" id="Nat.strongRecOn'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L259-L262">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.strongRecOn'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRecOn'"><span class="name">Nat</span>.<span class="name">strongRecOn'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">((<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">m</span></span></span>)</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">n</span></span></div></div><p>Recursion principle based on <code>&lt;</code> applied to some natural number.</p><details id="instances-for-list-Nat.strongRecOn'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.strongRecOn'_beta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L264-L266">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.strongRecOn'_beta" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRecOn'_beta"><span class="name">Nat</span>.<span class="name">strongRecOn'_beta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">((<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">m</span></span></span>)</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">n</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRecOn'">strongRecOn'</a></span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">h</span> <span class="fn">n</span> <span class="fn">fun (<span class="fn">m</span> : <span class="fn">‚Ñï</span>) (<span class="fn">x</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">m</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongRecOn'">strongRecOn'</a></span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="Nat.le_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L268-L276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.le_induction"><span class="name">Nat</span>.<span class="name">le_induction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">base</span> : <span class="fn"><span class="fn">P</span> <span class="fn">m</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">succ</span> : <span class="fn">‚àÄ (<span class="fn">n</span> : <span class="fn">‚Ñï</span>) (<span class="fn">hmn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">n</span> <span class="fn">hmn</span></span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">n</span> <span class="fn">hmn</span></span></div></div><p>Induction principle starting at a non-zero number.
To use in an induction proof, the syntax is <code>induction n, hn using <a href="../../.././Mathlib/Data/Nat/Init.html#Nat.le_induction">Nat.le_induction</a></code> (or the same
for <code>induction'</code>).</p><p>This is an alias of <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.leRec">Nat.leRec</a></code>, specialized to <code>Prop</code>.</p></div></div><div class="decl" id="Nat.twoStepInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L278-L283">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.twoStepInduction" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.twoStepInduction"><span class="name">Nat</span>.<span class="name">twoStepInduction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">zero</span> : <span class="fn"><span class="fn">P</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">one</span> : <span class="fn"><span class="fn">P</span> <span class="fn">1</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">more</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">n</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">2</span>)</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></div></div><p>Induction principle deriving the next case from the two previous ones.</p><details id="instances-for-list-Nat.twoStepInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.strong_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L285-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strong_induction_on"><span class="name">Nat</span>.<span class="name">strong_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">n</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">(‚àÄ <span class="fn">m</span> &lt; <span class="fn">n</span>, <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span>)</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.case_strong_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L290-L292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.case_strong_induction_on"><span class="name">Nat</span>.<span class="name">case_strong_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hz</span> : <span class="fn"><span class="fn">p</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hi</span> : <span class="fn">‚àÄ (<span class="fn">n</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">(‚àÄ <span class="fn">m</span> ‚â§ <span class="fn">n</span>, <span class="fn"><span class="fn">p</span> <span class="fn">m</span></span>)</span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Nat.decreasingInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L294-L306">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction"><span class="name">Nat</span>.<span class="name">decreasingInduction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">m</span> <span class="fn">mn</span></span></div></div><p>Decreasing induction: if <code>P (k+1)</code> implies <code>P k</code> for all <code>k &lt; n</code>, then <code>P n</code> implies <code>P m</code> for
all <code>m ‚â§ n</code>.
Also works for functions to <code>Sort*</code>.</p><p>For a version also assuming <code>m ‚â§ k</code>, see <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction'">Nat.decreasingInduction'</a></code>.</p><details id="instances-for-list-Nat.decreasingInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.decreasingInduction_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L308-L312">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction_self" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction_self"><span class="name">Nat</span>.<span class="name">decreasingInduction_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn">self</span></span></div></div></div></div><div class="decl" id="Nat.decreasingInduction_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L314-L319">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction_succ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction_succ"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">msn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">msn</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">‚Ñï</span>) (<span class="fn">x_1</span> : <span class="fn">x</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) =&gt; <span class="fn"><span class="fn">of_succ</span> <span class="fn">x</span> <span class="fn">‚ãØ</span></span>)</span> <span class="fn">(<span class="fn">of_succ</span> <span class="fn">n</span> <span class="fn">‚ãØ</span> <span class="fn">self</span>)</span> <span class="fn">mn</span></span></span></div></div></div></div><div class="decl" id="Nat.decreasingInduction_succ'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L321-L324">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction_succ'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction_succ'"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span></span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">of_succ</span> <span class="fn">n</span> <span class="fn">‚ãØ</span> <span class="fn">self</span></span></span></div></div></div></div><div class="decl" id="Nat.decreasingInduction_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L326-L333">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction_trans"><span class="name">Nat</span>.<span class="name">decreasingInduction_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n </span><span class="fn">k</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hmn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnk</span> : <span class="fn">n</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k_1</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k_1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">k</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k_1</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k_1</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">‚Ñï</span>) (<span class="fn">x_1</span> : <span class="fn">x</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) =&gt; <span class="fn"><span class="fn">of_succ</span> <span class="fn">x</span> <span class="fn">‚ãØ</span></span>)</span> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">hnk</span>)</span> <span class="fn">hmn</span></span></span></div></div></div></div><div class="decl" id="Nat.decreasingInduction_succ_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L335-L341">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction_succ_left" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction_succ_left"><span class="name">Nat</span>.<span class="name">decreasingInduction_succ_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">of_succ</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">h</span></span> ‚Üí <span class="fn"><span class="fn">motive</span> <span class="fn">k</span> <span class="fn">‚ãØ</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">self</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">n</span> <span class="fn">‚ãØ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">smn</span> : <span class="fn"><span class="fn">m</span> <span class="fn">+</span> <span class="fn">1</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">mn</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">of_succ</span> <span class="fn">m</span> <span class="fn">smn</span> <span class="fn">(<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">decreasingInduction</a> <span class="fn">of_succ</span> <span class="fn">self</span> <span class="fn">smn</span>)</span></span></span></div></div></div></div><div class="decl" id="Nat.strongSubRecursion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L343-L350">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.strongSubRecursion" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.strongSubRecursion"><span class="name">Nat</span>.<span class="name">strongSubRecursion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">((<span class="fn">x </span><span class="fn">y</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">m</span> ‚Üí <span class="fn"><span class="fn">y</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">m</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">n</span> <span class="fn">m</span></span></div></div><p>Given <code>P : ‚Ñï ‚Üí ‚Ñï ‚Üí Sort*</code>, if for all <code>m n : ‚Ñï</code> we can extend <code>P</code> from the rectangle
strictly below <code>(m, n)</code> to <code>P m n</code>, then we have <code>P n m</code> for all <code>n m : ‚Ñï</code>.
Note that for non-<code>Prop</code> output it is preferable to use the equation compiler directly if possible,
since this produces equation lemmas.</p><details id="instances-for-list-Nat.strongSubRecursion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.pincerRecursion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L352-L363">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.pincerRecursion" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.pincerRecursion"><span class="name">Nat</span>.<span class="name">pincerRecursion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Ha0</span> : <span class="fn">(<span class="fn">m</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">m</span> <span class="fn">0</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H0b</span> : <span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">0</span> <span class="fn">n</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn"><span class="fn">y</span>.<span class="fn">succ</span></span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn"><span class="fn">x</span>.<span class="fn">succ</span></span> <span class="fn">y</span></span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn"><span class="fn">x</span>.<span class="fn">succ</span></span> <span class="fn"><span class="fn">y</span>.<span class="fn">succ</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">m</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">n</span> <span class="fn">m</span></span></div></div><p>Given <code>P : ‚Ñï ‚Üí ‚Ñï ‚Üí Sort*</code>, if we have <code>P m 0</code> and <code>P 0 n</code> for all <code>m n : ‚Ñï</code>, and for any
<code>m n : ‚Ñï</code> we can extend <code>P</code> from <code>(m, n + 1)</code> and <code>(m + 1, n)</code> to <code>(m + 1, n + 1)</code> then we have
<code>P m n</code> for all <code>m n : ‚Ñï</code>.</p><p>Note that for non-<code>Prop</code> output it is preferable to use the equation compiler directly if possible,
since this produces equation lemmas.</p><details id="instances-for-list-Nat.pincerRecursion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.decreasingInduction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L365-L376">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decreasingInduction'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction'"><span class="name">Nat</span>.<span class="name">decreasingInduction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">k</span> : <span class="fn">‚Ñï</span>) ‚Üí <span class="fn"><span class="fn">k</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span> ‚Üí <span class="fn"><span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">k</span> ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">k</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">k</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mn</span> : <span class="fn">m</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn"><span class="fn">P</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">m</span></span></div></div><p>Decreasing induction: if <code>P (k+1)</code> implies <code>P k</code> for all <code>m ‚â§ k &lt; n</code>, then <code>P n</code> implies <code>P m</code>.
Also works for functions to <code>Sort*</code>.</p><p>Weakens the assumptions of <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.decreasingInduction">Nat.decreasingInduction</a></code>.</p><details id="instances-for-list-Nat.decreasingInduction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.diag_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L378-L392">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.diag_induction"><span class="name">Nat</span>.<span class="name">diag_induction</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">‚àÄ (<span class="fn">a</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn">‚àÄ (<span class="fn">b</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">P</span> <span class="fn">0</span> <span class="fn">(<span class="fn">b</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn">‚àÄ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">b</span> ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">b</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">(<span class="fn">b</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">a</span> <span class="fn">+</span> <span class="fn">1</span>)</span> <span class="fn">(<span class="fn">b</span> <span class="fn">+</span> <span class="fn">1</span>)</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">b</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div><p>Given a predicate on two naturals <code>P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop</code>, <code>P a b</code> is true for all <code>a &lt; b</code> if
<code>P (a + 1) (a + 1)</code> is true for all <code>a</code>, <code>P 0 (b + 1)</code> is true for all <code>b</code> and for all
<code>a &lt; b</code>, <code>P (a + 1) b</code> is true and <code>P a (b + 1)</code> is true implies <code>P (a + 1) (b + 1)</code> is true.</p></div></div><div class="mod_doc"><h3 id="mod-dvd" class="markdown-heading"><code>mod</code>, <code>dvd</code> <a class="hover-link" href="#mod-dvd">#</a></h3></div><div class="decl" id="Nat.not_pos_pow_dvd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L396-L398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.not_pos_pow_dvd"><span class="name">Nat</span>.<span class="name">not_pos_pow_dvd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">^</span> <span class="fn">n</span></span> <span class="fn">‚à£</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Nat.not_two_dvd_bit1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L400-L402">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.not_two_dvd_bit1"><span class="name">Nat</span>.<span class="name">not_two_dvd_bit1</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">2</span> <span class="fn">‚à£</span> <span class="fn"><span class="fn"><span class="fn">2</span> <span class="fn">*</span> <span class="fn">n</span></span> <span class="fn">+</span> <span class="fn">1</span></span></span></span></div></div></div></div><div class="decl" id="Nat.dvd_add_self_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L404-L405">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.dvd_add_self_left"><span class="name">Nat</span>.<span class="name">dvd_add_self_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">‚à£</span> <span class="fn"><span class="fn">m</span> <span class="fn">+</span> <span class="fn">n</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">m</span> <span class="fn">‚à£</span> <span class="fn">n</span></span></span></div></div><p>A natural number <code>m</code> divides the sum <code>m + n</code> if and only if <code>m</code> divides <code>n</code>.</p></div></div><div class="decl" id="Nat.dvd_add_self_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L407-L408">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.dvd_add_self_right"><span class="name">Nat</span>.<span class="name">dvd_add_self_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">‚à£</span> <span class="fn"><span class="fn">n</span> <span class="fn">+</span> <span class="fn">m</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">m</span> <span class="fn">‚à£</span> <span class="fn">n</span></span></span></div></div><p>A natural number <code>m</code> divides the sum <code>n + m</code> if and only if <code>m</code> divides <code>n</code>.</p></div></div><div class="decl" id="Nat.dvd_right_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L410-L413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.dvd_right_iff_eq"><span class="name">Nat</span>.<span class="name">dvd_right_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">‚à£</span> <span class="fn">a</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">n</span> <span class="fn">‚à£</span> <span class="fn">a</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">m</span> <span class="fn">=</span> <span class="fn">n</span></span></span></div></div><p>Two natural numbers are equal if and only if they have the same multiples.</p></div></div><div class="decl" id="Nat.dvd_left_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L415-L418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.dvd_left_iff_eq"><span class="name">Nat</span>.<span class="name">dvd_left_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m </span><span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">‚à£</span> <span class="fn">m</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">a</span> <span class="fn">‚à£</span> <span class="fn">n</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">m</span> <span class="fn">=</span> <span class="fn">n</span></span></span></div></div><p>Two natural numbers are equal if and only if they have the same divisors.</p></div></div><div class="mod_doc"><h3 id="Decidability-of-predicates" class="markdown-heading">Decidability of predicates <a class="hover-link" href="#Decidability-of-predicates">#</a></h3></div><div class="decl" id="Nat.decidableLoHi"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L422-L428">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decidableLoHi" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decidableLoHi"><span class="name">Nat</span>.<span class="name">decidableLoHi</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lo </span><span class="fn">hi</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(‚àÄ (<span class="fn">x</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">lo</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x</span> ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">hi</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span></span></span>)</span></span></div></div></div></div><div class="decl" id="Nat.decidableLoHiLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L430-L433">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.decidableLoHiLe" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.decidableLoHiLe"><span class="name">Nat</span>.<span class="name">decidableLoHiLe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lo </span><span class="fn">hi</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(‚àÄ (<span class="fn">x</span> : <span class="fn">‚Ñï</span>), <span class="fn"><span class="fn">lo</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x</span> ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">hi</span> ‚Üí <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span></span></span>)</span></span></div></div></div></div><div class="decl" id="Nat.instNeZeroNatAbsOfInt_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L435-L436">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.instNeZeroNatAbsOfInt_mathlib"><span class="name">Nat</span>.<span class="name">instNeZeroNatAbsOfInt_mathlib</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñ§</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">NeZero</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">NeZero</span> <span class="fn"><span class="fn">n</span>.<span class="fn">natAbs</span></span></span></div></div></div></div><div class="mod_doc"><h3 id="Nat-AtLeastTwo" class="markdown-heading"><code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">Nat.AtLeastTwo</a></code> <a class="hover-link" href="#Nat-AtLeastTwo">#</a></h3></div><div class="decl" id="Nat.AtLeastTwo"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L440-L452">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.AtLeastTwo" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A type class for natural numbers which are greater than or equal to <code>2</code>.</p><p><code>NeZero</code> and <code><a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></code> are used for numeric literals, and also for groups of related lemmas
sharing a common value of <code>n</code> that needs to be nonzero, or at least <code>2</code>, and where it is
convenient to pass this information implicitly. Instances for these classes cover some of the
cases where it is most structurally obvious from the syntactic form of <code>n</code> that it satisfies the
required conditions, such as <code>m + 1</code>. Less widely used cases may be defined as lemmas rather than
global instances and then made into instances locally where needed. If implicit arguments,
appearing before other explicit arguments, are allowed to be <code>autoParam</code>s in a future version of
Lean, such an <code>autoParam</code> that is proved <code>by lia</code> might be a more general replacement for the
use of typeclass inference for this purpose.</p><ul class="structure_fields" id="Nat.AtLeastTwo.mk"><li id="Nat.AtLeastTwo.prop" class="structure_field"><div class="structure_field_info">prop : <span class="fn">2</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">n</span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Nat.AtLeastTwo" class="instances-list"></ul></details></div></div><div class="decl" id="Nat.instAtLeastTwoHAddOfNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L456-L457">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Nat_Init.html#Nat.instAtLeastTwoHAddOfNat" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.instAtLeastTwoHAddOfNat"><span class="name">Nat</span>.<span class="name">instAtLeastTwoHAddOfNat</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">NeZero</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">n</span> <span class="fn">+</span> <span class="fn">1</span>)</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></span></div></div></div></div><div class="decl" id="Nat.AtLeastTwo.one_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L463-L463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo.one_lt"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">one_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Nat.AtLeastTwo.ne_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L464-L464">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo.ne_one"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">ne_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">‚Ñï</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">‚â†</span> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="Nat.AtLeastTwo.toNeZero"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L466-L467">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo.toNeZero"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">toNeZero</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">NeZero</span> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.AtLeastTwo.neZero_sub_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Nat/Init.lean#L470-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo.neZero_sub_one"><span class="name">Nat</span>.<span class="name">AtLeastTwo</span>.<span class="name">neZero_sub_one</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo">AtLeastTwo</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">NeZero</span> <span class="fn">(<span class="fn">n</span> <span class="fn">-</span> <span class="fn">1</span>)</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>