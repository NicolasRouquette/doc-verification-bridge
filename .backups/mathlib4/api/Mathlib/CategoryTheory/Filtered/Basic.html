<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Filtered.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Filtered.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Data/Fin/VecNotation.html">Mathlib.Data.Fin.VecNotation</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html">Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Filtered.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.isDirectedOrder"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">isDirectedOrder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.iff_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.firstToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.secondToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.thirdToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq‚ÇÉHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.crown"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.crown‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.crown‚ÇÑ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown‚ÇÑ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.wideSpan"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">wideSpan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.iff_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.wideCospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">wideCospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_iff_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_iff_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_iff_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_iff_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredProd</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Filtered-categories" class="markdown-heading">Filtered categories <a class="hover-link" href="#Filtered-categories">#</a></h1><p>A category is filtered if every finite diagram admits a cocone.
We give a simple characterisation of this condition as</p><ol><li>for every pair of objects there exists another object &quot;to the right&quot;,</li><li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li><li>there exists some object.</li></ol><p>An important example of filtered category is given by nonempty directed types;
actually, filtered categories may be considered as a generalization of nonempty directed types.
In the file <code>CategoryTheory.Presentable.<a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a></code>, we show that &quot;conversely&quot;
if <code>C</code> is a filtered category, there exists a final functor <code>Œ± ‚•§ C</code> from
a nonempty directed type (<code>IsFiltered.isDirected</code>).</p><p>Filtered colimits are often better behaved than arbitrary colimits.
See <code>Mathlib/CategoryTheory/Limits/Types/</code> for some details.</p><p>Filtered categories are nice because colimits indexed by filtered categories tend to be
easier to describe than general colimits (and more often preserved by functors).</p><p>In this file we show that any functor from a finite category to a filtered category admits a cocone:</p><ul><li><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a> [FinCategory J] [IsFiltered C] (F : J ‚•§ C) : Nonempty (Cocone F)</code>
More generally,
for any finite collection of objects and morphisms between them in a filtered category
(even if not closed under composition) there exists some object <code>Z</code> receiving maps from all of them,
so that all the triangles (one edge from the finite set, two from morphisms to <code>Z</code>) commute.
This formulation is often more useful in practice and is available via <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists">sup_exists</a></code>,
which takes a finset of objects, and an indexed family (indexed by source and target)
of finsets of morphisms.</li></ul><p>We also prove the converse of <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a></code> as <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty">of_cocone_nonempty</a></code>.</p><p>Furthermore, we give special support for two diagram categories: The <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>.
This is because these shapes show up in the proofs that forgetful functors of algebraic categories
(e.g. <code><a href="../../.././Mathlib/Algebra/Category/MonCat/Basic.html#MonCat">MonCat</a></code>, <code><a href="../../.././Mathlib/Algebra/Category/Ring/Basic.html#CommRingCat">CommRingCat</a></code>, ...) preserve filtered colimits.</p><p>All of the above API, except for the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>, is also provided for cofiltered
categories.</p><h2 id="See-also" class="markdown-heading">See also <a class="hover-link" href="#See-also">#</a></h2><p>In <code><a href="../../.././Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.html">Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean</a></code> we show that filtered
colimits commute with finite limits.</p><p>There is another characterization of filtered categories, namely that whenever <code>F : J ‚•§ C</code> is a
functor from a finite category, there is <code>X : C</code> such that <code>Nonempty (limit (F.op ‚ãô yoneda.obj X))</code>.
This is shown in <code><a href="../../.././Mathlib/CategoryTheory/Limits/Filtered.html">Mathlib/CategoryTheory/Limits/Filtered.lean</a></code>.</p></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L76-L86">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFilteredOrEmpty" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a></code> if</p><ol><li>for every pair of objects there exists another object &quot;to the right&quot;, and</li><li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal.</li></ol><ul class="structure_fields" id="CategoryTheory.IsFilteredOrEmpty.mk"><li id="CategoryTheory.IsFilteredOrEmpty.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) (<span class="fn">x</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>), <span class="fn">True</span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the right&quot;</p></div></li><li id="CategoryTheory.IsFilteredOrEmpty.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps<span class="impl_arg"><span class="decl_args">
<span class="fn">‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L88-L97">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span id="CategoryTheory.IsFiltered.toIsFilteredOrEmpty"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code> if</p><ol><li>for every pair of objects there exists another object &quot;to the right&quot;,</li><li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li><li>there exists some object.</li></ol><ul class="structure_fields" id="CategoryTheory.IsFiltered.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_objs">cocone_objs</a><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) (<span class="fn">x</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>), <span class="fn">True</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_maps">cocone_maps</a><span class="impl_arg"><span class="decl_args">
<span class="fn">‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></li><li id="CategoryTheory.IsFiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><span class="fn">Nonempty</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a filtered category must be non-empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L99-L102">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L104-L105">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_directed_le"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L107-L112">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFilteredOrEmpty_of_directed_le" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirectedOrder">IsDirectedOrder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_of_directed_le_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L114-L115">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFiltered_of_directed_le_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirectedOrder">IsDirectedOrder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L122-L124">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredDiscretePUnit" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete">Discrete</a> <span class="fn">PUnit.{u_1 + 1}</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L133-L137">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.max" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code> is an arbitrary choice of object to the right of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.leftToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L139-L143">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.leftToMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> <span class="fn">j</span> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">leftToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.leftToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.rightToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L145-L149">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.rightToMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> <span class="fn">j</span> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">rightToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j'</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.rightToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L151-L157">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.coeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L159-L165">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeqHom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.coeqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L167-L172">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq_condition" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is the proof that
<code>f ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L170-L170">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq_condition_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">h</span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is the proof that
<code>f ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ‚â´ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.isDirectedOrder"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L176-L178">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.isDirectedOrder" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.isDirectedOrder"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">isDirectedOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirectedOrder">IsDirectedOrder</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L189-L198">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a functor <code>R : C ‚•§ D</code> with a left adjoint, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L200-L203">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a right adjoint functor <code>R : C ‚•§ D</code>, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L205-L207">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being filtered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L220-L232">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.sup_objs_exists" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">‚àÄ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span> ‚Üí <span class="fn"><span class="fn">Nonempty</span> (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">S</span>)</span></span></span></span></div></div><p>Any finite collection of objects in a filtered category has an object &quot;to the right&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L236-L264">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.sup_exists" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span> ‚Üí (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">S</span>)</span></span>),
  <span class="fn">‚àÄ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}, <span class="fn"><span class="fn"><span class="fn"><span class="fn">‚ü®</span><span class="fn">X</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">Y</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mX</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mY</span>, <span class="fn">f</span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span> <span class="fn">‚àà</span> <span class="fn">H</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn">T</span> <span class="fn">mY</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : X ‚ü∂ S</code> from each <code>X</code>,
such that the triangles commute: <code>f ‚â´ T Y = T X</code>, for <code>f : X ‚ü∂ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L266-L271">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.sup" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the right&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details id="instances-for-list-CategoryTheory.IsFiltered.sup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L273-L276">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.toSup" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> <span class="fn">O</span> <span class="fn">H</span></span></div></div><p>The morphisms to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.toSup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L278-L283">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.toSup_commutes" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mf</span> : <span class="fn"><span class="fn"><span class="fn">‚ü®</span><span class="fn">X</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">Y</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mX</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mY</span>, <span class="fn">f</span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span> <span class="fn">‚àà</span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span></span></div></div><p>The triangles of consisting of a morphism in <code>H</code> and the maps to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L287-L304">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.cocone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>, then for any functor <code>F : J ‚•§ C</code> with <code>FinCategory J</code>,
there exists a cocone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L306-L309">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.cocone" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cocone over <code>F : J ‚•§ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.cocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L313-L317">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_right_adjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a functor <code>R : C ‚•§ D</code> with a left adjoint, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L319-L321">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_isRightAdjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a right adjoint functor <code>R : C ‚•§ D</code>, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L323-L325">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>Being filtered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.iff_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L328-L329">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.iff_of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.iff_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L338-L356">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cocone, then <code>C</code> is filtered. It is sufficient to verify
this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasFiniteColimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L358-L359">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_hasFiniteColimits" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteColimits">Limits.HasFiniteColimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isTerminal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L361-L362">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_isTerminal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal">Limits.IsTerminal</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasTerminal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L364-L365">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.of_hasTerminal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasTerminal">Limits.HasTerminal</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.iff_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L367-L371">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.iff_cocone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.max‚ÇÉ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L380-L384">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code> is an arbitrary choice of object to the right of <code>j‚ÇÅ</code>, <code>j‚ÇÇ</code> and <code>j‚ÇÉ</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.max‚ÇÉ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.firstToMax‚ÇÉ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L386-L390">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.firstToMax‚ÇÉ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> <span class="fn">j‚ÇÅ</span> <span class="fn">j‚ÇÇ</span> <span class="fn">j‚ÇÉ</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax‚ÇÉ">firstToMax‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code> is an arbitrary choice of morphism from <code>j‚ÇÅ</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.firstToMax‚ÇÉ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.secondToMax‚ÇÉ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L392-L396">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.secondToMax‚ÇÉ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> <span class="fn">j‚ÇÅ</span> <span class="fn">j‚ÇÇ</span> <span class="fn">j‚ÇÉ</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax‚ÇÉ">secondToMax‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code> is an arbitrary choice of morphism from <code>j‚ÇÇ</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.secondToMax‚ÇÉ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.thirdToMax‚ÇÉ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L398-L402">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.thirdToMax‚ÇÉ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> <span class="fn">j‚ÇÅ</span> <span class="fn">j‚ÇÇ</span> <span class="fn">j‚ÇÉ</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax‚ÇÉ">thirdToMax‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code> is an arbitrary choice of morphism from <code>j‚ÇÉ</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max‚ÇÉ">max‚ÇÉ</a> j‚ÇÅ j‚ÇÇ j‚ÇÉ</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.thirdToMax‚ÇÉ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq‚ÇÉ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L404-L411">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ">coeq‚ÇÉ</a> f g h</code>, for morphisms <code>f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> f g h : j‚ÇÇ ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ">coeq‚ÇÉ</a> f g h</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ">coeq‚ÇÉ_condition‚ÇÅ</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ">coeq‚ÇÉ_condition‚ÇÇ</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ">coeq‚ÇÉ_condition‚ÇÉ</a></code> are satisfied.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.coeq‚ÇÉ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq‚ÇÉHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L413-L421">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ">coeq‚ÇÉ</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> f g h</code>, for morphisms <code>f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ</code>, is an arbitrary choice of morphism
<code>j‚ÇÇ ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ">coeq‚ÇÉ</a> f g h</code> such that <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ">coeq‚ÇÉ_condition‚ÇÅ</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ">coeq‚ÇÉ_condition‚ÇÇ</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ">coeq‚ÇÉ_condition‚ÇÉ</a></code>
are satisfied. Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsFiltered.coeq‚ÇÉHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L423-L425">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L428-L434">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L436-L437">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉ_condition‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq‚ÇÉ_condition‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq‚ÇÉHom">coeq‚ÇÉHom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.span"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L439-L445">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.span" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k</span>) (<span class="fn">g'</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></span></div></div><p>For every span <code>j ‚üµ i ‚ü∂ j'</code>, there exists a cocone <code>j ‚ü∂ k ‚üµ j'</code> such that the square
commutes.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L447-L465">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.bowtie" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≤</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÅ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÇ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">Œ≤</span></span></span></span></span></div></div><p>Given a &quot;bowtie&quot; of morphisms</p><pre><code> j‚ÇÅ   j‚ÇÇ
 |\  /|
 | \/ |
 | /\ |
 |/  \‚à£
 vv  vv
 k‚ÇÅ  k‚ÇÇ
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k‚ÇÅ</code> and <code>k‚ÇÇ</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.crown"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L467-L494">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.crown" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.crown"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">j</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">j</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≤</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>), <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">g</span> <span class="fn">i</span>)</span> <span class="fn">Œ≤</span></span></span></span></span></div></div><p>Given a &quot;crown&quot; of morphisms</p><pre><code>  j‚ÇÅ   j‚ÇÇ   j‚ÇÉ  ... j‚Çô
 /  \  /\  /  \
|    \/  \/    |
|    /\  /\    |
|   |  \/  |   |
 \  |  /\  |  /
  \ | /  \ | /
   vvv    vvv
    k‚ÇÅ    k‚ÇÇ
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k‚ÇÅ</code> and <code>k‚ÇÇ</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.crown‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L496-L518">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.crown‚ÇÉ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.crown‚ÇÉ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ </span><span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÉ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÉ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≤</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÅ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span>     <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÇ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÉ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÉ</span> <span class="fn">Œ≤</span></span></span></span></span></span></div></div><p>Given a &quot;crown&quot; of morphisms</p><pre><code>  j‚ÇÅ   j‚ÇÇ   j‚ÇÉ
 /  \  /\  /  \
|    \/  \/    |
|    /\  /\    |
|   |  \/  |   |
 \  |  /\  |  /
  \ | /  \ | /
   vvv    vvv
    k‚ÇÅ    k‚ÇÇ
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k‚ÇÅ</code> and <code>k‚ÇÇ</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.crown‚ÇÑ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L520-L528">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.crown‚ÇÑ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.crown‚ÇÑ"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">crown‚ÇÑ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ </span><span class="fn">j‚ÇÑ </span><span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÉ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÉ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÑ</span> : <span class="fn">j‚ÇÑ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÑ</span> : <span class="fn">j‚ÇÑ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≤</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÅ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span>     <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÇ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span>       <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÉ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÉ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÑ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÑ</span> <span class="fn">Œ≤</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.tulip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L530-L554">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.tulip" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">j‚ÇÉ </span><span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ </span><span class="fn">l</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÇ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÉ</span> : <span class="fn">j‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÑ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ</span> : <span class="fn">j‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÇ</span> : <span class="fn">j‚ÇÉ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≤</span> : <span class="fn">l</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>) (<span class="fn">Œ≥</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">s</span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÅ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">Œ≤</span></span></span> <span class="fn">‚àß</span>     <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÇ</span> <span class="fn">Œ±</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÉ</span> <span class="fn">Œ≥</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f‚ÇÑ</span> <span class="fn">Œ≥</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">Œ≤</span></span></span></span></span></span></div></div><p>Given a &quot;tulip&quot; of morphisms</p><pre><code> j‚ÇÅ    j‚ÇÇ    j‚ÇÉ
 |\   / \   / |
 | \ /   \ /  |
 |  vv    vv  |
 \  k‚ÇÅ    k‚ÇÇ /
  \         /
   \       /
    \     /
     \   /
      v v
       l
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and three morphisms from <code>k‚ÇÅ</code>, <code>k‚ÇÇ</code> and <code>l</code>
to <code>s</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.wideSpan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L556-L563">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsFiltered.wideSpan" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.wideSpan"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">wideSpan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">I</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn">I</span> ‚Üí <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">I</span>) ‚Üí <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn">j</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">fik</span> : <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k</span>) (<span class="fn">g</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">I</span>) ‚Üí <span class="fn"><span class="fn">j</span> <span class="fn">x</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k</span></span>), <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">I</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn">fik</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L569-L580">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofilteredOrEmpty" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a></code> if</p><ol><li>for every pair of objects there exists another object &quot;to the left&quot;, and</li><li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal.</li></ol><ul class="structure_fields" id="CategoryTheory.IsCofilteredOrEmpty.mk"><li id="CategoryTheory.IsCofilteredOrEmpty.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn">True</span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the left&quot;</p></div></li><li id="CategoryTheory.IsCofilteredOrEmpty.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps<span class="impl_arg"><span class="decl_args">
<span class="fn">‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L582-L591">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span id="CategoryTheory.IsCofiltered.toIsCofilteredOrEmpty"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code> if</p><ol><li>for every pair of objects there exists another object &quot;to the left&quot;,</li><li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal, and</li><li>there exists some object.</li></ol><ul class="structure_fields" id="CategoryTheory.IsCofiltered.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_objs">cone_objs</a><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn">True</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_maps">cone_maps</a><span class="impl_arg"><span class="decl_args">
<span class="fn">‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">‚àÉ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></div></li><li id="CategoryTheory.IsCofiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><span class="fn">Nonempty</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a cofiltered category must be non-empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L593-L598">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L600-L601">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L603-L610">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsCodirectedOrder">IsCodirectedOrder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_directed_ge_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L612-L613">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsCodirectedOrder">IsCodirectedOrder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L620-L624">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredDiscretePUnit" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete">Discrete</a> <span class="fn">PUnit.{u_1 + 1}</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L633-L637">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.min" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> is an arbitrary choice of object to the left of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.min" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L639-L643">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.minToLeft" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">minToLeft</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.minToLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L645-L649">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.minToRight" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">minToRight</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.minToRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L651-L657">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.eq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ‚ü∂ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L659-L665">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.eqHom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ‚ü∂ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.eqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L667-L672">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.eq_condition" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is the proof that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L670-L670">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.eq_condition_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">h</span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ‚ü∂ j'</code>, is the proof that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ‚â´ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L674-L680">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.cospan" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">i</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">i</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j</span>) (<span class="fn">g'</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j'</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">f'</span></span></span></span></div></div><p>For every cospan <code>j ‚ü∂ i ‚üµ j'</code>,
there exists a cone <code>j ‚üµ k ‚ü∂ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.Functor.ranges_directed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L682-L685">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.Functor.ranges_directed" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(Type</a> u_1)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x1</span> <span class="fn">‚äá</span> <span class="fn">x2</span></span>)</span> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">C</span>) √ó' (<span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j</span>)</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<span class="fn">snd</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L687-L705">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.bowtie" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j‚ÇÅ </span><span class="fn">j‚ÇÇ </span><span class="fn">k‚ÇÅ </span><span class="fn">k‚ÇÇ</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÅ</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÅ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f‚ÇÇ</span> : <span class="fn">k‚ÇÅ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÇ</span> : <span class="fn">k‚ÇÇ</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">j‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">Œ±</span> : <span class="fn">s</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÅ</span>) (<span class="fn">Œ≤</span> : <span class="fn">s</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">k‚ÇÇ</span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">Œ±</span> <span class="fn">f‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">Œ≤</span> <span class="fn">g‚ÇÅ</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">Œ±</span> <span class="fn">f‚ÇÇ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">Œ≤</span> <span class="fn">g‚ÇÇ</span></span></span></span></span></div></div><p>Given a &quot;bowtie&quot; of morphisms</p><pre><code> k‚ÇÅ   k‚ÇÇ
 |\  /|
 | \/ |
 | /\ |
 |/  \‚à£
 vv  vv
 j‚ÇÅ  j‚ÇÇ
</code></pre><p>in a cofiltered category, we can construct an object <code>s</code> and two morphisms
from <code>s</code> to <code>k‚ÇÅ</code> and <code>k‚ÇÇ</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L718-L727">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a functor <code>L : C ‚•§ D</code> with a right adjoint,
then <code>D</code> is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L729-L732">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsLeftAdjoint">IsLeftAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a left adjoint functor <code>L : C ‚•§ D</code>, then <code>D</code> is
cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L734-L736">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being cofiltered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L749-L761">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.inf_objs_exists" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">‚àÄ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span> ‚Üí <span class="fn"><span class="fn">Nonempty</span> (<span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span></span></span></div></div><p>Any finite collection of objects in a cofiltered category has an object &quot;to the left&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L765-L793">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.inf_exists" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} ‚Üí <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span> ‚Üí (<span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>),
  <span class="fn">‚àÄ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}, <span class="fn"><span class="fn"><span class="fn"><span class="fn">‚ü®</span><span class="fn">X</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">Y</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mX</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mY</span>, <span class="fn">f</span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span> <span class="fn">‚àà</span> <span class="fn">H</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">T</span> <span class="fn">mX</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : S ‚ü∂ X</code> from each <code>X</code>,
such that the triangles commute: <code>T X ‚â´ f = T Y</code>, for <code>f : X ‚ü∂ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L795-L800">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.inf" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the left&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.inf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L802-L805">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.infTo" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span></div></div><p>The morphisms from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.infTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L807-L812">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.infTo_commutes" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) √ó' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>) √ó' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <span class="fn">‚àà</span> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mf</span> : <span class="fn"><span class="fn"><span class="fn">‚ü®</span><span class="fn">X</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">Y</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mX</span>, <span class="fn"><span class="fn">‚ü®</span><span class="fn">mY</span>, <span class="fn">f</span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span><span class="fn">‚ü©</span></span> <span class="fn">‚àà</span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></span></div></div><p>The triangles consisting of a morphism in <code>H</code> and the maps from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L816-L835">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.cone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>, then for any functor <code>F : J ‚•§ C</code> with <code>FinCategory J</code>,
there exists a cone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L837-L840">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.cone" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cone over <code>F : J ‚•§ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>.</p><details id="instances-for-list-CategoryTheory.IsCofiltered.cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L844-L849">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_left_adjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a functor <code>L : C ‚•§ D</code> with a right adjoint,
then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L851-L853">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsLeftAdjoint">IsLeftAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a left adjoint functor <code>L : C ‚•§ D</code>, then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L855-L857">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>Being cofiltered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.iff_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L860-L861">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.iff_of_equivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.iff_of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.wideCospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L864-L872">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.wideCospan" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.wideCospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">wideCospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">I</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn">I</span> ‚Üí <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">I</span>) ‚Üí <span class="fn"><span class="fn">j</span> <span class="fn">x</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">fki</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">i</span>) (<span class="fn">g</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">I</span>) ‚Üí <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn">j</span> <span class="fn">x</span></span></span>), <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">I</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn">fki</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L882-L900">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_cone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cone, then <code>C</code> is cofiltered. It is sufficient to
verify this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasFiniteLimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L902-L903">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_hasFiniteLimits" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteLimits">Limits.HasFiniteLimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isInitial"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L905-L906">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_isInitial" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsInitial">Limits.IsInitial</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasInitial"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L908-L909">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.of_hasInitial" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasInitial">Limits.HasInitial</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.iff_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L911-L915">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.IsCofiltered.iff_cone_nonempty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L925-L934">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_of_isFiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L936-L937">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofiltered_op_of_isFiltered" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L939-L948">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_op_of_isCofiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L950-L951">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFiltered_op_of_isCofiltered" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L953-L955">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If C·µí·µñ is filtered or empty, then C is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L957-L959">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If C·µí·µñ is cofiltered or empty, then C is filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_isFiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L961-L963">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofiltered_of_isFiltered_op" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If C·µí·µñ is filtered, then C is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.isFiltered_of_isCofiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L965-L967">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFiltered_of_isCofiltered_op" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div><p>If C·µí·µñ is cofiltered, then C is filtered.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_iff_isFiltered"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L969-L970">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isCofiltered_op_iff_isFiltered" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_op_iff_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_iff_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_op_iff_isCofiltered"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L972-L973">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.isFiltered_op_iff_isCofiltered" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_op_iff_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_iff_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">·µí·µñ</a></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L979-L980">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredULift" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<span class="fn">ULift.{u‚ÇÇ, u}</span> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L982-L983">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredULift" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<span class="fn">ULift.{u‚ÇÇ, u}</span> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L985-L986">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredULiftHom" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">ULiftHom</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L988-L989">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredULiftHom" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">ULiftHom</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L991-L992">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredAsSmall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">AsSmall</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L994-L995">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredAsSmall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">AsSmall</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredOrEmptyForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1004-L1008">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredOrEmptyForall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œ±</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1011-L1011">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredForall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œ±</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredOrEmptyForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1014-L1018">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredOrEmptyForall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œ±</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1021-L1021">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredForall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œ±</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredOrEmptyProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1031-L1035">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredOrEmptyProd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">(<span class="fn">C</span> <span class="fn">√ó</span> <span class="fn">D</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1038-L1038">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsFilteredProd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<span class="fn">C</span> <span class="fn">√ó</span> <span class="fn">D</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredOrEmptyProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1042-L1046">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredOrEmptyProd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">(<span class="fn">C</span> <span class="fn">√ó</span> <span class="fn">D</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Filtered/Basic.lean#L1049-L1049">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Filtered_Basic.html#CategoryTheory.instIsCofilteredProd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<span class="fn">C</span> <span class="fn">√ó</span> <span class="fn">D</span>)</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>