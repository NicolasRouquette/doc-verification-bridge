<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Presentable.OrthogonalReflection</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Presentable.OrthogonalReflection";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Presentable</span>.<span class="name">OrthogonalReflection</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Adjunction/PartialAdjoint.html">Mathlib.CategoryTheory.Adjunction.PartialAdjoint</a></li><li><a href="../../.././Mathlib/CategoryTheory/Localization/BousfieldTransfiniteComposition.html">Mathlib.CategoryTheory.Localization.BousfieldTransfiniteComposition</a></li><li><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html">Mathlib.CategoryTheory.MorphismProperty.IsSmall</a></li><li><a href="../../.././Mathlib/CategoryTheory/Presentable/Adjunction.html">Mathlib.CategoryTheory.Presentable.Adjunction</a></li><li><a href="../../.././Mathlib/CategoryTheory/SmallObject/TransfiniteIteration.html">Mathlib.CategoryTheory.SmallObject.TransfiniteIteration</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html">Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Presentable.OrthogonalReflection" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isClosedUnderColimitsOfShape_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isCardinalAccessible_Œπ_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isCardinalAccessible_Œπ_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÅOfIsSmallOfLocallySmall"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD‚ÇÅOfIsSmallOfLocallySmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.hasCoproductsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">hasCoproductsOfShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">obj‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">obj‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">l</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_l</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_l_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">Œπ_comp_t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">Œπ_comp_t_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_t_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.step"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">step</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toStep</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_snd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_fst</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_L"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_L</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_R"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_R</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallLMultispanShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.hasColimitsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">hasColimitsOfShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_left"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_fst</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_snd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_right"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.fromStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">fromStep</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_injectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_surjectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">leftBousfieldW_isLocal_toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isIso_toSucc_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.succStruct"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succStruct</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflectionObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">transfiniteCompositionOfShapeReflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iterationObjSuccIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_injectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_surjectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_reflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_reflectionObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.corepresentableBy"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">corepresentableBy</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isRightAdjoint_Œπ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isRightAdjoint_Œπ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isRightAdjoint_Œπ_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isRightAdjoint_Œπ_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isLocallyPresentable_isLocal</span></a></div></nav><main>
<div class="mod_doc"><h1 id="The-Orthogonal-reflection-construction" class="markdown-heading">The Orthogonal-reflection construction <a class="hover-link" href="#The-Orthogonal-reflection-construction">#</a></h1><p>Given <code>W : MorphismProperty C</code> (which should be small) and assuming the existence
of certain colimits in <code>C</code>, we construct a morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> for
any <code>Z : C</code>. This morphism belongs to <code>W.isLocal.isLocal</code> and
is an isomorphism iff <code>Z</code> belongs to <code>W.isLocal</code> (see the lemma <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff">isIso_toSucc_iff</a></code>).
The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is defined as a composition
of two morphisms that are roughly described as follows:</p><ul><li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">toStep</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code>: for any morphism <code>f : X ‚ü∂ Y</code> satisfying <code>W</code>
and any morphism <code>X ‚ü∂ Z</code>, we &quot;attach&quot; a morphism <code>Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> (using
coproducts and a pushout in essentially the same way as it is done in
the file <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Construction.html">Mathlib/CategoryTheory/SmallObject/Construction.lean</a></code> for the small object
argument);</li><li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> W Z : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>: this morphism coequalizes all pairs
of morphisms <code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> such that there is a <code>f : X ‚ü∂ Y</code>
satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</li></ul><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is a variant of the (wrong) definition
p. 32 in the book by Ad√°mek and Rosick√Ω. In this book, a slightly different object
than <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is defined directly as a colimit of an intricate diagram, but
contrary to what is stated on p. 33, it does not satisfy <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff">isIso_toSucc_iff</a></code>.
The author of this file was unable to understand the attempt of the authors
to fix this mistake in the errata to this book. This led to the definition
in two steps outlined above.</p><h2 id="Main-results" class="markdown-heading">Main results <a class="hover-link" href="#Main-results">#</a></h2><p>The morphisms described above <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> for all <code>Z : C</code> allow to
define <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">succStruct</a> W Z‚ÇÄ : SuccStruct C</code> for any <code>Z‚ÇÄ : C</code>. By applying
a transfinite iteration to this <code>SuccStruct</code>, we obtain the following results
under the assumption that <code>W : MorphismProperty C</code> is a <code>w</code>-small property
of morphisms in a locally <code>Œ∫</code>-presentable category <code>C</code> (with <code>Œ∫ : Cardinal.{w}</code>
a regular cardinal) such that the domains and codomains of the morphisms
satisfying <code>W</code> are <code>Œ∫</code>-presentable:</p><ul><li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isRightAdjoint_Œπ_isLocal">MorphismProperty.isRightAdjoint_Œπ_isLocal</a></code>: existence of the left adjoint
of the inclusion <code>W.isLocal ‚•§ C</code>;</li><li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal">MorphismProperty.isLocallyPresentable_isLocal</a></code>: the full subcategory
<code>W.isLocal</code> is locally presentable.</li></ul><p>This is essentially the implication (i) ‚Üí (ii) in Theorem 1.39 (and the corollary 1.40)
in the book by Ad√°mek and Rosick√Ω (note that according to the
errata to this book, the implication (ii) ‚Üí (i) is wrong when <code>Œ∫ = ‚Ñµ‚ÇÄ</code>).</p><h2 id="References" class="markdown-heading">References <a class="hover-link" href="#References">#</a></h2><ul><li>[Ad√°mek, J. and Rosick√Ω, J., <em>Locally presentable and accessible categories</em>][Adamek_Rosicky_1994]</li></ul></div><div class="decl" id="CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L75-L93">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isClosedUnderColimitsOfShape_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> u')</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v', u'}</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.EssentiallySmall">EssentiallySmall.{w, v', u'}</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/IsCardinalFiltered.html#CategoryTheory.IsCardinalFiltered">IsCardinalFiltered</a> <span class="fn">J</span> <span class="fn">Œ∫</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/ColimitsOfShape.html#CategoryTheory.ObjectProperty.IsClosedUnderColimitsOfShape">IsClosedUnderColimitsOfShape</a></span> <span class="fn">J</span></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isCardinalAccessible_Œπ_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L95-L102">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.MorphismProperty.isCardinalAccessible_Œπ_isLocal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isCardinalAccessible_Œπ_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isCardinalAccessible_Œπ_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.HasCardinalFilteredColimits">HasCardinalFilteredColimits</a> <span class="fn">C</span> <span class="fn">Œ∫</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.Œπ">Œπ</a></span>.<a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.Functor.IsCardinalAccessible">IsCardinalAccessible</a></span> <span class="fn">Œ∫</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L108-L111">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u v)</div></div><p>Given <code>W : MorphismProperty C</code> and <code>Z : C</code>, this is the index type
parametrising the data of a morphism <code>f : X ‚ü∂ Y</code> satisfying <code>W</code>
and a morphism <code>X ‚ü∂ Z</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallD‚ÇÅOfIsSmallOfLocallySmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L113-L116">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÅOfIsSmallOfLocallySmall" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÅOfIsSmallOfLocallySmall"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD‚ÇÅOfIsSmallOfLocallySmall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.hasCoproductsOfShape"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L118-L122">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.hasCoproductsOfShape" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.hasCoproductsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">hasCoproductsOfShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproductsOfShape">Limits.HasCoproductsOfShape</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L125-L127">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">obj‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>If <code>d : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> W Z</code> corresponds to the data of <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> and
of a morphism <code>X ‚ü∂ Z</code>, this is the object <code>X</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L130-L132">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">obj‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>If <code>d : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> W Z</code> corresponds to the data of <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> and
of a morphism <code>X ‚ü∂ Z</code>, this is the object <code>Y</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.l"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L138-L142">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">l</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span></div></div><p>Considering all diagrams consisting of a morphism <code>f : X ‚ü∂ Y</code> satisfying <code>W</code>
and of a morphism <code>d : X ‚ü∂ Z</code>, this is the morphism from the coproduct of
all these <code>X</code> objects to <code>Z</code> given by these morphisms <code>d</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.l" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L145-L148">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></div></div><p>The inclusion of a summand in <code>‚àê <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L151-L154">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_l</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft">ŒπLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l">l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L151-L151">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_l_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_l_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft">ŒπLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l">l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.t"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L158-L161">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></div></div><p>The coproduct of all the morphisms <code>f</code> indexed by all diagrams
consisting of a morphism <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> and of a morphism <code>d : X ‚ü∂ Z</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.t" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L164-L167">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></div></div><p>The inclusion of a summand in <code>‚àê <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L171-L174">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">Œπ_comp_t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.Œπ">Limits.Sigma.Œπ</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a> <span class="fn">d</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(‚Üë<span class="fn"><span class="fn">d</span>.<span class="fn">fst</span></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom">hom</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.Œπ">Limits.Sigma.Œπ</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a> <span class="fn">d</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L171-L171">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.Œπ_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">Œπ_comp_t_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ">D‚ÇÅ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.Œπ">Limits.Sigma.Œπ</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a> <span class="fn">d</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(‚Üë<span class="fn"><span class="fn">d</span>.<span class="fn">fst</span></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom">hom</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.Œπ">Limits.Sigma.Œπ</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a> <span class="fn">d</span>)</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L177-L180">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft">ŒπLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight">ŒπRight</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L177-L177">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÅ</span>.<span class="name">ŒπLeft_comp_t_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">‚àê</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">obj‚ÇÇ</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπLeft">ŒπLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.ŒπRight">ŒπRight</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.step"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L184-L195">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">step</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The intermediate object in the definition of the morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>.
It is the pushout of the following square:</p><pre><code class="language-lean">‚àê <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a> ‚ü∂ ‚àê <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a>
   |           |
   v           v
   Z      ‚ü∂   <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z
</code></pre><p>where the coproduct is taken over all the diagram consisting of a morphism <code>f : X ‚ü∂ Y</code>
satisfying <code>W</code> and a morphism <code>X ‚ü∂ Z</code>. The top map is the coproduct of all of these <code>f</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.step" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L197-L198">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toStep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The canonical map from <code>Z</code> to the pushout of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.t">D‚ÇÅ.t</a> W Z</code> and <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.l">D‚ÇÅ.l</a> W Z</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.toStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L200-L204">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u v)</div></div><p>The index type parametrising the data of two morphisms <code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code>, and
a map <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÇ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L206-L213">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape">Limits.MultispanShape</a></div></div><p>The shape of the multicoequalizer of all pairs of morphisms <code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L208-L208">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_snd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x‚úù</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ">D‚ÇÇ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.snd">snd</a></span> <span class="fn">x‚úù</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(</span><span class="fn">)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L208-L208">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_fst" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x‚úù</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ">D‚ÇÇ</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.fst">fst</a></span> <span class="fn">x‚úù</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(</span><span class="fn">)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_L"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L208-L208">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_L" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_L"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_L</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ">D‚ÇÇ</a> <span class="fn">W</span> <span class="fn">Z</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_R"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L208-L208">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_R" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape_R"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanShape_R</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.R">R</a></span> <span class="fn">=</span> <span class="fn">Unit</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallD‚ÇÇ"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L219-L221">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÇ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ">D‚ÇÇ</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L223-L223">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallLMultispanShape" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallLMultispanShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">D‚ÇÇ.multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.hasColimitsOfShape"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L226-L228">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.hasColimitsOfShape" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.hasColimitsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">hasColimitsOfShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfSize">Limits.HasColimitsOfSize.{w, w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfShape">Limits.HasColimitsOfShape</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.WalkingMultispan">Limits.WalkingMultispan</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>)</span> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L232-L239">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex">Limits.MultispanIndex</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">C</span></span></div></div><p>The diagram of the multicoequalizer of all pair of morphisms <code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L234-L234">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_left" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_left"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.left">left</a></span> <span class="fn">d</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(‚Üë<span class="fn"><span class="fn">d</span>.<span class="fn">fst</span></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.right">right</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L234-L234">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_fst" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.fst">fst</a></span> <span class="fn">d</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(‚Üë<span class="fn"><span class="fn">d</span>.<span class="fn">snd</span></span>)</span>.1</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L234-L234">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_snd" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.snd">snd</a></span> <span class="fn">d</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(‚Üë<span class="fn"><span class="fn">d</span>.<span class="fn">snd</span></span>)</span>.2</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L234-L234">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_right" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex_right"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">multispanIndex_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x‚úù</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.R">R</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.right">right</a></span> <span class="fn">x‚úù</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.succ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L243-L245">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The object <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is the multicoequalizer of all pairs of morphisms
<code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with a <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.succ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.fromStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L247-L250">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">fromStep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The projection from <code>Z</code> to the multicoequalizer of all morphisms <code>g‚ÇÅ g‚ÇÇ : Y ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ‚ü∂ Y</code> satisfying <code>W</code> such that <code>f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.fromStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L253-L258">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÇ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L253-L253">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D‚ÇÇ</span>.<span class="name">condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÇ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h‚úù</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h‚úù</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h‚úù</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L260-L261">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The morphism <code>Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.toSucc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc_injectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L264-L268">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_injectivity" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_injectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÇ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L272-L275">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_surjectivity" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_surjectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L278-L290">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L292-L293">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[deprecated CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc (since := &quot;2025-11-20&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">leftBousfieldW_isLocal_toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc">CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc</a></code>.</p></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L296-L319">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isIso_toSucc_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span> <span class="fn">Z</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.succStruct"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L330-L334">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succStruct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z‚ÇÄ</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration/Basic.html#CategoryTheory.SmallObject.SuccStruct">SmallObject.SuccStruct</a> <span class="fn">C</span></span></div></div><p>The successor structure of the orthogonal-reflection construction.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.succStruct" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.reflectionObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L339-L340">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflectionObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The transfinite iteration of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">succStruct</a> W Z</code> to the power <code>Œ∫.ord.ToType</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.reflectionObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.reflection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L342-L345">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span></span></div></div><p>The map which shall exhibit <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z Œ∫</code> as the image of <code>Z</code> by
the left adjoint of the inclusion of <code>W.isLocal</code>, see <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.corepresentableBy">corepresentableBy</a></code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.reflection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L347-L354">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">transfiniteCompositionOfShapeReflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/MorphismProperty/TransfiniteComposition.html#CategoryTheory.MorphismProperty.TransfiniteCompositionOfShape">TransfiniteCompositionOfShape</a></span> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span></span></div></div><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> W Z Œ∫ : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z Œ∫</code> is a transfinite
compositions of morphisms in <code>LeftBousfield.W W.isLocal</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L356-L359">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span></div></div><p>The functor <code>Œ∫.ord.ToType ‚•§ C</code> that is the diagram of the
transfinite composition <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection">transfiniteCompositionOfShapeReflection</a></code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.iteration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L365-L371">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iterationObjSuccIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span></span></div></div><p><code>(iteration W Z Œ∫).obj (Order.<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> j)</code> identifies to the image of
<code>(iteration W Z Œ∫).obj j</code> by <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a></code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.iterationObjSuccIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L373-L377">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso">iterationObjSuccIso</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span> <span class="fn">j</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L373-L373">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">toStep</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span>
      <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso">iterationObjSuccIso</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span> <span class="fn">j</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L380-L384">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_injectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g‚ÇÇ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÅ</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span>)</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g‚ÇÇ</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L387-L393">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_surjectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span>),
  <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span>)</span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L397-L400">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_reflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L408-L433">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_reflectionObj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_reflectionObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.corepresentableBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L436-L443">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.corepresentableBy" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.corepresentableBy"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">corepresentableBy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.Œπ">Œπ</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">Z</span>)</span>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.Functor.CorepresentableBy">CorepresentableBy</a></span> <a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory.mk">{</a> <span class="fn">obj</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">Œ∫</span></span>, <span class="fn">property</span> := <span class="fn">‚ãØ</span> <a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory.mk">}</a></span></div></div><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> W Z Œ∫ : Z ‚ü∂ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z Œ∫</code> exhibits <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z Œ∫</code>
as the image of <code>Z</code> by the left adjoint of the inclusion <code>W.isLocal.Œπ</code>.</p><details id="instances-for-list-CategoryTheory.OrthogonalReflection.corepresentableBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isRightAdjoint_Œπ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L447-L451">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isRightAdjoint_Œπ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isRightAdjoint_Œπ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isRightAdjoint_Œπ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÅ">D‚ÇÅ.obj‚ÇÅ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÅ.obj‚ÇÇ">D‚ÇÅ.obj‚ÇÇ</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D‚ÇÇ.multispanIndex">D‚ÇÇ.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.Œπ">Œπ</a></span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isRightAdjoint_Œπ_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L458-L468">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.MorphismProperty.isRightAdjoint_Œπ_isLocal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isRightAdjoint_Œπ_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isRightAdjoint_Œπ_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfSize">Limits.HasColimitsOfSize.{w, w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.Œπ">Œπ</a></span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L470-L477">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Presentable_OrthogonalReflection.html#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isLocallyPresentable_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ∫</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">Œ∫</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/LocallyPresentable.html#CategoryTheory.IsCardinalLocallyPresentable">IsCardinalLocallyPresentable</a> <span class="fn">C</span> <span class="fn">Œ∫</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>‚¶Ñ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">Œ∫</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">Œ∫</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/LocallyPresentable.html#CategoryTheory.IsCardinalLocallyPresentable">IsCardinalLocallyPresentable</a> <span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span> <span class="fn">Œ∫</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>