<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Skeletal</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Skeletal";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html">Mathlib.CategoryTheory.IsomorphismClasses</a></li><li><a href="../.././Mathlib/CategoryTheory/Thin.html">Mathlib.CategoryTheory.Thin</a></li><li><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html">Mathlib.CategoryTheory.Adjunction.Basic</a></li><li><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Skeletal" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeletal"><span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsSkeletonOf"><span class="name">CategoryTheory</span>.<span class="name">IsSkeletonOf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.eq_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">eq_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.functor_skeletal"><span class="name">CategoryTheory</span>.<span class="name">functor_skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeleton"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategorySkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCategorySkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instInhabitedSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCoeSortSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCoeSortSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFullSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFullSkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFaithfulSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instEssSurjSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instEssSurjSkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton.isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span>.<span class="name">isEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeletonToSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">fromSkeletonToSkeletonIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.preCounitIso"><span class="name">CategoryTheory</span>.<span class="name">preCounitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeleton.comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">comp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeleton.comp_hom_assoc"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">comp_hom_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeletonFunctor"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeletonFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeletonFunctor_map_hom"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor_map_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeleton_skeletal"><span class="name">CategoryTheory</span>.<span class="name">skeleton_skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeleton_isSkeleton"><span class="name">CategoryTheory</span>.<span class="name">skeleton_isSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeleton_fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_fromSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeleton_eq_toSkeleton_iff"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_eq_toSkeleton_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.congr_toSkeleton_of_iso"><span class="name">CategoryTheory</span>.<span class="name">congr_toSkeleton_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeleton.isoOfEq"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">isoOfEq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toSkeleton_eq_iff"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapSkeleton_obj_toSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_obj_toSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instFullSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFullSkeletonMapSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instFaithfulSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFaithfulSkeletonMapSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instEssSurjSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjSkeletonMapSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toSkeletonFunctorCompMapSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toSkeletonFunctorCompMapSkeletonIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapSkeleton_injective"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_injective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.mapSkeleton_surjective"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.skeletonEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">skeletonEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.mk"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.inhabitedThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">inhabitedThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.preorder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">preorder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thin"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thin</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">comp_toThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.mapNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇObjMap"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇObjMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇ_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map‚ÇÇ_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">toThinSkeleton_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.equivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_isEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.equiv_of_both_ways"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equiv_of_both_ways</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.skeletal"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_comp_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_comp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_id_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_id_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_iso_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_iso_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeletonCompToThinSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeletonCompToThinSkeletonIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.mapCompFromThinSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapCompFromThinSkeletonIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeleton_isSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">isSkeletonOfInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.lowerAdjunction"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">lowerAdjunction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.thinSkeletonOrderIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">thinSkeletonOrderIso</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Skeleton-of-a-category" class="markdown-heading">Skeleton of a category <a class="hover-link" href="#Skeleton-of-a-category">#</a></h1><p>Define skeletal categories as categories in which any two isomorphic objects are equal.</p><p>Construct the skeleton of an arbitrary category by taking isomorphism classes, and show it is a
skeleton of the original category.</p><p>In addition, construct the skeleton of a thin category as a partial ordering, and (noncomputably)
show it is a skeleton of the original category. The advantage of this special case being handled
separately is that lemmas and definitions about orderings can be used directly, for example for the
subobject lattice. In addition, some of the commutative diagrams about the functors commute
definitionally on the nose which is convenient in practice.</p></div><div class="decl" id="CategoryTheory.Skeletal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L41-L43">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Skeletal" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal"><span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A category is skeletal if isomorphic objects are equal.</p><details id="instances-for-list-CategoryTheory.Skeletal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsSkeletonOf"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L45-L52">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.IsSkeletonOf" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf"><span class="name">CategoryTheory</span>.<span class="name">IsSkeletonOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">IsSkeletonOf</a> C D F</code> says that <code>F : D ‚•§ C</code> exhibits <code>D</code> as a skeletal full subcategory of <code>C</code>,
in particular <code>F</code> is a (strong) equivalence and <code>D</code> is skeletal.</p><ul class="structure_fields" id="CategoryTheory.IsSkeletonOf.mk"><li id="CategoryTheory.IsSkeletonOf.skel" class="structure_field"><div class="structure_field_info">skel : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>The category <code>D</code> has isomorphic objects equal</p></div></li><li id="CategoryTheory.IsSkeletonOf.eqv" class="structure_field"><div class="structure_field_info">eqv : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div><div class="structure_field_doc"><p>The functor <code>F</code> is an equivalence</p></div></li></ul><details id="instances-for-list-CategoryTheory.IsSkeletonOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.eq_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L58-L61">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.eq_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">eq_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F‚ÇÅ </span><span class="fn">F‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hC</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn">F‚ÇÅ</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">F‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F‚ÇÅ</span> <span class="fn">=</span> <span class="fn">F‚ÇÇ</span></span></div></div><p>If <code>C</code> is thin and skeletal, then any naturally isomorphic functors to <code>C</code> are equal.</p></div></div><div class="decl" id="CategoryTheory.functor_skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L63-L67">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.functor_skeletal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.functor_skeletal"><span class="name">CategoryTheory</span>.<span class="name">functor_skeletal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hC</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span>)</span></span></div></div><p>If <code>C</code> is thin and skeletal, <code>D ‚•§ C</code> is skeletal.
<code><a href="../.././Mathlib/CategoryTheory/Thin.html#CategoryTheory.functor_thin">CategoryTheory.functor_thin</a></code> shows it is thin also.</p></div></div><div class="decl" id="CategoryTheory.Skeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L73-L80">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Skeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u‚ÇÅ</div></div><p>Construct the skeleton category as the induced category on the isomorphism classes, and derive
its category structure.</p><details id="instances-for-list-CategoryTheory.Skeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategorySkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L78-L78">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instCategorySkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instCategorySkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCategorySkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_1, u_2}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_1, u_2}</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instInhabitedSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L79-L79">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instInhabitedSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instInhabitedSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Inhabited</span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instCoeSortSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L80-L80">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instCoeSortSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instCoeSortSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCoeSortSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_3, u_1}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">CoeSort</span> <span class="fn">C</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">CoeSort</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span> <span class="fn">Œ±</span></span></div></div></div></div><div class="decl" id="CategoryTheory.fromSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L84-L87">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.fromSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span> <span class="fn">C</span></span></div></div><p>The functor from the skeleton of <code>C</code> to <code>C</code>.</p><details id="instances-for-list-CategoryTheory.fromSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.fromSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L85-L85">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.fromSkeleton_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X‚úù </span><span class="fn">Y‚úù</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory">InducedCategory</a> <span class="fn">C</span> <a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X‚úù</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.fromSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L85-L85">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.fromSkeleton_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn"><span class="fn">_root_.Quotient</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">isIsomorphicSetoid</a> <span class="fn">C</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">a‚úù</span>.<a href="../.././Mathlib/Data/Quot.html#Quotient.out">out</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.instFullSkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L94-L95">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instFullSkeletonFromSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instFullSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFullSkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.instFaithfulSkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L96-L97">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instFaithfulSkeletonFromSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instFaithfulSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.instEssSurjSkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L99-L99">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.instEssSurjSkeletonFromSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instEssSurjSkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instEssSurjSkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.fromSkeleton.isEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L101-L101">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.fromSkeleton.isEquivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton.isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span>.<span class="name">isEquivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.toSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L105-L106">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span></div></div><p>The class of an object in the skeleton.</p><details id="instances-for-list-CategoryTheory.toSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.fromSkeletonToSkeletonIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L108-L110">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">fromSkeletonToSkeletonIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">X</span></div></div><p>The isomorphism between <code>‚ü¶X‚üß.out</code> and <code>X</code>.</p><details id="instances-for-list-CategoryTheory.fromSkeletonToSkeletonIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.preCounitIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L112-L113">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.preCounitIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[deprecated CategoryTheory.fromSkeletonToSkeletonIso (since := &quot;2025-12-18&quot;)]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.preCounitIso"><span class="name">CategoryTheory</span>.<span class="name">preCounitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">X</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso">CategoryTheory.fromSkeletonToSkeletonIso</a></code>.</p><hr>
<p>The isomorphism between <code>‚ü¶X‚üß.out</code> and <code>X</code>.</p><details id="instances-for-list-CategoryTheory.preCounitIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Skeleton.comp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L115-L117">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Skeleton.comp_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton.comp_hom"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">comp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Skeleton.comp_hom_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L115-L115">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Skeleton.comp_hom_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton.comp_hom_assoc"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">comp_hom_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">Z</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.toSkeletonFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L121-L127">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeletonFunctor" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span></span></div></div><p>An inverse to <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> C</code> that forms an equivalence with it.</p><details id="instances-for-list-CategoryTheory.toSkeletonFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.toSkeletonFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L122-L122">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeletonFunctor_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor">toSkeletonFunctor</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.toSkeletonFunctor_map_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L122-L122">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeletonFunctor_map_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor_map_hom"><span class="name">CategoryTheory</span>.<span class="name">toSkeletonFunctor_map_hom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor">toSkeletonFunctor</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.Hom.hom">hom</a></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso">fromSkeletonToSkeletonIso</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso">fromSkeletonToSkeletonIso</a> <span class="fn">Y</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L129-L137">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeletonEquivalence" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">C</span></div></div><p>The equivalence between the skeleton and the category itself.</p><details id="instances-for-list-CategoryTheory.skeletonEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L130-L130">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeletonEquivalence_unitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_unitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence">skeletonEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.InducedCategory.isoMk">InducedCategory.isoMk</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">‚ãØ</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span>)</span> <span class="fn">‚ãØ</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L130-L130">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeletonEquivalence_counitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_counitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence">skeletonEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeletonToSkeletonIso">fromSkeletonToSkeletonIso</a> <span class="fn">‚ãØ</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L130-L130">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeletonEquivalence_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_inverse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence">skeletonEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor">toSkeletonFunctor</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L130-L130">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeletonEquivalence_functor" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence_functor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence">skeletonEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeleton_skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L139-L142">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeleton_skeletal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeleton_skeletal"><span class="name">CategoryTheory</span>.<span class="name">skeleton_skeletal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeleton_isSkeleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L144-L147">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.skeleton_isSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeleton_isSkeleton"><span class="name">CategoryTheory</span>.<span class="name">skeleton_isSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span></span></div></div><p>The <code>skeleton</code> of <code>C</code> given by choice is a skeleton of <code>C</code>.</p></div></div><div class="decl" id="CategoryTheory.toSkeleton_fromSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L151-L152">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeleton_fromSkeleton_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton_fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_fromSkeleton_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <span class="fn">=</span> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.toSkeleton_eq_toSkeleton_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L154-L155">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeleton_eq_toSkeleton_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton_eq_toSkeleton_iff"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_eq_toSkeleton_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">Y</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Nonempty</span> (<span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.congr_toSkeleton_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L157-L158">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.congr_toSkeleton_of_iso" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.congr_toSkeleton_of_iso"><span class="name">CategoryTheory</span>.<span class="name">congr_toSkeleton_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Skeleton.isoOfEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L160-L163">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Skeleton.isoOfEq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton.isoOfEq"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span>.<span class="name">isoOfEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">Y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">Y</span></div></div><p>Provides a (noncomputable) isomorphism <code>X ‚âÖ Y</code> given that <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> X = <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> Y</code>.</p><details id="instances-for-list-CategoryTheory.Skeleton.isoOfEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.toSkeleton_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L165-L167">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toSkeleton_eq_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton_eq_iff"><span class="name">CategoryTheory</span>.<span class="name">toSkeleton_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn">Y</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Nonempty</span> (<span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">fromSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L171-L173">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.mapSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">D</span>)</span></span></div></div><p>From a functor <code>C ‚•§ D</code>, construct a map of skeletons <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> C ‚Üí <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> D</code>.</p><details id="instances-for-list-CategoryTheory.Functor.mapSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapSkeleton_obj_toSkeleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L177-L179">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.mapSkeleton_obj_toSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton_obj_toSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_obj_toSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">X</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeleton">toSkeleton</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instFullSkeletonMapSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L181-L181">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.instFullSkeletonMapSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.instFullSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFullSkeletonMapSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instFaithfulSkeletonMapSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L183-L183">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.instFaithfulSkeletonMapSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.instFaithfulSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFaithfulSkeletonMapSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instEssSurjSkeletonMapSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L185-L185">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.instEssSurjSkeletonMapSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.instEssSurjSkeletonMapSkeleton"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjSkeletonMapSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toSkeletonFunctorCompMapSkeletonIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L188-L195">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.toSkeletonFunctorCompMapSkeletonIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.toSkeletonFunctorCompMapSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toSkeletonFunctorCompMapSkeletonIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor">toSkeletonFunctor</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toSkeletonFunctor">toSkeletonFunctor</a> <span class="fn">D</span>)</span></span></div></div><p>A natural isomorphism between <code>X ‚Ü¶ ‚ü¶X‚üß ‚Ü¶ ‚ü¶FX‚üß</code> and <code>X ‚Ü¶ FX ‚Ü¶ ‚ü¶FX‚üß</code>. On the level of
categories, these are <code>C ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> C ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> D</code> and <code>C ‚•§ D ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> D</code>. So this says that
the square formed by these 4 objects and 4 functors commutes.</p><details id="instances-for-list-CategoryTheory.Functor.toSkeletonFunctorCompMapSkeletonIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.mapSkeleton_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L197-L198">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.mapSkeleton_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton_injective"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Function.Injective</span> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.mapSkeleton_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L200-L201">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Functor.mapSkeleton_surjective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton_surjective"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">mapSkeleton_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Function.Surjective</span> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.mapSkeleton">mapSkeleton</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.skeletonEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L205-L212">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Equivalence.skeletonEquiv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Equivalence.skeletonEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">skeletonEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">‚âÉ</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a> <span class="fn">D</span></span></div></div><p>Two categories which are categorically equivalent have skeletons with equivalent objects.</p><details id="instances-for-list-CategoryTheory.Equivalence.skeletonEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L216-L221">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u‚ÇÅ</div></div><p>Construct the skeleton category by taking the quotient of objects. This construction gives a
preorder with nice definitional properties, but is only really appropriate for thin categories.
If your original category is not thin, you probably want to be using <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">Skeleton</a></code> instead of this.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L224-L225">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.mk" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.mk"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span></div></div><p>Convenience constructor for <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a></code>.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.inhabitedThinSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L227-L228">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.inhabitedThinSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.inhabitedThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">inhabitedThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Inhabited</span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.preorder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L230-L243">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.preorder" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.preorder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">preorder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.toThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L245-L249">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toThinSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div><p>The functor from a category to its thin skeleton.</p><details id="instances-for-list-CategoryTheory.toThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.toThinSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L246-L246">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toThinSkeleton_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X‚úù </span><span class="fn">Y‚úù</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X‚úù</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.toThinSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L246-L246">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.toThinSkeleton_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">c</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.mk">ThinSkeleton.mk</a> <span class="fn">c</span></span></span></div></div></div></div><div class="mod_doc"><p>The constructions here are intended to be used when the category <code>C</code> is thin, even though
some of the statements can be shown without this assumption.</p></div><div class="decl" id="CategoryTheory.ThinSkeleton.thin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L259-L263">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.thin" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thin"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thin</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div><p>The thin skeleton is thin.</p></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L267-L271">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">D</span>)</span></span></div></div><p>A functor <code>C ‚•§ D</code> computably lowers to a functor <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> D</code>.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L268-L268">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn"><span class="fn">_root_.Quotient</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">isIsomorphicSetoid</a> <span class="fn">C</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">‚ãØ</span> <span class="fn">a‚úù</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L268-L268">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn">Quotient.recOnSubsingleton‚ÇÇ</span> (motive := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>) =&gt;
    <span class="fn">(<span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">x_1</span>) ‚Üí (<span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">‚ãØ</span> <span class="fn">x</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">‚ãØ</span> <span class="fn">x_1</span></span>)</span></span>) <span class="fn">X</span> <span class="fn">Y</span>
    <span class="fn">(fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">C</span>) (<span class="fn">k</span> : <span class="fn"><span class="fn">‚ü¶</span><span class="fn">x</span><span class="fn">‚üß</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn">‚ü¶</span><span class="fn">x_1</span><span class="fn">‚üß</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">‚ãØ</span></span>)</span> <span class="fn">a‚úù</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L273-L274">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.comp_toThinSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">comp_toThinSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">D</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.mapNatTrans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L276-L278">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.mapNatTrans" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.mapNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F‚ÇÅ </span><span class="fn">F‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">F‚ÇÅ</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">F‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F‚ÇÅ</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F‚ÇÇ</span></span></div></div><p>Given a natural transformation <code>F‚ÇÅ ‚ü∂ F‚ÇÇ</code>, induce a natural transformation <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F‚ÇÅ ‚ü∂ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F‚ÇÇ</code>.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.mapNatTrans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇObjMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L291-L296">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇObjMap" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇObjMap"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇObjMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">D</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">E</span></span></span></span></div></div><p>Given a bifunctor, we descend to a function on objects of <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a></code></p><details id="instances-for-list-CategoryTheory.ThinSkeleton.map‚ÇÇObjMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L298-L305">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">D</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">E</span>)</span></span></span></div></div><p>For each <code>x : <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C</code>, we promote <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇObjMap">map‚ÇÇObjMap</a> F x</code> to a functor</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.map‚ÇÇFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L307-L314">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">x‚ÇÅ</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">x‚ÇÇ</span>) ‚Üí (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor">map‚ÇÇFunctor</a> <span class="fn">F</span> <span class="fn">x‚ÇÅ</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor">map‚ÇÇFunctor</a> <span class="fn">F</span> <span class="fn">x‚ÇÇ</span></span>)</span></div></div><p>This provides natural transformations <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor">map‚ÇÇFunctor</a> F x‚ÇÅ ‚ü∂ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor">map‚ÇÇFunctor</a> F x‚ÇÇ</code> given
<code>x‚ÇÅ ‚ü∂ x‚ÇÇ</code></p><details id="instances-for-list-CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L317-L322">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">D</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">E</span>)</span>)</span></span></div></div><p>A functor <code>C ‚•§ D ‚•§ E</code> computably lowers to a functor
<code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> D ‚•§ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> E</code></p><details id="instances-for-list-CategoryTheory.ThinSkeleton.map‚ÇÇ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇ_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L319-L319">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X‚úù </span><span class="fn">Y‚úù</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn">X‚úù</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y‚úù</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ">map‚ÇÇ</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇNatTrans">map‚ÇÇNatTrans</a> <span class="fn">F</span> <span class="fn">a‚úù</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map‚ÇÇ_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L319-L319">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map‚ÇÇ_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇ">map‚ÇÇ</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map‚ÇÇFunctor">map‚ÇÇFunctor</a> <span class="fn">F</span> <span class="fn">a‚úù</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L330-L330">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.toThinSkeleton_faithful" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">toThinSkeleton_faithful</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L332-L338">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span> <span class="fn">C</span></span></div></div><p>Use <code><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a></code> to create a functor out of the thin skeleton.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.fromThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L333-L333">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn"><span class="fn">_root_.Quotient</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">isIsomorphicSetoid</a> <span class="fn">C</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">a‚úù</span>.<a href="../.././Mathlib/Data/Quot.html#Quotient.out">out</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L333-L333">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚úù</span> : <span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">a‚úù</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn">Quotient.recOnSubsingleton‚ÇÇ</span> (motive := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span>) =&gt;
    <span class="fn">(<span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">x_1</span>) ‚Üí (<span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">x</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">x_1</span></span>)</span></span>) <span class="fn">x</span> <span class="fn">y</span>
    <span class="fn">(fun (<span class="fn">X</span> <span class="fn">Y</span> : <span class="fn">C</span>) (<span class="fn">f</span> : <span class="fn"><span class="fn">‚ü¶</span><span class="fn">X</span><span class="fn">‚üß</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn"><span class="fn">‚ü¶</span><span class="fn">Y</span><span class="fn">‚üß</span></span>) =&gt;
      <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">‚ãØ</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">‚ãØ</span>)</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">‚ãØ</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span>)</span>
    <span class="fn">a‚úù</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.equivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L340-L346">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.equivalence" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">C</span></div></div><p>The equivalence between the thin skeleton and the category itself.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L348-L349">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_isEquivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.equiv_of_both_ways"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L353-L354">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.equiv_of_both_ways" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equiv_of_both_ways"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equiv_of_both_ways</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <span class="fn">‚âà</span> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L356-L362">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonPartialOrder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L364-L365">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.skeletal" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.skeletal"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">skeletal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">Skeletal</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_comp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L367-L369">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map_comp_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_comp_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_comp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÉ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÉ, u‚ÇÉ}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">G</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_id_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L371-L373">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map_id_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_id_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_id_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_iso_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L375-L378">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.map_iso_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_iso_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_iso_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F‚ÇÅ </span><span class="fn">F‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">F‚ÇÅ</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn">F‚ÇÇ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F‚ÇÇ</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeletonCompToThinSkeletonIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L380-L387">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeletonCompToThinSkeletonIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeletonCompToThinSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeletonCompToThinSkeletonIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a> <span class="fn">D</span>)</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span></span></div></div><p>Applying <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a></code>, <code>F</code> and then <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">toThinSkeleton</a></code> is isomorphic to applying <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F</code>.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.fromThinSkeletonCompToThinSkeletonIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.mapCompFromThinSkeletonIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L389-L397">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.mapCompFromThinSkeletonIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.mapCompFromThinSkeletonIso"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapCompFromThinSkeletonIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">D</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">‚âÖ</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span></div></div><p>Applying <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F</code> and then <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a></code> is isomorphic to first applying <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a></code>
and then applying <code>F</code>.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.mapCompFromThinSkeletonIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L399-L401">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeleton_isSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeleton_isSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> C</code> exhibits the thin skeleton as a skeleton.</p></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L403-L405">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.isSkeletonOfInhabited" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">isSkeletonOfInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> <span class="fn">C</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.lowerAdjunction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L411-L422">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.ThinSkeleton.lowerAdjunction" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.lowerAdjunction"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">lowerAdjunction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÇ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÇ, u‚ÇÇ}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">L</span></span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">‚ä£</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> <span class="fn">R</span></span></div></div><p>An adjunction between thin categories gives an adjunction between their thin skeletons.</p><details id="instances-for-list-CategoryTheory.ThinSkeleton.lowerAdjunction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.thinSkeletonOrderIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Skeletal.lean#L432-L438">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Skeletal.html#CategoryTheory.Equivalence.thinSkeletonOrderIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Equivalence.thinSkeletonOrderIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">thinSkeletonOrderIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u‚ÇÅ}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v‚ÇÅ, u‚ÇÅ}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">‚âå</a> <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Order/Hom/Basic.html#OrderIso">‚âÉo</a> <span class="fn">Œ±</span></div></div><p>When <code>e : C ‚âå Œ±</code> is a categorical equivalence from a thin category <code>C</code> to some partial order <code>Œ±</code>,
the <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C</code> is order isomorphic to <code>Œ±</code>.</p><details id="instances-for-list-CategoryTheory.Equivalence.thinSkeletonOrderIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>