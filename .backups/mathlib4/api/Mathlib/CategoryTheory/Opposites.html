<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Opposites</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Opposites";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Opposites</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/Equivalence.html">Mathlib.CategoryTheory.Equivalence</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Opposites" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.op_inj"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">op_inj</span></a></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.unop_inj"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_inj</span></a></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.unop_op"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_op</span></a></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.unop_op'"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_op'</span></a></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.op_unop"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">op_unop</span></a></div><div class="nav_link"><a class="break_within" href="#Quiver.Hom.unop_mk"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CategoryStruct.opposite"><span class="name">CategoryTheory</span>.<span class="name">CategoryStruct</span>.<span class="name">opposite</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unop_id"><span class="name">CategoryTheory</span>.<span class="name">unop_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_id_unop"><span class="name">CategoryTheory</span>.<span class="name">op_id_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_comp"><span class="name">CategoryTheory</span>.<span class="name">op_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_id"><span class="name">CategoryTheory</span>.<span class="name">op_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unop_comp"><span class="name">CategoryTheory</span>.<span class="name">unop_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unop_id_op"><span class="name">CategoryTheory</span>.<span class="name">unop_id_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_comp_unop"><span class="name">CategoryTheory</span>.<span class="name">op_comp_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Category.opposite"><span class="name">CategoryTheory</span>.<span class="name">Category</span>.<span class="name">opposite</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">op_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unop_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">unop_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unopUnop"><span class="name">CategoryTheory</span>.<span class="name">unopUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unopUnop_map"><span class="name">CategoryTheory</span>.<span class="name">unopUnop_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unopUnop_obj"><span class="name">CategoryTheory</span>.<span class="name">unopUnop_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOp"><span class="name">CategoryTheory</span>.<span class="name">opOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOp_map"><span class="name">CategoryTheory</span>.<span class="name">opOp_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOp_obj"><span class="name">CategoryTheory</span>.<span class="name">opOp_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOpEquivalence"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOpEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOpEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOpEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opOpEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsEquivalenceOppositeOpOp"><span class="name">CategoryTheory</span>.<span class="name">instIsEquivalenceOppositeOpOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsEquivalenceOppositeUnopUnop"><span class="name">CategoryTheory</span>.<span class="name">instIsEquivalenceOppositeUnopUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isIso_op"><span class="name">CategoryTheory</span>.<span class="name">isIso_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isIso_of_op"><span class="name">CategoryTheory</span>.<span class="name">isIso_of_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isIso_op_iff"><span class="name">CategoryTheory</span>.<span class="name">isIso_op_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isIso_unop_iff"><span class="name">CategoryTheory</span>.<span class="name">isIso_unop_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isIso_unop"><span class="name">CategoryTheory</span>.<span class="name">isIso_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.op_inv"><span class="name">CategoryTheory</span>.<span class="name">op_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">unop_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.op"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.op_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.op_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unop"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unop_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unop_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opHom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opHom_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opHom_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opInv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opInv_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.unopId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOp_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_map_unop"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_map_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instFullOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFullOppositeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instFaithfulOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFaithfulOppositeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.FullyFaithful.op"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_faithful"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOp_faithful"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_full"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_full</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOp_full"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_full</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.FullyFaithful.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">leftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.FullyFaithful.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">rightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpLeftOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpLeftOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOpLeftOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.rightOp_leftOp_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_leftOp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_whiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerRight_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.op_whiskerLeft_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerLeft_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_whiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerRight_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.unop_whiskerLeft_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerLeft_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeUnop"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeUnop_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeUnop_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOp_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOpWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOpWhiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.leftOpWhiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOpWhiskerRight_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeLeftOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeLeftOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOp_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOpWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOpWhiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.rightOpWhiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOpWhiskerRight_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeRightOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeRightOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatTrans.removeRightOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_hom"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_inv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_hom"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_op"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_unop"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_refl"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_trans"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.op_symm"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_refl"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_trans"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_symm"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_hom_inv_id_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom_inv_id_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_hom_inv_id_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom_inv_id_app_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_inv_hom_id_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv_hom_id_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.unop_inv_hom_id_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv_hom_id_app_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_refl"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_trans"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_symm"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.removeOp"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.removeOp_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.removeOp_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_refl"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_trans"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_symm"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_isoWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_isoWhiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_isoWhiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_isoWhiskerLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_whiskerRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_whiskerLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_leftUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_leftUnitor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_rightUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_rightUnitor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.op_associator"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_associator</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_leftUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_leftUnitor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_rightUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_rightUnitor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.NatIso.unop_associator"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_associator</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.op"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.op_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.op_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.op_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.op_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unop"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unop_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unop_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unop_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unop_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_functor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_inverse_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_functor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_inverse_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.leftOp_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_functor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_inverse_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_inverse_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_functor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.rightOp_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opEquiv"><span class="name">CategoryTheory</span>.<span class="name">opEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opEquiv_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">opEquiv_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.opEquiv_apply"><span class="name">CategoryTheory</span>.<span class="name">opEquiv_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.subsingleton_of_unop"><span class="name">CategoryTheory</span>.<span class="name">subsingleton_of_unop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.decidableEqOfUnop"><span class="name">CategoryTheory</span>.<span class="name">decidableEqOfUnop</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isoOpEquiv"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isoOpEquiv_apply"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isoOpEquiv_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv_symm_apply</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopEquiv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.opUnopEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_inverse_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_inverse_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_obj_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_hom_app_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_counitIso_hom_app_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_functor_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_map_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_inv_app_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_counitIso_inv_app_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_obj_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instEssSurjOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instEssSurjOppositeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeRightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instEssSurjOppositeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeLeftOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceOppositeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeRightOp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceOppositeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeLeftOp</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Opposite-categories" class="markdown-heading">Opposite categories <a class="hover-link" href="#Opposite-categories">#</a></h1><p>We provide a category instance on <code>C</code>.
The morphisms <code>X  Y</code> are defined to be the morphisms <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a> Y  <a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a> X</code> in <code>C</code>.</p><p>Here <code>C</code> is an irreducible typeclass synonym for <code>C</code>
(it is the same one used in the algebra library).</p><p>We also provide various mechanisms for constructing opposite morphisms, functors,
and natural transformations.</p><p>Unfortunately, because we do not have a definitional equality <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a> (op X) = X</code>,
there are quite a few variations that are needed in practice.</p></div><div class="decl" id="Quiver.Hom.op_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L39-L41">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.op_inj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.op_inj"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">op_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Function.Injective</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></div></div></div></div><div class="decl" id="Quiver.Hom.unop_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L43-L45">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.unop_inj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.unop_inj"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Function.Injective</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></div></div></div></div><div class="decl" id="Quiver.Hom.unop_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L47-L49">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.unop_op" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.unop_op"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Quiver.Hom.unop_op'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L51-L53">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.unop_op'" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.unop_op'"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_op'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Quiver.Hom.op_unop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L55-L57">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.op_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.op_unop"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">op_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Quiver.Hom.unop_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L59-L60">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#Quiver.Hom.unop_mk" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#Quiver.Hom.unop_mk"><span class="name">Quiver</span>.<span class="name">Hom</span>.<span class="name">unop_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CategoryStruct.opposite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L70-L73">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.CategoryStruct.opposite" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.CategoryStruct.opposite"><span class="name">CategoryTheory</span>.<span class="name">CategoryStruct</span>.<span class="name">opposite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The opposite <code>CategoryStruct</code>.</p></div></div><div class="decl" id="CategoryTheory.unop_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L75-L77">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unop_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unop_id"><span class="name">CategoryTheory</span>.<span class="name">unop_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.op_id_unop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L79-L81">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_id_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_id_unop"><span class="name">CategoryTheory</span>.<span class="name">op_id_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.op_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L83-L85">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_comp"><span class="name">CategoryTheory</span>.<span class="name">op_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.op_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L87-L89">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_id"><span class="name">CategoryTheory</span>.<span class="name">op_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unop_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L91-L93">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unop_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unop_comp"><span class="name">CategoryTheory</span>.<span class="name">unop_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unop_id_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L95-L97">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unop_id_op" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unop_id_op"><span class="name">CategoryTheory</span>.<span class="name">unop_id_op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.op_comp_unop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L100-L101">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_comp_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_comp_unop"><span class="name">CategoryTheory</span>.<span class="name">op_comp_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryStruct.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Category.opposite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L109-L115">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Category.opposite" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Category.opposite"><span class="name">CategoryTheory</span>.<span class="name">Category</span>.<span class="name">opposite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The opposite category.</p></div></div><div class="decl" id="CategoryTheory.op_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L119-L121">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_comp_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">op_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z'</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z'</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unop_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L123-L125">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unop_comp_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unop_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">unop_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z'</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z'</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unopUnop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L131-L135">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unopUnop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop"><span class="name">CategoryTheory</span>.<span class="name">unopUnop</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">C</span></span></div></div><p>The functor from the double-opposite of a category to the underlying category.</p><details id="instances-for-list-CategoryTheory.unopUnop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.unopUnop_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L132-L132">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unopUnop_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop_map"><span class="name">CategoryTheory</span>.<span class="name">unopUnop_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unopUnop_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L132-L132">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unopUnop_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop_obj"><span class="name">CategoryTheory</span>.<span class="name">unopUnop_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L137-L141">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp"><span class="name">CategoryTheory</span>.<span class="name">opOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The functor from a category to its double-opposite.</p><details id="instances-for-list-CategoryTheory.opOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.opOp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L138-L138">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOp_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp_map"><span class="name">CategoryTheory</span>.<span class="name">opOp_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOp_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L138-L138">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOp_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp_obj"><span class="name">CategoryTheory</span>.<span class="name">opOp_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOpEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L143-L149">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOpEquivalence" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">C</span></div></div><p>The double opposite category is equivalent to the original.</p><details id="instances-for-list-CategoryTheory.opOpEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.opOpEquivalence_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L144-L144">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOpEquivalence_counitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence_counitIso"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_counitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence">opOpEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOpEquivalence_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L144-L144">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOpEquivalence_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_inverse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence">opOpEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOpEquivalence_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L144-L144">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOpEquivalence_unitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence_unitIso"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_unitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence">opOpEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opOpEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L144-L144">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opOpEquivalence_functor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">opOpEquivalence_functor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence">opOpEquivalence</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsEquivalenceOppositeOpOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L151-L152">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.instIsEquivalenceOppositeOpOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.instIsEquivalenceOppositeOpOp"><span class="name">CategoryTheory</span>.<span class="name">instIsEquivalenceOppositeOpOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsEquivalenceOppositeUnopUnop"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L154-L155">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.instIsEquivalenceOppositeUnopUnop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.instIsEquivalenceOppositeUnopUnop"><span class="name">CategoryTheory</span>.<span class="name">instIsEquivalenceOppositeUnopUnop</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isIso_op"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L159-L161">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isIso_op" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isIso_op"><span class="name">CategoryTheory</span>.<span class="name">isIso_op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div><p>If <code>f</code> is an isomorphism, so is <code>f.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code></p></div></div><div class="decl" id="CategoryTheory.isIso_of_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L163-L167">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isIso_of_op" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isIso_of_op"><span class="name">CategoryTheory</span>.<span class="name">isIso_of_op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span></div></div><p>If <code>f.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> is an isomorphism <code>f</code> must be too.
(This cannot be an instance as it would immediately loop!)</p></div></div><div class="decl" id="CategoryTheory.isIso_op_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L169-L170">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isIso_op_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isIso_op_iff"><span class="name">CategoryTheory</span>.<span class="name">isIso_op_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span> <span class="fn"></span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.isIso_unop_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L172-L173">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isIso_unop_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isIso_unop_iff"><span class="name">CategoryTheory</span>.<span class="name">isIso_unop_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span> <span class="fn"></span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.isIso_unop"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L175-L176">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isIso_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isIso_unop"><span class="name">CategoryTheory</span>.<span class="name">isIso_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.op_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L178-L181">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.op_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.op_inv"><span class="name">CategoryTheory</span>.<span class="name">op_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.inv">inv</a> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.inv">inv</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.unop_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L183-L186">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.unop_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">unop_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.inv">inv</a> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.inv">inv</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L194-L199">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The opposite of a functor, i.e. considering a functor <code>F : C  D</code> as a functor <code>C  D</code>.
In informal mathematics no distinction is made between these.</p><details id="instances-for-list-CategoryTheory.Functor.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.op_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L196-L196">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.op_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.op_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L196-L196">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.op_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">op_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L201-L207">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span></div></div><p>Given a functor <code>F : C  D</code> we can take the &quot;unopposite&quot; functor <code>F : C  D</code>.
In informal mathematics no distinction is made between these.</p><details id="instances-for-list-CategoryTheory.Functor.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.unop_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L204-L204">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unop_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unop_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L204-L204">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unop_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unop_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L209-L212">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">F</span></div></div><p>The isomorphism between <code>F.op.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code> and <code>F</code>.</p><details id="instances-for-list-CategoryTheory.Functor.opUnopIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opUnopIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L210-L210">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso">opUnopIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L210-L210">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso">opUnopIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopOpIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L214-L217">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopOpIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">F</span></div></div><p>The isomorphism between <code>F.unop.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> and <code>F</code>.</p><details id="instances-for-list-CategoryTheory.Functor.unopOpIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.unopOpIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L215-L215">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopOpIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso">unopOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopOpIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L215-L215">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopOpIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopOpIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso">unopOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L221-L228">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opHom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span></div></div><p>Taking the opposite of a functor is functorial.</p><details id="instances-for-list-CategoryTheory.Functor.opHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opHom_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L223-L223">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opHom_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom">opHom</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opHom_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L223-L223">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opHom_map_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opHom_map_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom">opHom</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L230-L238">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opInv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>Take the &quot;unopposite&quot; of a functor is functorial.</p><details id="instances-for-list-CategoryTheory.Functor.opInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opInv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L232-L232">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opInv_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv">opInv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">Quiver.Hom.op</a> <a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.mk">{</a> <span class="fn">app</span> := <span class="fn">fun (<span class="fn">X</span> : <span class="fn">C</span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span>, <span class="fn">naturality</span> := <span class="fn"></span> <a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.mk">}</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opInv_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L232-L232">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opInv_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opInv_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv">opInv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L246-L248">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opComp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">Functor.op</a></code> with respect to functor composition.</p><details id="instances-for-list-CategoryTheory.Functor.opComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L247-L247">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opComp_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L247-L247">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opComp_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L250-L252">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopComp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">Functor.unop</a></code> with respect to functor composition.</p><details id="instances-for-list-CategoryTheory.Functor.unopComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.unopComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L251-L251">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopComp_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L251-L251">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopComp_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L255-L257">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opId" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">Functor.op</a></code> transforms identity functors to identity functors.</p><details id="instances-for-list-CategoryTheory.Functor.opId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opId_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L256-L256">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opId_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId_hom_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId">opId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opId_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L256-L256">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opId_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opId_inv_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId">opId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L260-L262">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopId" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">Functor.unop</a></code> transforms identity functors to identity functors.</p><details id="instances-for-list-CategoryTheory.Functor.unopId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.unopId_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L261-L261">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopId_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId_inv_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId">unopId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.unopId_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L261-L261">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.unopId_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">unopId_hom_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId">unopId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L266-L273">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span></div></div><p>Another variant of the opposite of functor, turning a functor <code>C  D</code> into a functor <code>C  D</code>.
In informal mathematics no distinction is made.</p><details id="instances-for-list-CategoryTheory.Functor.leftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.leftOp_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L270-L270">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOp_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L270-L270">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOp_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L275-L282">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>Another variant of the opposite of functor, turning a functor <code>C  D</code> into a functor <code>C  D</code>.
In informal mathematics no distinction is made.</p><details id="instances-for-list-CategoryTheory.Functor.rightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L279-L279">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L279-L279">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_map_unop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L284-L285">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_map_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_map_unop"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_map_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instFullOppositeOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L287-L288">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instFullOppositeOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instFullOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFullOppositeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instFaithfulOppositeOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L290-L291">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instFaithfulOppositeOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instFaithfulOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instFaithfulOppositeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.FullyFaithful.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L293-L295">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.FullyFaithful.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.FullyFaithful.op"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The opposite of a fully faithful functor is fully faithful.</p><details id="instances-for-list-CategoryTheory.Functor.FullyFaithful.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L297-L299">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_faithful" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_faithful"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div><p>If F is faithful then the right_op of F is also faithful.</p></div></div><div class="decl" id="CategoryTheory.Functor.leftOp_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L301-L303">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOp_faithful" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp_faithful"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div><p>If F is faithful then the left_op of F is also faithful.</p></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_full"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L305-L306">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_full" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_full"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_full</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOp_full"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L308-L309">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOp_full" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp_full"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOp_full</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.FullyFaithful.leftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L311-L314">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.FullyFaithful.leftOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.FullyFaithful.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">leftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The opposite of a fully faithful functor is fully faithful.</p><details id="instances-for-list-CategoryTheory.Functor.FullyFaithful.leftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.FullyFaithful.rightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L316-L319">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.FullyFaithful.rightOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.FullyFaithful.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">FullyFaithful</span>.<span class="name">rightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The opposite of a fully faithful functor is fully faithful.</p><details id="instances-for-list-CategoryTheory.Functor.FullyFaithful.rightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOpComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L321-L325">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpComp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">Functor.rightOp</a></code> with respect to functor composition.</p><details id="instances-for-list-CategoryTheory.Functor.rightOpComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOpComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L322-L322">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpComp_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOpComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L322-L322">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpComp_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L327-L331">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpComp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span></span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">Functor.leftOp</a></code> with respect to functor composition.</p><details id="instances-for-list-CategoryTheory.Functor.leftOpComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.leftOpComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L328-L328">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpComp_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L328-L328">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpComp_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOpId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L336-L338">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpId" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a> <span class="fn">C</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">Functor.rightOp</a></code> sends identity functors to the canonical isomorphism <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOp">opOp</a></code>.</p><details id="instances-for-list-CategoryTheory.Functor.rightOpId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOpId_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L337-L337">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpId_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId_hom_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpId">rightOpId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOpId_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L337-L337">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpId_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpId_inv_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpId">rightOpId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L340-L342">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpId" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpId"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a> <span class="fn">C</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">Functor.leftOp</a></code> sends identity functors to the canonical isomorphism <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.unopUnop">unopUnop</a></code>.</p><details id="instances-for-list-CategoryTheory.Functor.leftOpId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.leftOpId_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L341-L341">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpId_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpId_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId_hom_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpId">leftOpId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpId_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L341-L341">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpId_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpId_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpId_inv_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpId">leftOpId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L346-L349">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">F</span></div></div><p>The isomorphism between <code>F.leftOp.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></code> and <code>F</code>.</p><details id="instances-for-list-CategoryTheory.Functor.leftOpRightOpIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L347-L347">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpIso">leftOpRightOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L347-L347">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpIso">leftOpRightOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOpLeftOpIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L351-L354">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">F</span></div></div><p>The isomorphism between <code>F.rightOp.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></code> and <code>F</code>.</p><details id="instances-for-list-CategoryTheory.Functor.rightOpLeftOpIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.rightOpLeftOpIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L352-L352">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso">rightOpLeftOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOpLeftOpIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L352-L352">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOpLeftOpIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso">rightOpLeftOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.rightOp_leftOp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L356-L360">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.rightOp_leftOp_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp_leftOp_eq"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">rightOp_leftOp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <span class="fn">=</span> <span class="fn">F</span></span></div></div><p>Whenever possible, it is advisable to use the isomorphism <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso">rightOpLeftOpIso</a></code>
instead of this equality of functors.</p></div></div><div class="decl" id="CategoryTheory.NatTrans.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L374-L378">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></div></div><p>The opposite of a natural transformation.</p><details id="instances-for-list-CategoryTheory.NatTrans.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.op_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L375-L375">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L380-L382">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L384-L387">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L384-L384">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_comp_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_whiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L389-L393">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_whiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_whiskerRight_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L389-L389">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_whiskerRight_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_whiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerRight_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_whiskerLeft"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L395-L399">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_whiskerLeft" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.op_whiskerLeft_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L395-L395">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.op_whiskerLeft_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op_whiskerLeft_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">op_whiskerLeft_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"></span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L401-L405">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></div></div><p>The &quot;unopposite&quot; of a natural transformation.</p><details id="instances-for-list-CategoryTheory.NatTrans.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L402-L402">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L407-L409">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L411-L414">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L411-L411">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_comp_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_whiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L416-L421">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_whiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_whiskerRight_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L416-L416">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_whiskerRight_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_whiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerRight_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_whiskerLeft"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L423-L428">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_whiskerLeft" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.unop_whiskerLeft_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L423-L423">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.unop_whiskerLeft_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop_whiskerLeft_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">unop_whiskerLeft_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"></span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L430-L437">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">F</span></div></div><p>Given a natural transformation <code> : F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a>  G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code>,
we can take the &quot;unopposite&quot; of each component obtaining a natural transformation <code>G  F</code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.removeOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.removeOp_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L433-L433">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeOp_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">NatTrans.removeOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeOp_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L439-L441">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeOp_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeOp_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">NatTrans.removeOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeUnop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L443-L449">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeUnop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">F</span></div></div><p>Given a natural transformation <code> : F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code>, we can take the opposite of each
component obtaining a natural transformation <code>G  F</code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.removeUnop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.removeUnop_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L445-L445">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeUnop_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">NatTrans.removeUnop</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeUnop_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L451-L453">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeUnop_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeUnop_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeUnop">NatTrans.removeUnop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L461-L467">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span></div></div><p>Given a natural transformation <code> : F  G</code>, for <code>F G : C  D</code>,
taking <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code> of each component gives a natural transformation <code>G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a>  F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.leftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOp_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L464-L464">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOp_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOp_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L469-L471">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOp_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOp_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L473-L476">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOp_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOp_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOpWhiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L478-L482">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOpWhiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOpWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOpWhiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.leftOpWhiskerRight_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L478-L478">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.leftOpWhiskerRight_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOpWhiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">leftOpWhiskerRight_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn"></span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerLeft">whiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpComp">leftOpComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeLeftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L484-L491">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeLeftOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">F</span></div></div><p>Given a natural transformation <code> : F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a>  G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></code>, for <code>F G : C  D</code>,
taking <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> of each component gives a natural transformation <code>G  F</code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.removeLeftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.removeLeftOp_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L487-L487">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeLeftOp_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp">NatTrans.removeLeftOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeLeftOp_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L493-L495">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeLeftOp_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeLeftOp_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeLeftOp">NatTrans.removeLeftOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L503-L509">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span></div></div><p>Given a natural transformation <code> : F  G</code>, for <code>F G : C  D</code>,
taking <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> of each component gives a natural transformation <code>G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a>  F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.rightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOp_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L506-L506">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOp_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">x</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOp_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L511-L513">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOp_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOp_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L515-L518">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOp_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp_comp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOp_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn"></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn"></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOpWhiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L520-L524">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOpWhiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOpWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOpWhiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.rightOpWhiskerRight_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L520-L520">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.rightOpWhiskerRight_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOpWhiskerRight_assoc"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">rightOpWhiskerRight_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskerRight">Functor.whiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.rightOp">NatTrans.rightOp</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpComp">rightOpComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeRightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L526-L533">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeRightOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">F</span></div></div><p>Given a natural transformation <code> : F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a>  G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></code>, for <code>F G : C  D</code>,
taking <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code> of each component gives a natural transformation <code>G  F</code>.</p><details id="instances-for-list-CategoryTheory.NatTrans.removeRightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatTrans.removeRightOp_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L529-L529">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeRightOp_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp_app"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">NatTrans.removeRightOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatTrans.removeRightOp_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L535-L537">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatTrans.removeRightOp_id" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp_id"><span class="name">CategoryTheory</span>.<span class="name">NatTrans</span>.<span class="name">removeRightOp_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeRightOp">NatTrans.removeRightOp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L547-L554">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">Y</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span></div></div><p>The opposite isomorphism.</p><details id="instances-for-list-CategoryTheory.Iso.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.op_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L549-L549">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_hom"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L549-L549">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_inv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L556-L562">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">Y</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span></span></div></div><p>The isomorphism obtained from an isomorphism in the opposite category.</p><details id="instances-for-list-CategoryTheory.Iso.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.unop_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L557-L557">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_hom"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L557-L557">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L564-L565">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_op" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_op"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op_unop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L567-L568">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_unop"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L571-L572">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_refl" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_refl"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">refl</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">refl</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L574-L577">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_trans"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">Y</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"></span>).<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.op_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L579-L580">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.op_symm" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op_symm"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">op_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L582-L583">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_refl" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_refl"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">refl</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">refl</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L585-L588">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_trans"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">Y</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"></span>).<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L590-L591">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_symm" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_symm"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_hom_inv_id_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L597-L599">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_hom_inv_id_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_hom_inv_id_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom_inv_id_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_hom_inv_id_app_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L597-L597">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_hom_inv_id_app_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_hom_inv_id_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_hom_inv_id_app_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_inv_hom_id_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L601-L603">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_inv_hom_id_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_inv_hom_id_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv_hom_id_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.unop_inv_hom_id_app_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L601-L601">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Iso.unop_inv_hom_id_app_assoc" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop_inv_hom_id_app_assoc"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">unop_inv_hom_id_app_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L614-L621">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></div></div><p>The natural isomorphism between opposite functors <code>G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a>  F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> induced by a natural
isomorphism between the original functors <code>F  G</code>.</p><details id="instances-for-list-CategoryTheory.NatIso.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatIso.op_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L616-L616">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L616-L616">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.op">NatTrans.op</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L623-L624">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_refl" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_refl"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L626-L629">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_trans"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> (<span class="fn"></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"></span>)</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L631-L632">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_symm" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_symm"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.removeOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L635-L640">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.removeOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.removeOp"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">F</span></div></div><p>The natural isomorphism between functors <code>G  F</code> induced by a natural isomorphism
between the opposite functors <code>F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a>  G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code>.</p><details id="instances-for-list-CategoryTheory.NatIso.removeOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatIso.removeOp_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L637-L637">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.removeOp_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.removeOp_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.removeOp">NatIso.removeOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">NatTrans.removeOp</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.removeOp_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L637-L637">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.removeOp_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.removeOp_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">removeOp_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.removeOp">NatIso.removeOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.removeOp">NatTrans.removeOp</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L642-L647">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></div></div><p>The natural isomorphism between functors <code>G.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  F.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code> induced by a natural isomorphism
between the original functors <code>F  G</code>.</p><details id="instances-for-list-CategoryTheory.NatIso.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.NatIso.unop_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L644-L644">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_hom" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_hom"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L644-L644">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_inv" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_inv"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.unop">NatTrans.unop</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L649-L650">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_refl" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_refl"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">F</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L652-L655">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_trans" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_trans"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G </span><span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> (<span class="fn"></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"></span>)</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L657-L658">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_symm" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_symm"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_isoWhiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L660-L663">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_isoWhiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_isoWhiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_isoWhiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_isoWhiskerLeft"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L665-L668">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_isoWhiskerLeft" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_isoWhiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_isoWhiskerLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_whiskerRight"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L670-L674">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_whiskerRight" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_whiskerRight"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_whiskerRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"></span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span>)</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_whiskerLeft"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L676-L680">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_whiskerLeft" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_whiskerLeft"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_whiskerLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"></span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_leftUnitor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L682-L687">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_leftUnitor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_leftUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_leftUnitor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId">Functor.opId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_rightUnitor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L689-L694">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_rightUnitor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_rightUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_rightUnitor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opId">Functor.opId</a> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span>)</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.op_associator"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L696-L702">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.op_associator" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op_associator"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">op_associator</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E'</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_2, u_2}</a> <span class="fn">E'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">E'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn">G</span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a>     <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a>       <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opComp">opComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_leftUnitor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L704-L709">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_leftUnitor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_leftUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_leftUnitor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId">Functor.unopId</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_rightUnitor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L711-L716">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_rightUnitor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_rightUnitor"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_rightUnitor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopId">Functor.unopId</a> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.NatIso.unop_associator"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L718-L724">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.NatIso.unop_associator" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop_associator"><span class="name">CategoryTheory</span>.<span class="name">NatIso</span>.<span class="name">unop_associator</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E'</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_1, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v_2, u_2}</a> <span class="fn">E'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">E'</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn">G</span> <span class="fn">H</span>)</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a>     <span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a>       <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a>         <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans"></a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopComp">unopComp</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.op"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L733-L743">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.op" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></div></div><p>An equivalence between categories gives an equivalence between the opposite categories.</p><details id="instances-for-list-CategoryTheory.Equivalence.op" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.op_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L735-L735">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.op_unitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.op_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L735-L735">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.op_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.op_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L735-L735">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.op_counitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.op">NatIso.op</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.op_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L735-L735">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.op_functor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">op_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L746-L756">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.unop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span></div></div><p>An equivalence between opposite categories gives an equivalence between the original categories.</p><details id="instances-for-list-CategoryTheory.Equivalence.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unop_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L748-L748">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.unop_counitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unop_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L748-L748">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.unop_functor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unop_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L748-L748">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.unop_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unop_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L748-L748">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.unop_unitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unop_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatIso.unop">NatIso.unop</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L758-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span></div></div><p>An equivalence between <code>C</code> and <code>D</code> gives an equivalence between <code>C</code> and <code>D</code>.</p><details id="instances-for-list-CategoryTheory.Equivalence.leftOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_unitIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_functor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_functor_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_functor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_inverse_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_inverse_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_inverse_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_counitIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_functor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_functor_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_functor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_inverse_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_inverse_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_inverse_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_unitIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.leftOp_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L759-L759">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.leftOp_counitIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">leftOp_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L761-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></div></div><p>An equivalence between <code>C</code> and <code>D</code> gives an equivalence between <code>C</code> and <code>D</code>.</p><details id="instances-for-list-CategoryTheory.Equivalence.rightOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_unitIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_functor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_functor_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_functor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_functor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_inverse_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_inverse_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_inverse_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_inverse_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_inverse_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_inverse_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_counitIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_unitIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_functor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_functor_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_functor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_functor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.rightOp_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L762-L762">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Equivalence.rightOp_counitIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">rightOp_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L766-L783">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opEquiv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv"><span class="name">CategoryTheory</span>.<span class="name">opEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">B</span>) <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv"></a> (<span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</div></div><p>The equivalence between arrows of the form <code>A  B</code> and <code>B.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  A.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code>. Useful for building
adjunctions.
Note that this (definitionally) gives variants</p><pre><code>def opEquiv' (A : C) (B : C) : (Opposite.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a> A  B)  (B.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  A) :=
  <a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv">opEquiv</a> _ _

def opEquiv'' (A : C) (B : C) : (A  <a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> B)  (B  A.unop) :=
  <a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv">opEquiv</a> _ _

def opEquiv''' (A B : C) : (Opposite.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a> A  <a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> B)  (B  A) :=
  <a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv">opEquiv</a> _ _
</code></pre><details id="instances-for-list-CategoryTheory.opEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.opEquiv_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L780-L780">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opEquiv_symm_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">opEquiv_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv">opEquiv</a> <span class="fn">A</span> <span class="fn">B</span>)</span>.<a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv.symm">symm</a></span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.opEquiv_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L780-L780">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.opEquiv_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv_apply"><span class="name">CategoryTheory</span>.<span class="name">opEquiv_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opEquiv">opEquiv</a> <span class="fn">A</span> <span class="fn">B</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.subsingleton_of_unop"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L785-L786">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.subsingleton_of_unop" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.subsingleton_of_unop"><span class="name">CategoryTheory</span>.<span class="name">subsingleton_of_unop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> (<span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Subsingleton</span> (<span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">B</span>)</span></div></div></div></div><div class="decl" id="CategoryTheory.decidableEqOfUnop"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L788-L789">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.decidableEqOfUnop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.decidableEqOfUnop"><span class="name">CategoryTheory</span>.<span class="name">decidableEqOfUnop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> (<span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">DecidableEq</span> (<span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">B</span>)</span></div></div></div></div><div class="decl" id="CategoryTheory.isoOpEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L791-L801">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isoOpEquiv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isoOpEquiv"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">A</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">B</span>) <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv"></a> (<span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</div></div><p>The equivalence between isomorphisms of the form <code>A  B</code> and <code>B.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  A.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code>.</p><p>Note this is definitionally the same as the other three variants:</p><ul><li><code>(Opposite.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a> A  B)  (B.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a>  A)</code></li><li><code>(A  <a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> B)  (B  A.unop)</code></li><li><code>(Opposite.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a> A  <a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> B)  (B  A)</code></li></ul><details id="instances-for-list-CategoryTheory.isoOpEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.isoOpEquiv_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L798-L798">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isoOpEquiv_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isoOpEquiv_apply"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">A</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn">B</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isoOpEquiv">isoOpEquiv</a> <span class="fn">A</span> <span class="fn">B</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.unop">unop</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.isoOpEquiv_symm_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L798-L798">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.isoOpEquiv_symm_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isoOpEquiv_symm_apply"><span class="name">CategoryTheory</span>.<span class="name">isoOpEquiv_symm_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A </span><span class="fn">B</span> : <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">B</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso"></a> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">A</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.isoOpEquiv">isoOpEquiv</a> <span class="fn">A</span> <span class="fn">B</span>)</span>.<a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv.symm">symm</a></span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L808-L822">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopEquiv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The equivalence of functor categories induced by <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></code> and <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unop">unop</a></code>.</p><details id="instances-for-list-CategoryTheory.Functor.opUnopEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.opUnopEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L810-L810">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopEquiv_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_inverse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv">opUnopEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opInv">opInv</a> <span class="fn">C</span> <span class="fn">D</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L810-L810">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopEquiv_unitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_unitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv">opUnopEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>) =&gt; <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopIso">opUnopIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Iso.op">op</a></span>)</span> <span class="fn"></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L810-L810">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopEquiv_counitIso" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_counitIso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv">opUnopEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>) =&gt; <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.unopOpIso">unopOpIso</a></span>)</span> <span class="fn"></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.opUnopEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L810-L810">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.opUnopEquiv_functor" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">opUnopEquiv_functor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opUnopEquiv">opUnopEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.opHom">opHom</a> <span class="fn">C</span> <span class="fn">D</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L824-L842">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"></a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span></div></div><p>The equivalence of functor categories induced by <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></code> and <code><a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></code>.</p><details id="instances-for-list-CategoryTheory.Functor.leftOpRightOpEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_inverse_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_inverse_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.NatTrans.leftOp">NatTrans.leftOp</a> <span class="fn"></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_inverse_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_inverse_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_inverse_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_inv_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_unitIso_inv_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso">rightOpLeftOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_obj" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_obj"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_obj_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_hom_app_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_hom_app_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_hom_app_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_counitIso_hom_app_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_functor_map_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_map_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_map_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_map_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn"></span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"></span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.unop">unop</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">x</span>)</span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_inv_app_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_inv_app_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_inv_app_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_counitIso_inv_app_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">X</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_hom_app" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_unitIso_hom_app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">X</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOpLeftOpIso">rightOpLeftOpIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L826-L826">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_map" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">leftOpRightOpEquiv_functor_obj_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span>)</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom"></a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOpRightOpEquiv">leftOpRightOpEquiv</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/Data/Opposite.html#Opposite.unop">Opposite.unop</a> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span>)</span>.<a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op">op</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instEssSurjOppositeOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L844-L845">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instEssSurjOppositeOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instEssSurjOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instEssSurjOppositeRightOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L847-L848">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instEssSurjOppositeRightOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instEssSurjOppositeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeRightOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instEssSurjOppositeLeftOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L850-L851">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instEssSurjOppositeLeftOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instEssSurjOppositeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instEssSurjOppositeLeftOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceOppositeOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L853-L853">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.op">op</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceOppositeRightOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L855-L855">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeRightOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeRightOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeRightOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.rightOp">rightOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceOppositeLeftOp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Opposites.lean#L857-L857">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_CategoryTheory_Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeLeftOp" class="verification-badge mathematical" title="Mathematical property (specification layer)"> coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.instIsEquivalenceOppositeLeftOp"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceOppositeLeftOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span><a href="../.././Mathlib/Data/Opposite.html#Opposite"></a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Functor.leftOp">leftOp</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>