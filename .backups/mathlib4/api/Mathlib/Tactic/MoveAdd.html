<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.MoveAdd</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.MoveAdd";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MoveAdd</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Lean/Meta.html">Mathlib.Lean.Meta</a></li><li><a href="../.././Mathlib/Tactic/ToAdditive.html">Mathlib.Tactic.ToAdditive</a></li><li><a href="../.././Mathlib/Tactic/ToDual.html">Mathlib.Tactic.ToDual</a></li><li><a href="../.././Mathlib/Algebra/Group/Basic.html">Mathlib.Algebra.Group.Basic</a></li><li><a href="../.././Mathlib/Order/Defs/LinearOrder.html">Mathlib.Order.Defs.LinearOrder</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.MoveAdd" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Expr.getExprInputs"><span class="name">Lean</span>.<span class="name">Expr</span>.<span class="name">getExprInputs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Expr.size"><span class="name">Lean</span>.<span class="name">Expr</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.uniquify"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">uniquify</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.weight"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">weight</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.reorderUsing"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">reorderUsing</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.prepareOp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">prepareOp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.sumList"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">sumList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.getAddends"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">getAddends</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.getOps"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">getOps</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.rankSums"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">rankSums</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.permuteExpr"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">permuteExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.pairUp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">pairUp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.moveOperSimpCtx"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">moveOperSimpCtx</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.reorderAndSimp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">reorderAndSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.unifyMovements"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">unifyMovements</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.parseArrows"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">parseArrows</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.moveOperTac"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">moveOperTac</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.tacticMove_add_"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">tacticMove_add_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.MoveAdd.tacticMove_mul_"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">tacticMove_mul_</span></a></div></nav><main>
<div class="mod_doc"><h1 id="move-add-a-tactic-for-moving-summands-in-expressions" class="markdown-heading"><code>move_add</code> a tactic for moving summands in expressions <a class="hover-link" href="#move-add-a-tactic-for-moving-summands-in-expressions">#</a></h1><p>The tactic <code>move_add</code> rearranges summands in expressions.</p><p>The tactic takes as input a list of terms, each one optionally preceded by <code>‚Üê</code>.
A term preceded by <code>‚Üê</code> gets moved to the left, while a term without <code>‚Üê</code> gets moved to the right.</p><ul><li><p>Empty input: <code>move_add []</code></p><p>In this case, the effect of <code>move_add []</code> is equivalent to <code>simp only [‚Üê add_assoc]</code>:
essentially the tactic removes all visible parentheses.</p></li><li><p>Singleton input: <code>move_add [a]</code> and <code>move_add [‚Üê a]</code></p><p>If <code>‚ä¢ b + a + c</code> is (a summand in) the goal, then</p><ul><li><code>move_add [‚Üê a]</code> changes the goal to <code>a + b + c</code> (effectively, <code>a</code> moved to the left).</li><li><code>move_add [a]</code> changes the goal to <code>b + c + a</code> (effectively, <code>a</code> moved to the right);</li></ul><p>The tactic reorders <em>all</em> sub-expressions of the target at the same time.
For instance, if <code>‚ä¢ 0 &lt; if b + a &lt; b + a + c then a + b else b + a</code> is the goal, then</p><ul><li><code>move_add [a]</code> changes the goal to <code>0 &lt; if b + a &lt; b + c + a then b + a else b + a</code>
(<code>a</code> moved to the right in three sums);</li><li><code>move_add [‚Üê a]</code> changes the goal to <code>0 &lt; if a + b &lt; a + b + c then a + b else a + b</code>
(<code>a</code> again moved to the left in three sums).</li></ul></li><li><p>Longer inputs: <code>move_add [..., a, ..., ‚Üê b, ...]</code></p><p>If the list contains more than one term, the tactic effectively tries to move each term preceded
by <code>‚Üê</code> to the left, each term not preceded by <code>‚Üê</code> to the right
<em>maintaining the relative order in the call</em>.
Thus, applying <code>move_add [a, b, c, ‚Üê d, ‚Üê e]</code> returns summands of the form
<code>d + e + [...] + a + b + c</code>, i.e. <code>d</code> and <code>e</code> have the same relative position in the input list
and in the final rearrangement (and similarly for <code>a, b, c</code>).
In particular, <code>move_add [a, b]</code> likely has the same effect as
<code>move_add [a]; move_add [b]</code>: first, we move <code>a</code> to the right, then we move <code>b</code> also to the
right, <em>after</em> <code>a</code>.
However, if the terms matched by <code>a</code> and <code>b</code> do not overlap, then <code>move_add [‚Üê a, ‚Üê b]</code>
has the same effect as <code>move_add [b]; move_add [a]</code>:
first, we move <code>b</code> to the left, then we move <code>a</code> also to the left, <em>before</em> <code>a</code>.
The behaviour in the situation where <code>a</code> and <code>b</code> overlap is unspecified: <code>move_add</code>
will descend into subexpressions, but the order in which they are visited depends
on which rearrangements have already happened.
Also note, though, that <code>move_add [a, b]</code> may differ <code>move_add [a]; move_add [b]</code>,
for instance when <code>a</code> and <code>b</code> are <code>DefEq</code>.</p></li><li><p>Unification of inputs and repetitions: <code>move_add [_, ‚Üê _, a * _]</code></p><p>The matching of the user inputs with the atoms of the summands in the target expression
is performed via checking <code>DefEq</code> and selecting the first, still available match.
Thus, if a sum in the target is <code>2 * 3 + 4 * (5 + 6) + 4 * 7 + 10 * 10</code>, then
<code>move_add [4 * _]</code> moves the summand <code>4 * (5 + 6)</code> to the right.</p><p>The unification of later terms only uses the atoms in the target that have not yet been unified.
Thus, if again the target contains <code>2 * 3 + 4 * (5 + 6) + 4 * 7 + 10 * 10</code>, then
<code>move_add [_, ‚Üê _, 4 * _]</code>
matches</p><ul><li>the first input (<code>_</code>) with <code>2 * 3</code>;</li><li>the second input (<code>_</code>) with <code>4 * (5 + 6)</code>;</li><li>the third input (<code>4 * _</code>) with <code>4 * 7</code>.</li></ul><p>The resulting permutation therefore places <code>2 * 3</code> and <code>4 * 7</code> to the left (in this order) and
<code>4 * (5 + 6)</code> to the right: <code>2 * 3 + 4 * 7 + 10 * 10 + 4 * (5 + 6)</code>.</p></li></ul><p>For the technical description, look at <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">Mathlib.MoveAdd.weight</a></code> and <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">Mathlib.MoveAdd.reorderUsing</a></code>.</p><p><code>move_add</code> is the specialization of a more general <code>move_oper</code> tactic that takes a binary,
associative, commutative operation and a list of &quot;operand atoms&quot; and rearranges the operation.</p><h2 id="Extension-notes" class="markdown-heading">Extension notes <a class="hover-link" href="#Extension-notes">#</a></h2><p>To work with a general associative, commutative binary operation, <code>move_oper</code>
needs to have inbuilt the lemmas asserting the analogues of
<code>add_comm, add_assoc, <a href="../.././Mathlib/Algebra/Group/Basic.html#add_left_comm">add_left_comm</a></code> for the new operation.
Currently, <code>move_oper</code> supports <code>HAdd.hAdd</code>, <code>HMul.hMul</code>, <code>And</code>, <code>Or</code>, <code><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Max.max">Max.max</a></code>, <code><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Min.min">Min.min</a></code>.</p><p>These lemmas should be added to <code>Mathlib.MoveAdd.move_oper_simpCtx</code>.</p><p>See <code><a href="../.././MathlibTest/MoveAdd.html">MathlibTest/MoveAdd.lean</a></code> for sample usage of <code>move_oper</code>.</p><h2 id="Implementation-notes" class="markdown-heading">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The main driver behind the tactic is <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp">Mathlib.MoveAdd.reorderAndSimp</a></code>.</p><p>The tactic takes the target, replaces the maximal subexpressions whose head symbol is the given
operation and replaces them by their reordered versions.
Once that is done, it tries to replace the initial goal with the permuted one by using <code>simp</code>.</p><p>Currently, no attempt is made at guiding <code>simp</code> by doing a <code>congr</code>-like destruction of the goal.
This will be the content of a later PR.</p></div><div class="decl" id="Lean.Expr.getExprInputs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L111-L120">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Lean.Expr.getExprInputs" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Lean.Expr.getExprInputs"><span class="name">Lean</span>.<span class="name">Expr</span>.<span class="name">getExprInputs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Expr</span> ‚Üí <span class="fn"><span class="fn">Array</span> <span class="fn">Expr</span></span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Lean.Expr.getExprInputs">getExprInputs</a> e</code> inspects the outermost constructor of <code>e</code> and returns the array of all the
arguments to that constructor that are themselves <code>Expr</code>essions.</p><details id="instances-for-list-Lean.Expr.getExprInputs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Expr.size"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L122-L124">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Lean.Expr.size" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[deprecated Lean.Expr.sizeWithoutSharing (since := &quot;2025-09-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Lean.Expr.size"><span class="name">Lean</span>.<span class="name">Expr</span>.<span class="name">size</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Ñï</span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Lean.Expr.size">size</a> e</code> returns the number of subexpressions of <code>e</code>.</p></div></div><div class="mod_doc"><h2 id="Reordering-the-variables" class="markdown-heading">Reordering the variables <a class="hover-link" href="#Reordering-the-variables">#</a></h2><p>This section produces the permutations of the variables for <code>move_add</code>.</p><p>The user controls the final order by passing a list of terms to the tactic.
Each term can be preceded by <code>‚Üê</code> or not.
In the final ordering,</p><ul><li>terms preceded by <code>‚Üê</code> appear first,</li><li>terms not preceded by <code>‚Üê</code> appear last,</li><li>all remaining terms remain in their current relative order.</li></ul></div><div class="decl" id="Mathlib.MoveAdd.uniquify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L146-L157">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.uniquify" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.uniquify"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">uniquify</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">BEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">‚Ñï</span>)</span></span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.uniquify">uniquify</a> L</code> takes a list <code>L : List Œ±</code> as input and it returns a list <code>L' : List (Œ± √ó ‚Ñï)</code>.
The two lists <code>L</code> and <code>L'.map <a href="../.././Mathlib/Order/Interval/Basic.html#Prod.fst">Prod.fst</a></code> coincide.
The second component of each entry <code>(a, n)</code> in <code>L'</code> is the number of times that <code>a</code> appears in <code>L</code>
before the current location.</p><p>The resulting list of pairs has no duplicates.</p><details id="instances-for-list-Mathlib.MoveAdd.uniquify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.weight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L159-L180">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.weight" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">weight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">BEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Ñ§</span></div></div><p>Return a sorting key so that all <code>(a, true)</code>s are in the list's order
and sorted before all <code>(a, false)</code>s, which are also in the list's order.
Although <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a></code> does not require this, we use <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a></code> in the case where the list obtained
from <code>L</code> by only keeping the first component (i.e. <code>L.map <a href="../.././Mathlib/Order/Interval/Basic.html#Prod.fst">Prod.fst</a></code>) has no duplicates.
The properties that we mention here assume that this is the case.</p><p>Thus, <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L</code> is a function <code>Œ± ‚Üí ‚Ñ§</code> with the following properties:</p><ul><li>if <code>(a, true)  ‚àà L</code>, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L a</code> is strictly negative;</li><li>if <code>(a, false) ‚àà L</code>, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L a</code> is strictly positive;</li><li>if neither <code>(a, true)</code> nor <code>(a, false)</code> is in <code>L</code>, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L a = 0</code>.</li></ul><p>Moreover, the function <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L</code> is strictly monotone increasing on both
<code>{a : Œ± | (a, true) ‚àà L}</code> and <code>{a : Œ± | (a, false) ‚àà L}</code>,
in the sense that if <code>a' = (a, true)</code> and <code>b' = (b, true)</code> are in <code>L</code>,
then <code>a'</code> appears before <code>b'</code> in <code>L</code> if and only if <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L a &lt; <a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.weight">weight</a> L b</code> and
similarly for the pairs with second coordinate equal to <code>false</code>.</p><details id="instances-for-list-Mathlib.MoveAdd.weight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.reorderUsing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L182-L208">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.reorderUsing" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">reorderUsing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">BEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">toReorder</span> : <span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">instructions</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">reorderUsing</a> toReorder instructions</code> produces a reordering of <code>toReorder : List Œ±</code>,
following the requirements imposed by <code>instructions : List (Œ± √ó Bool)</code>.</p><p>These are the requirements:</p><ul><li>elements of <code>toReorder</code> that appear with <code>true</code> in <code>instructions</code> appear at the
<em>beginning</em> of the reordered list, in the order in which they appear in <code>instructions</code>;</li><li>similarly, elements of <code>toReorder</code> that appear with <code>false</code> in <code>instructions</code> appear at the
<em>end</em> of the reordered list, in the order in which they appear in <code>instructions</code>;</li><li>finally, elements of <code>toReorder</code> that do not appear in <code>instructions</code> appear &quot;in the middle&quot;
with the order that they had in <code>toReorder</code>.</li></ul><p>For example,</p><ul><li><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">reorderUsing</a> [0, 1, 2] [(0, false)] = [1, 2, 0]</code>,</li><li><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">reorderUsing</a> [0, 1, 2] [(1, true)] = [1, 0, 2]</code>,</li><li><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">reorderUsing</a> [0, 1, 2] [(1, true), (0, false)] = [1, 2, 0]</code>.</li></ul><details id="instances-for-list-Mathlib.MoveAdd.reorderUsing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.prepareOp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L212-L224">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.prepareOp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.prepareOp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">prepareOp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sum</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Expr</span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.prepareOp">prepareOp</a> sum</code> takes an <code>Expr</code>ession as input.  It assumes that <code>sum</code> is a well-formed
term representing a repeated application of a binary operation and that the summands are the
last two arguments passed to the operation.
It returns the expression consisting of the operation with all its arguments already applied,
except for the last two.
This is similar to <code>Lean.Meta.mkAdd, Lean.Meta.mkMul</code>, except that the resulting operation is
primed to work with operands of the same type as the ones already appearing in <code>sum</code>.</p><p>This is useful to rearrange the operands.</p><details id="instances-for-list-Mathlib.MoveAdd.prepareOp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.sumList"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L226-L244">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.sumList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.sumList"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">sumList</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">prepOp</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">left_assoc?</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Lean.Expr</span></span> ‚Üí <span class="fn">Lean.Expr</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.sumList">sumList</a> prepOp left_assoc? exs</code> assumes that <code>prepOp</code> is an <code>Expr</code>ession representing a
binary operation already fully applied up until its last two arguments and assumes that the
last two arguments are the operands of the operation.
Such an expression is the result of <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.prepareOp">prepareOp</a></code>.</p><p>If <code>exs</code> is the list <code>[e‚ÇÅ, e‚ÇÇ, ..., e‚Çô]</code> of <code>Expr</code>essions, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.sumList">sumList</a> prepOp left_assoc? exs</code>
returns</p><ul><li><code>prepOp (prepOp( ... prepOp (prepOp e‚ÇÅ e‚ÇÇ) e‚ÇÉ) ... e‚Çô)</code>, if <code>left_assoc?</code> is <code>false</code>, and</li><li><code>prepOp e‚ÇÅ (prepOp e‚ÇÇ (... prepOp (prepOp e‚Çô‚Çã‚ÇÅ  e‚Çô))</code>, if <code>left_assoc?</code> is <code>true</code>.</li></ul></div></div><div class="decl" id="Mathlib.MoveAdd.getAddends"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L253-L260">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.getAddends" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getAddends"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">getAddends</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">R </span><span class="fn">sum</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Array</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>If <code>sum</code> is an expression consisting of repeated applications of <code>op</code>, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getAddends">getAddends</a></code>
returns the Array of those recursively determined arguments whose type is DefEq to <code>R</code>.</p></div></div><div class="decl" id="Mathlib.MoveAdd.getOps"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L262-L272">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.getOps" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getOps"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">getOps</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sum</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Array</span> <span class="fn">(<span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Expr</span></span> <span class="fn">√ó</span> <span class="fn">Lean.Expr</span>)</span>)</span></span></div></div><p>Recursively compute the Array of <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.getAddends">getAddends</a></code> Arrays by recursing into the expression <code>sum</code>
looking for instance of the operation <code>op</code>.</p><p>Possibly returns duplicates!</p></div></div><div class="decl" id="Mathlib.MoveAdd.rankSums"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L274-L295">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.rankSums" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.rankSums"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">rankSums</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tgt</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">instructions</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Lean.Expr</span>)</span>)</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.rankSums">rankSums</a> op tgt instructions</code> takes as input</p><ul><li>the name <code>op</code> of a binary operation,</li><li>an <code>Expr</code>ession <code>tgt</code>,</li><li>a list <code>instructions</code> of pair <code>(expression, Boolean)</code>.</li></ul><p>It extracts the maximal subexpressions of <code>tgt</code> whose head symbol is <code>op</code>
(i.e. the maximal subexpressions that consist only of applications of the binary operation <code>op</code>),
it rearranges the operands of such subexpressions following the order implied by <code>instructions</code>
(as in <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderUsing">reorderUsing</a></code>),
it returns the list of pairs of expressions <code>(old_sum, new_sum)</code>, for which <code>old_sum ‚â† new_sum</code>
sorted by decreasing value of <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Lean.Expr.size">Lean.Expr.size</a></code>.
In particular, a subexpression of an <code>old_sum</code> can only appear <em>after</em> its over-expression.</p><details id="instances-for-list-Mathlib.MoveAdd.rankSums" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.permuteExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L297-L308">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.permuteExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">permuteExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tgt</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">instructions</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr">permuteExpr</a> op tgt instructions</code> takes the same input as <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.rankSums">rankSums</a></code> and returns the
expression obtained from <code>tgt</code> by replacing all <code>old_sum</code>s by the corresponding <code>new_sum</code>.
If there were no required changes, then <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr">permuteExpr</a></code> reports this in its second factor.</p><details id="instances-for-list-Mathlib.MoveAdd.permuteExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.pairUp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L310-L340">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.pairUp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.pairUp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">pairUp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn"><span class="fn">Bool</span> <span class="fn">√ó</span> <span class="fn">Lean.Syntax</span></span>)</span></span> ‚Üí
  <span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Lean.Expr</span></span> ‚Üí <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span> <span class="fn">√ó</span> <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn"><span class="fn">Bool</span> <span class="fn">√ó</span> <span class="fn">Lean.Syntax</span></span>)</span></span>)</span></span></span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.pairUp">pairUp</a> L R</code> takes to lists <code>L R : List Expr</code> as inputs.
It scans the elements of <code>L</code>, looking for a corresponding <code>DefEq</code> <code>Expr</code>ession in <code>R</code>.
If it finds one such element <code>d</code>, then it sets the element <code>d : R</code> aside, removing it from <code>R</code>, and
it continues with the matching on the remainder of <code>L</code> and on <code>R.erase d</code>.</p><p>At the end, it returns the sublist of <code>R</code> of the elements that were matched to some element of <code>R</code>,
in the order in which they appeared in <code>L</code>,
as well as the sublist of <code>L</code> of elements that were not matched, also in the order in which they
appeared in <code>L</code>.</p><p>Example:</p><pre><code class="language-lean">#eval do
  let L := [mkNatLit 0, (‚Üê mkFreshExprMVar (some (mkConst ``Nat))), mkNatLit 0] -- i.e. [0, _, 0]
  let R := [mkNatLit 0, mkNatLit 0,                                 mkNatLit 1] -- i.e. [0, 1]
  dbg_trace f!&quot;{(‚Üê <a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.pairUp">pairUp</a> L R)}&quot;
/- output:
`([0, 0], [0])`
the output LHS list `[0, 0]` consists of the first `0` and the `MVarId`.
the output RHS list `[0]` corresponds to the last `0` in `L`.
-/
</code></pre><details id="instances-for-list-Mathlib.MoveAdd.pairUp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.moveOperSimpCtx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L342-L356">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.moveOperSimpCtx" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperSimpCtx"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">moveOperSimpCtx</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Meta.Simp.Context</span></span></div></div><p><code>move_oper_simpCtx</code> is the <code>Simp.Context</code> for the reordering internal to <code>move_oper</code>.
To support a new binary operation, extend the list in this definition, so that it contains
enough lemmas to allow <code>simp</code> to close a generic permutation goal for the new binary operation.</p><details id="instances-for-list-Mathlib.MoveAdd.moveOperSimpCtx" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.reorderAndSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L358-L380">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">reorderAndSimp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mv</span> : <span class="fn">Lean.MVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">instr</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">List</span> <span class="fn">Lean.MVarId</span>)</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.reorderAndSimp">reorderAndSimp</a> mv op instr</code> takes as input an <code>MVarId</code>  <code>mv</code>, the name <code>op</code> of a binary
operation and a list of &quot;instructions&quot; <code>instr</code> that it passes to <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.permuteExpr">permuteExpr</a></code>.</p><ul><li>It creates a version <code>permuted_mv</code> of <code>mv</code> with subexpressions representing <code>op</code>-sums reordered
following <code>instructions</code>.</li><li>It produces 2 temporary goals by applying <code>Eq.mpr</code> and unifying the resulting meta-variable with
<code>permuted_mv</code>: <code>[‚ä¢ mv = permuted_mv, ‚ä¢ permuted_mv]</code>.</li><li>It tries to solve the goal <code>mv = permuted_mv</code> by a simple-minded <code>simp</code> call, using the
<code>op</code>-analogues of <code>add_comm, add_assoc, <a href="../.././Mathlib/Algebra/Group/Basic.html#add_left_comm">add_left_comm</a></code>.</li></ul><details id="instances-for-list-Mathlib.MoveAdd.reorderAndSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.unifyMovements"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L382-L405">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.unifyMovements" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.unifyMovements"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">unifyMovements</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">op</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">data</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn"><span class="fn">Bool</span> <span class="fn">√ó</span> <span class="fn">Lean.Syntax</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tgt</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn">Bool</span>)</span></span> <span class="fn">√ó</span> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">List</span> <span class="fn">Lean.MessageData</span></span> <span class="fn">√ó</span> <span class="fn"><span class="fn">List</span> <span class="fn">Lean.Syntax</span></span>)</span> <span class="fn">√ó</span> <span class="fn"><span class="fn">Array</span> <span class="fn">Lean.MessageData</span></span></span>)</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.unifyMovements">unifyMovements</a></code> takes as input</p><ul><li>an array of <code>Expr √ó Bool √ó Syntax</code>, as in the output of <code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.parseArrows">parseArrows</a></code>,</li><li>the <code>Name</code> <code>op</code> of a binary operation,</li><li>an <code>Expr</code>ession <code>tgt</code>.
It unifies each <code>Expr</code>ession appearing as a first factor of the array with the atoms
for the operation <code>op</code> in the expression <code>tgt</code>, returning</li><li>the lists of pairs of a matched subexpression with the corresponding <code>Bool</code>ean;</li><li>a pair of a list of error messages and the corresponding list of Syntax terms where the error
should be thrown;</li><li>an array of debugging messages.</li></ul><details id="instances-for-list-Mathlib.MoveAdd.unifyMovements" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.parseArrows"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L410-L425">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.parseArrows" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.parseArrows"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">parseArrows</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Lean.TSyntax</span> <span class="fn">`Lean.Parser.Tactic.rwRuleSeq</span></span> ‚Üí <span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">(<span class="fn">Array</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">√ó</span> <span class="fn"><span class="fn">Bool</span> <span class="fn">√ó</span> <span class="fn">Lean.Syntax</span></span>)</span>)</span></span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.parseArrows">parseArrows</a></code> parses an input of the form <code>[a, ‚Üê b, _ * (1 : ‚Ñ§)]</code>, consisting of a list of
terms, each optionally preceded by the arrow <code>‚Üê</code>.
It returns an array of triples consisting of</p><ul><li>the <code>Expr</code>ession corresponding to the parsed term,</li><li>the <code>Bool</code>ean <code>true</code> if the arrow is present in front of the term,</li><li>the underlying <code>Syntax</code> of the given term.</li></ul><p>E.g. convert <code>[a, ‚Üê b, _ * (1 : ‚Ñ§)]</code> to
<code>[(a, false, `(a)), (b, true, `(b)), (_ * 1, false, `(_ * 1))]</code>.</p><details id="instances-for-list-Mathlib.MoveAdd.parseArrows" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.moveOperTac"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L429-L455">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.moveOperTac" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.moveOperTac"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">moveOperTac</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>The tactic <code>move_add</code> rearranges summands of expressions.
Calling <code>move_add [a, ‚Üê b, ...]</code> matches <code>a, b,...</code> with summands in the main goal.
It then moves <code>a</code> to the far right and <code>b</code> to the far left of each addition in which they appear.
The side to which the summands are moved is determined by the presence or absence of the arrow <code>‚Üê</code>.</p><p>The inputs <code>a, b,...</code> can be any terms, also with underscores.
The tactic uses the first &quot;new&quot; summand that unifies with each one of the given inputs.</p><p>There is a multiplicative variant, called <code>move_mul</code>.</p><p>There is also a general tactic for a &quot;binary associative commutative operation&quot;: <code>move_oper</code>.
In this case the syntax requires providing first a term whose head symbol is the operation.
E.g. <code>move_oper HAdd.hAdd [...]</code> is the same as <code>move_add</code>, while <code>move_oper <a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Max.max">Max.max</a> [...]</code>
rearranges <code>max</code>s.</p><details id="instances-for-list-Mathlib.MoveAdd.moveOperTac" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.tacticMove_add_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L457-L460">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.tacticMove_add_" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_add_"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">tacticMove_add_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>The tactic <code>move_add</code> rearranges summands of expressions.
Calling <code>move_add [a, ‚Üê b, ...]</code> matches <code>a, b,...</code> with summands in the main goal.
It then moves <code>a</code> to the far right and <code>b</code> to the far left of each addition in which they appear.
The side to which the summands are moved is determined by the presence or absence of the arrow <code>‚Üê</code>.</p><p>The inputs <code>a, b,...</code> can be any terms, also with underscores.
The tactic uses the first &quot;new&quot; summand that unifies with each one of the given inputs.</p><p>There is a multiplicative variant, called <code>move_mul</code>.</p><p>There is also a general tactic for a &quot;binary associative commutative operation&quot;: <code>move_oper</code>.
In this case the syntax requires providing first a term whose head symbol is the operation.
E.g. <code>move_oper HAdd.hAdd [...]</code> is the same as <code>move_add</code>, while <code>move_oper <a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Max.max">Max.max</a> [...]</code>
rearranges <code>max</code>s.</p><details id="instances-for-list-Mathlib.MoveAdd.tacticMove_add_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.MoveAdd.tacticMove_mul_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/MoveAdd.lean#L462-L465">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_MoveAdd.html#Mathlib.MoveAdd.tacticMove_mul_" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MoveAdd.html#Mathlib.MoveAdd.tacticMove_mul_"><span class="name">Mathlib</span>.<span class="name">MoveAdd</span>.<span class="name">tacticMove_mul_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>The tactic <code>move_add</code> rearranges summands of expressions.
Calling <code>move_add [a, ‚Üê b, ...]</code> matches <code>a, b,...</code> with summands in the main goal.
It then moves <code>a</code> to the far right and <code>b</code> to the far left of each addition in which they appear.
The side to which the summands are moved is determined by the presence or absence of the arrow <code>‚Üê</code>.</p><p>The inputs <code>a, b,...</code> can be any terms, also with underscores.
The tactic uses the first &quot;new&quot; summand that unifies with each one of the given inputs.</p><p>There is a multiplicative variant, called <code>move_mul</code>.</p><p>There is also a general tactic for a &quot;binary associative commutative operation&quot;: <code>move_oper</code>.
In this case the syntax requires providing first a term whose head symbol is the operation.
E.g. <code>move_oper HAdd.hAdd [...]</code> is the same as <code>move_add</code>, while <code>move_oper <a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Max.max">Max.max</a> [...]</code>
rearranges <code>max</code>s.</p><details id="instances-for-list-Mathlib.MoveAdd.tacticMove_mul_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>