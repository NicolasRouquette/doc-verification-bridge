<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.FieldSimp</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.FieldSimp";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Data/Ineq.html">Mathlib.Data.Ineq</a></li><li><a href="../.././Mathlib/Util/SynthesizeUsing.html">Mathlib.Util.SynthesizeUsing</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Attr.html">Mathlib.Tactic.FieldSimp.Attr</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Discharger.html">Mathlib.Tactic.FieldSimp.Discharger</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html">Mathlib.Tactic.FieldSimp.Lemmas</a></li><li><a href="../.././Mathlib/Util/AtomM/Recurse.html">Mathlib.Util.AtomM.Recurse</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.FieldSimp" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.onExponent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">onExponent</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPrettyMonomial</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">tryClearZero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.removeZeros"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">removeZeros</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.split"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.evalPretty"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPretty</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkMulProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.div"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">div</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkDivProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition.proof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proofZero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.gcd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">gcd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.normalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">normalize</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceExprQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExprQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceEqQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceEqQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceLeQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLeQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceLtQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLtQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceProp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.parseDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">parseDischarger</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.fieldSimp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">fieldSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.convField_simp__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">convField_simp__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.proc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">proc</span></a></div><div class="nav_link"><a class="break_within" href="#fieldEq"><span class="name">fieldEq</span></a></div><div class="nav_link"><a class="break_within" href="#fieldLe"><span class="name">fieldLe</span></a></div><div class="nav_link"><a class="break_within" href="#fieldLt"><span class="name">fieldLt</span></a></div></nav><main>
<div class="mod_doc"><h1 id="field-simp-tactic" class="markdown-heading"><code>field_simp</code> tactic <a class="hover-link" href="#field-simp-tactic">#</a></h1><p>Tactic to clear denominators in algebraic expressions.</p></div><div class="mod_doc"><h3 id="Lists-of-expressions-representing-exponents-and-atoms-and-operations-on-such-lists" class="markdown-heading">Lists of expressions representing exponents and atoms, and operations on such lists <a class="hover-link" href="#Lists-of-expressions-representing-exponents-and-atoms-and-operations-on-such-lists">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L34-L47">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Basic meta-code &quot;normal form&quot; object of the <code>field_simp</code> tactic: a type synonym
for a list of ordered triples comprising an expression representing a term of a type <code>M</code> (where
typically <code>M</code> is a field), together with an integer &quot;power&quot; and a natural number &quot;index&quot;.</p><p>The natural number represents the index of the <code>M</code> term in the <code>AtomM</code> monad: this is not enforced,
but is sometimes assumed in operations.  Thus when items <code>((aâ‚, xâ‚), k)</code> and <code>((aâ‚‚, xâ‚‚), k)</code>
appear in two different <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> objects (i.e. with the same <code>â„•</code>-index <code>k</code>), it is expected
that the expressions <code>xâ‚</code> and <code>xâ‚‚</code> are the same.  It is also expected that the items in a
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> list are in strictly decreasing order by natural-number index.</p><p>By forgetting the natural number indices, an expression representing a <code><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF">Mathlib.Tactic.FieldSimp.NF</a></code>
object can be built from a <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> object; this construction is provided as
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">Mathlib.Tactic.FieldSimp.qNF.toNF</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.toNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L51-L55">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">Â«$MÂ»</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF">NF</a> <span class="fn">Â«$MÂ»</span></span>)</span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. a list of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (two <code>Expr</code>s and a natural
number), build an <code>Expr</code> representing an object of type <code>NF M</code> (i.e. <code>List (â„¤ Ã— M)</code>) in the
in the obvious way: by forgetting the natural numbers and gluing together the integers and <code>Expr</code>s.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.toNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.onExponent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L57-L61">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">onExponent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">â„¤</span> â†’ <span class="fn">â„¤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. a list of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (two <code>Expr</code>s and a natural
number), apply an expression representing a function with domain <code>â„¤</code> to each of the <code>â„¤</code>
components.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.onExponent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L63-L75">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPrettyMonomial</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">Q(<span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.zpow'">zpow'</a> <span class="fn">Â«$xÂ»</span> <span class="fn">Â«$rÂ»</span></span> <span class="fn">=</span> <span class="fn">Â«$eÂ»</span></span>)</span>)</span></span></div></div><p>Build a transparent expression for the product of powers represented by <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L77-L91">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">tryClearZero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">l'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">(</span><span class="fn">r</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span><span class="fn">,</span> <span class="fn">i</span><span class="fn">)</span></span> <span class="fn">::</span> <span class="fn">l</span>)</span></span>;
    <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span>)</span></span></div></div><p>Try to drop an expression <code>zpow' x r</code> from the beginning of a product. If <code>r â‰  0</code> this of course
can't be done. If <code>r = 0</code>, then <code>zpow' x r</code> is equal to <code>x / x</code>, so it can be simplified to 1 (hence
dropped from the beginning of the product) if we can find a proof that <code>x â‰  0</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.tryClearZero" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.removeZeros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L93-L108">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">removeZeros</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">l'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span>)</span></span></div></div><p>Given <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, obtain <code>l' : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code> by removing all <code>l</code>'s exponent-zero entries where the
corresponding atom can be proved nonzero, and construct a proof that their associated expressions
are equal.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.removeZeros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L110-L125">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">split</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">l_n</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
    <span class="fn">(<span class="fn">l_d</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
      <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l_d</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l_n</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">Â«$a_2Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">/</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span></span>)</span></span></span></span></span>)</span></span></div></div><p>Given a product of powers, split as a quotient: the positive powers divided by (the negations
of) the negative powers.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.evalPretty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L141-L154">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPretty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã—
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn">Â«$eÂ»</span></span>)</span></span>)</span></span></div></div><p>Build a transparent expression for the product of powers represented by <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.evalPretty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L156-L179">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">Â«$MÂ»</span>)</span></span> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">Â«$MÂ»</span>)</span></span> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">Â«$MÂ»</span>)</span></span></span></div></div><p>Given two terms <code>lâ‚</code>, <code>lâ‚‚</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (an integer, an
<code>Expr</code> and a natural number), construct another such term <code>l</code>, which will have the property that in
the field <code>$M</code>, the product of the &quot;multiplicative linear combinations&quot; represented by <code>lâ‚</code> and
<code>lâ‚‚</code> is the multiplicative linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>lâ‚</code> and <code>lâ‚‚</code> are in strictly decreasing order
by <code>â„•</code>-component, and that if pairs <code>(aâ‚, xâ‚)</code> and <code>(aâ‚‚, xâ‚‚)</code> appear in <code>lâ‚</code>, <code>lâ‚‚</code> respectively with
the same <code>â„•</code>-component <code>k</code>, then the expressions <code>xâ‚</code> and <code>xâ‚‚</code> are equal.</p><p>The construction is as follows: merge the two lists, except that if pairs <code>(aâ‚, xâ‚)</code> and <code>(aâ‚‚, xâ‚‚)</code>
appear in <code>lâ‚</code>, <code>lâ‚‚</code> respectively with the same <code>â„•</code>-component <code>k</code>, then contribute a term
<code>(aâ‚ + aâ‚‚, xâ‚)</code> to the output list with <code>â„•</code>-component <code>k</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L181-L199">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkMulProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lâ‚ </span><span class="fn">lâ‚‚</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">lâ‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">mul</a></span> <span class="fn">lâ‚‚</span>)</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">lâ‚‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">lâ‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">Â«$a_2Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">*</span> <span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span></span></div></div><p>Given two terms <code>lâ‚</code>, <code>lâ‚‚</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (an integer, an
<code>Expr</code> and a natural number), recursively construct a proof that in the field <code>$M</code>, the product of
the &quot;multiplicative linear combinations&quot; represented by <code>lâ‚</code> and <code>lâ‚‚</code> is the multiplicative linear
combination represented by <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">FieldSimp.qNF.mul</a> lâ‚ lâ‚</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mkMulProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.div"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L201-L223">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">div</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>lâ‚</code>, <code>lâ‚‚</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (an integer, an
<code>Expr</code> and a natural number), construct another such term <code>l</code>, which will have the property that in
the field <code>$M</code>, the quotient of the &quot;multiplicative linear combinations&quot; represented by <code>lâ‚</code> and
<code>lâ‚‚</code> is the multiplicative linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>lâ‚</code> and <code>lâ‚‚</code> are in strictly decreasing order
by <code>â„•</code>-component, and that if pairs <code>(aâ‚, xâ‚)</code> and <code>(aâ‚‚, xâ‚‚)</code> appear in <code>lâ‚</code>, <code>lâ‚‚</code> respectively with
the same <code>â„•</code>-component <code>k</code>, then the expressions <code>xâ‚</code> and <code>xâ‚‚</code> are equal.</p><p>The construction is as follows: merge the first list and the negation of the second list, except
that if pairs <code>(aâ‚, xâ‚)</code> and <code>(aâ‚‚, xâ‚‚)</code> appear in <code>lâ‚</code>, <code>lâ‚‚</code> respectively with the same
<code>â„•</code>-component <code>k</code>, then contribute a term <code>(aâ‚ - aâ‚‚, xâ‚)</code> to the output list with <code>â„•</code>-component <code>k</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.div" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L225-L243">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkDivProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lâ‚ </span><span class="fn">lâ‚‚</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">lâ‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">div</a></span> <span class="fn">lâ‚‚</span>)</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">lâ‚‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">lâ‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">Â«$a_2Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">/</span> <span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span></span></div></div><p>Given two terms <code>lâ‚</code>, <code>lâ‚‚</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(â„¤ Ã— Q($M)) Ã— â„•</code>s (an integer, an
<code>Expr</code> and a natural number), recursively construct a proof that in the field <code>$M</code>, the quotient
of the &quot;multiplicative linear combinations&quot; represented by <code>lâ‚</code> and <code>lâ‚‚</code> is the multiplicative
linear combination represented by <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">FieldSimp.qNF.div</a> lâ‚ lâ‚</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mkDivProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L247-L253">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition" class="verification-badge comp-datatype" title="Computational datatype">ğŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Constraints on denominators which may need to be considered in <code>field_simp</code>: no condition,
nonzeroness, or strict positivity.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.none">none<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.nonzero">nonzero<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.positive">positive<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT">PosMulReflectLT</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li></ul><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition.proof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L257-L262">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span> â†’ <a href="../.././foundational_types.html">Type</a></span></div></div><p>Given a field-simp-normal-form expression <code>L</code> (a product of powers of atoms), a proof (according
to the value of <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of that expression's nonzeroness, strict positivity, etc.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition.proof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L264-L271">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proofZero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<span class="fn">inferInstance</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">proof</a> <span class="fn"><span class="fn">[</span><span class="fn">]</span></span> <span class="fn">cond</span></span></div></div><p>The empty field-simp-normal-form expression <code>[]</code> (representing <code>1</code> as an empty product of powers
of atoms) can be proved to be nonzero, strict positivity, etc., as needed, as specified by the
value of <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition.proofZero" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L275-L295">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<span class="fn">inferInstance</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hL</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Q(<span class="fn"><span class="fn">Â«$eÂ»</span> <span class="fn">â‰ </span> <span class="fn">0</span></span>)</span> <span class="fn">Ã—</span> <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">(</span><span class="fn">r</span><span class="fn">,</span> <span class="fn">e</span><span class="fn">)</span></span><span class="fn">,</span> <span class="fn">i</span><span class="fn">)</span></span> <span class="fn">::</span> <span class="fn">L</span>)</span> <span class="fn">cond</span></span>)</span></span></div></div><p>Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of a field-simp-normal-form expression <code>L</code> (a product of powers of atoms),
construct a corresponding proof for <code>((r, e), i) :: L</code>.</p><p>In this version we also expose the proof of nonzeroness of <code>e</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L297-L314">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<span class="fn">inferInstance</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hL</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">(</span><span class="fn">r</span><span class="fn">,</span> <span class="fn">e</span><span class="fn">)</span></span><span class="fn">,</span> <span class="fn">i</span><span class="fn">)</span></span> <span class="fn">::</span> <span class="fn">L</span>)</span> <span class="fn">cond</span>)</span></span></div></div><p>Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of a field-simp-normal-form expression <code>L</code> (a product of powers of atoms),
construct a corresponding proof for <code>((r, e), i) :: L</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.gcd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L318-L405">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">gcd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lâ‚ </span><span class="fn">lâ‚‚</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<span class="fn">inferInstance</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
    <span class="fn">(<span class="fn">lâ‚'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
      <span class="fn">(<span class="fn">lâ‚‚'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
        <span class="fn"><span class="fn">(have <span class="fn">a</span> := <span class="fn"><span class="fn">lâ‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">lâ‚'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">Â«$a_2Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">*</span> <span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span>)</span> <span class="fn">Ã—</span>           <span class="fn"><span class="fn">(have <span class="fn">a</span> := <span class="fn"><span class="fn">lâ‚‚</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">lâ‚‚'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">Â«$a_2Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <span class="fn">*</span> <span class="fn"><span class="fn">Â«$a_1Â»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span>)</span> <span class="fn">Ã—</span>             <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span></span></span></span></span>)</span></span></div></div><p>Extract a common factor <code>L</code> of two products-of-powers <code>lâ‚</code> and <code>lâ‚‚</code> in <code>M</code>, in the sense that
both <code>lâ‚</code> and <code>lâ‚‚</code> are quotients by <code>L</code> of products of <em>positive</em> powers.</p><p>The variable <code>cond</code> specifies whether we extract a <em>certified nonzero[/positive]</em> (and therefore
potentially smaller) common factor. If so, the metaprogram returns a &quot;proof&quot; that this common factor
is nonzero/positive, i.e. an expression <code>Q(NF.eval $(L.toNF) â‰  0)</code> / <code>Q(0 &lt; NF.eval $(L.toNF))</code>.</p></div></div><div class="mod_doc"><h3 id="Core-of-the-field-simp-tactic" class="markdown-heading">Core of the <code>field_simp</code> tactic <a class="hover-link" href="#Core-of-the-field-simp-tactic">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.normalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L411-L528">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">normalize</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a>
  <span class="fn">((<span class="fn">y</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã—
    <span class="fn"><span class="fn">((<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign">Sign</a> <span class="fn">M</span></span>) Ã—
        <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign.expr">expr</a></span> <span class="fn">y</span></span>;
        <span class="fn">Q(<span class="fn"><span class="fn">Â«$xÂ»</span> <span class="fn">=</span> <span class="fn">Â«$aÂ»</span></span>)</span></span>)</span> <span class="fn">Ã—</span>       <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) Ã—
        <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
        <span class="fn">Q(<span class="fn"><span class="fn">Â«$yÂ»</span> <span class="fn">=</span> <span class="fn"><span class="fn">Â«$aÂ»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span></span>)</span></span></span></span>)</span></span></div></div><p>The main algorithm behind the <code>field_simp</code> tactic: partially-normalizing an
expression in a field <code>M</code> into the form x1 ^ c1 * x2 ^ c2 * ... x_k ^ c_k,
where x1, x2, ... are distinct atoms in <code>M</code>, and c1, c2, ... are integers.</p></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceExprQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L530-L538">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExprQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">x'</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">Q(<span class="fn"><span class="fn">Â«$xÂ»</span> <span class="fn">=</span> <span class="fn">Â«$x'Â»</span></span>)</span>)</span></span></div></div><p>Given <code>x</code> in a commutative group-with-zero, construct a new expression in the standard form
*** / *** (all denominators at the end) which is equal to <code>x</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceExprQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceEqQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L540-L553">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceEqQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eâ‚ </span><span class="fn">eâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">fâ‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">(<span class="fn">fâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">Q(<span class="fn"><span class="fn">(<span class="fn">Â«$eâ‚Â»</span> <span class="fn">=</span> <span class="fn">Â«$eâ‚‚Â»</span>)</span> <span class="fn">=</span> <span class="fn">(<span class="fn">Â«$fâ‚Â»</span> <span class="fn">=</span> <span class="fn">Â«$fâ‚‚Â»</span>)</span></span>)</span></span>)</span></span></div></div><p>Given <code>eâ‚</code> and <code>eâ‚‚</code>, cancel nonzero factors to construct a new equality which is logically
equivalent to <code>eâ‚ = eâ‚‚</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceEqQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceLeQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L555-L571">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLeQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLE">PosMulReflectLE</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eâ‚ </span><span class="fn">eâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">fâ‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">(<span class="fn">fâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">Q(<span class="fn">(<span class="fn">Â«$eâ‚Â»</span> <a href="../.././Mathlib/Algebra/Order/Kleene.html#LE.le">â‰¤</a> <span class="fn">Â«$eâ‚‚Â»</span>) <span class="fn">=</span> (<span class="fn">Â«$fâ‚Â»</span> <a href="../.././Mathlib/Algebra/Order/Kleene.html#LE.le">â‰¤</a> <span class="fn">Â«$fâ‚‚Â»</span>)</span>)</span></span>)</span></span></div></div><p>Given <code>eâ‚</code> and <code>eâ‚‚</code>, cancel positive factors to construct a new inequality which is logically
equivalent to <code>eâ‚ â‰¤ eâ‚‚</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceLeQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceLtQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L573-L589">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLtQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT">PosMulReflectLT</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">Â«$MÂ»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eâ‚ </span><span class="fn">eâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">fâ‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">(<span class="fn">fâ‚‚</span> : <span class="fn">Q(<span class="fn">Â«$MÂ»</span>)</span>) Ã— <span class="fn">Q(<span class="fn">(<span class="fn">Â«$eâ‚Â»</span> <a href="../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">Â«$eâ‚‚Â»</span>) <span class="fn">=</span> (<span class="fn">Â«$fâ‚Â»</span> <a href="../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">Â«$fâ‚‚Â»</span>)</span>)</span></span>)</span></span></div></div><p>Given <code>eâ‚</code> and <code>eâ‚‚</code>, cancel positive factors to construct a new inequality which is logically
equivalent to <code>eâ‚ &lt; eâ‚‚</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceLtQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L591-L608">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">Lean.Meta.Simp.Result</span></span></div></div><p>Given <code>x</code> in a commutative group-with-zero, construct a new expression in the standard form
*** / *** (all denominators at the end) which is equal to <code>x</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceProp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L610-L642">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceProp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">Lean.Meta.Simp.Result</span></span></div></div><p>Given an (in)equality <code>a = b</code> (respectively, <code>a â‰¤ b</code>, <code>a &lt; b</code>), cancel nonzero (resp. positive)
factors to construct a new (in)equality which is logically equivalent to <code>a = b</code> (respectively,
<code>a â‰¤ b</code>, <code>a &lt; b</code>).</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceProp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Frontend" class="markdown-heading">Frontend <a class="hover-link" href="#Frontend">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.parseDischarger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L648-L665">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">parseDischarger</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Lean.TSyntax</span> <span class="fn">`Lean.Parser.Tactic.discharger</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Lean.TSyntax</span> <span class="fn">`Lean.Parser.Tactic.simpArgs</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">({<span class="fn">u</span> : <span class="fn">Lean.Level</span>} â†’ <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$typeÂ»</span>)</span></span></span>)</span></span></div></div><p>If the user provided a discharger, elaborate it. If not, we will use the <code>field_simp</code> default
discharger, which (among other things) includes a simp-run for the specified argument list, so we
elaborate those arguments.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.parseDischarger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.fieldSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L667-L708">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">fieldSimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>The goal of <code>field_simp</code> is to bring expressions in (semi-)fields over a common denominator, i.e. to
reduce them to expressions of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code> contains any division
symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to <code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : â„š) (hy : 1 - y â‰  0) :
    âŒŠx / (1 - y) / (1 + y / (1 - y))âŒ‹ &lt; 3 := by
  field_simp
  -- new goal: `âŠ¢ âŒŠx / (1 - y + y)âŒ‹ &lt; 3`
</code></pre><p>The <code>field_simp</code> tactic will also clear denominators in field <em>(in)equalities</em>, by
cross-multiplying. For example, <code>field_simp</code> will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x â‰  0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  field_simp
  -- new goal: `âŠ¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>A very common pattern is <code>field_simp; ring</code> (clear denominators, then the resulting goal is
solvable by the axioms of a commutative ring). The finishing tactic <code>field</code> is a shorthand for this
pattern.</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
(e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>, check the
denominators of the resulting expression and provide proofs that they are nonzero/positive to enable
further progress.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.fieldSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.convField_simp__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L710-L741">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">convField_simp__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>The goal of the <code>field_simp</code> conv tactic is to bring an expression in a (semi-)field over a common
denominator, i.e. to reduce it to an expression of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code>
contains any division symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to
<code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : â„š) (hy : 1 - y â‰  0) :
    âŒŠx / (1 - y) / (1 + y / (1 - y))âŒ‹ &lt; 3 := by
  conv =&gt; enter [1, 1]; field_simp
  -- new goal: `âŠ¢ âŒŠx / (1 - y + y)âŒ‹ &lt; 3`
</code></pre><p>As in this example, cancelling and combining denominators will generally require checking
&quot;nonzeroness&quot; side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit
such steps if it cannot discharge the corresponding side conditions. The discharger will try, among
other things, <code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness proofs included
explicitly (e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>,
check the denominators of the resulting expression and provide proofs that they are nonzero to
enable further progress.</p><p>The <code>field_simp</code> conv tactic is a variant of the main (i.e., not conv) <code>field_simp</code> tactic. The
latter operates recursively on subexpressions, bringing <em>every</em> field-expression encountered to the
form <code>n / d</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.convField_simp__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.proc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L743-L777">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#Mathlib.Tactic.FieldSimp.proc" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">proc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Meta.Simp.Simproc</span></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x â‰  0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `âŠ¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.proc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L783-L783">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#fieldEq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldEq"><span class="name">fieldEq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Meta.Simp.Simproc</span></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x â‰  0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `âŠ¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details id="instances-for-list-fieldEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L784-L784">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#fieldLe" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldLe"><span class="name">fieldLe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Meta.Simp.Simproc</span></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x â‰  0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `âŠ¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details id="instances-for-list-fieldLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/FieldSimp.lean#L785-L785">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_FieldSimp.html#fieldLt" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldLt"><span class="name">fieldLt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Meta.Simp.Simproc</span></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x â‰  0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `âŠ¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details id="instances-for-list-fieldLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We register <code>field_simp</code> with the <code>hint</code> tactic.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>