<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Abel</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Abel";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/TryThis.html">Mathlib.Tactic.TryThis</a></li><li><a href="../.././Mathlib/Tactic/NormNum/Basic.html">Mathlib.Tactic.NormNum.Basic</a></li><li><a href="../.././Mathlib/Util/AtomM/Recurse.html">Mathlib.Util.AtomM.Recurse</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Abel" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">isAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.cleanup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">cleanup</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></div></nav><main>
<div class="mod_doc"><h1 id="The-abel-tactic" class="markdown-heading">The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic <a class="hover-link" href="#The-abel-tactic">#</a></h1><p>Evaluate expressions in the language of additive, commutative monoids and groups.</p><h2 id="Future-work" class="markdown-heading">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul><li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>It is undecided whether these features should be restored eventually.</li></ul></div><div class="decl" id="Mathlib.Tactic.Abel.term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L35-L36">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Î±</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n â€¢ x + a</code> in an additive commutative monoid.</p><details id="instances-for-list-Mathlib.Tactic.Abel.term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L37-L38">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.termg" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Î±</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n â€¢ x + a</code> in an additive commutative group.</p><details id="instances-for-list-Mathlib.Tactic.Abel.termg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L40-L41">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.smul" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Î±</span></div></div><p>A synonym for <code>â€¢</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.smul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smulg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L42-L43">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.smulg" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Î±</span></div></div><p>A synonym for <code>â€¢</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.smulg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L52-L73">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abel" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L75-L90">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.Context" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a></code> for a call to <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><p>Stores a few options for this call, and caches some common subexpressions
such as typeclass instances and <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.Î±">Î±</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.Context.mk"><li id="Mathlib.Tactic.Abel.Context.Î±" class="structure_field"><div class="structure_field_info">Î± : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The type of the ambient additive commutative group or monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.univ" class="structure_field"><div class="structure_field_info">univ : <span class="fn">Lean.Level</span></div><div class="structure_field_doc"><p>The universe level for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.Î±">Î±</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.Î±0" class="structure_field"><div class="structure_field_info">Î±0 : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The expression representing <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.Î±">Î±</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.isGroup" class="structure_field"><div class="structure_field_info">isGroup : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>Specify whether we are in an additive commutative group or an additive commutative monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.inst" class="structure_field"><div class="structure_field_info">inst : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.Î±">Î±</a></code> or <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.Î±">Î±</a></code> expression.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkContext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L92-L102">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.mkContext" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a></span></div></div><p>Populate a <code>context</code> object for evaluating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.mkContext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L104-L107">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.M" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The monad for <code>Abel</code> contains, in addition to the <code>AtomM</code> state,
some information about the current type we are working over, so that we can consistently
use group lemmas or monoid lemmas as appropriate.</p><details id="instances-for-list-Mathlib.Tactic.Abel.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L109-L112">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.Context.app" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inst</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Expr</span></span> â†’ <span class="fn">Lean.Expr</span></span></div></div><p>Apply the function <code>n : âˆ€ {Î±} [inst : AddWhatever Î±], _</code> to the
implicit parameters in the context, and the given list of arguments.</p><details id="instances-for-list-Mathlib.Tactic.Abel.Context.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.mkApp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L114-L121">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.Context.mkApp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">inst</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Apply the function <code>n : âˆ€ {Î±} [inst Î±], _</code> to the implicit parameters in the
context, and the given list of arguments.</p><p>Compared to <code>context.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></code>, this takes the name of the typeclass, rather than an
inferred typeclass instance.</p><details id="instances-for-list-Mathlib.Tactic.Abel.Context.mkApp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.addG"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L123-L130">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.addG" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Name</span> â†’ <span class="fn">Lean.Name</span></span></div></div><p>Add the letter &quot;g&quot; to the end of the name, e.g. turning <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a></code> into <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a></code>.</p><p>This is used to choose between declarations taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code> and those
taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a></code> instances.</p><details id="instances-for-list-Mathlib.Tactic.Abel.addG" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.iapp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L132-L138">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.iapp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">Lean.Name</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>Apply the function <code>n : âˆ€ {Î±} [AddComm{Monoid,Group} Î±]</code> to the given list of arguments.</p><p>Will use the <code>AddComm{Monoid,Group}</code> instance that has been cached in the context.</p><details id="instances-for-list-Mathlib.Tactic.Abel.iapp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L140-L141">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.mkTerm" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">x </span><span class="fn">a</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>Evaluate a term with coefficient <code>n</code>, atom <code>x</code> and successor terms <code>a</code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.mkTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.intToExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L143-L145">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.intToExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>Interpret an integer as a coefficient to a term.</p><details id="instances-for-list-Mathlib.Tactic.Abel.intToExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L147-L155">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.NormalExpr" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A normal form for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.
Expressions are represented as a list of terms of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a> = n â€¢ x</code>,
where <code>n : â„¤</code> and <code>x</code> is an arbitrary element of the additive commutative monoid or group.
We explicitly track the <code>Expr</code> forms of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> and <code>n</code>, even though they could be reconstructed,
for efficiency.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.zero">zero<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></li><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.nterm">nterm<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">â„¤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a>)</span></span>
 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instInhabitedNormalExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L155-L155">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L155-L155">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></div></div><details id="instances-for-list-Mathlib.Tactic.Abel.instInhabitedNormalExpr.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.e"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L157-L160">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.NormalExpr.e" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <span class="fn">Lean.Expr</span></span></div></div><p>Extract the expression from a normal form.</p><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.e" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instCoeNormalExprExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L162-L162">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Coe</span> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Lean.Expr</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.term'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L164-L166">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">â„¤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div><p>Construct the normal form representing a single term.</p><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.term'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.zero'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L168-L169">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div><p>Construct the normal form representing zero.</p><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.zero'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L173-L175">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.const_add_term" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">k</span> <span class="fn">+</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">k</span> <span class="fn">+</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L177-L179">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.const_add_termg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">k</span> <span class="fn">+</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">k</span> <span class="fn">+</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L181-L183">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_add_const" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">k </span><span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">+</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">+</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_constg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L185-L187">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_add_constg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">k </span><span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">+</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">+</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L189-L191">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_add_term" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">nâ‚</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">aâ‚</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nâ‚‚</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">aâ‚‚</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚</span> : <span class="fn"><span class="fn"><span class="fn">nâ‚</span> <span class="fn">+</span> <span class="fn">nâ‚‚</span></span> <span class="fn">=</span> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚‚</span> : <span class="fn"><span class="fn"><span class="fn">aâ‚</span> <span class="fn">+</span> <span class="fn">aâ‚‚</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">nâ‚</span> <span class="fn">x</span> <span class="fn">aâ‚</span></span> <span class="fn">+</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">nâ‚‚</span> <span class="fn">x</span> <span class="fn">aâ‚‚</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L193-L197">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_add_termg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">nâ‚</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">aâ‚</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nâ‚‚</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">aâ‚‚</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚</span> : <span class="fn"><span class="fn"><span class="fn">nâ‚</span> <span class="fn">+</span> <span class="fn">nâ‚‚</span></span> <span class="fn">=</span> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚‚</span> : <span class="fn"><span class="fn"><span class="fn">aâ‚</span> <span class="fn">+</span> <span class="fn">aâ‚‚</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">nâ‚</span> <span class="fn">x</span> <span class="fn">aâ‚</span></span> <span class="fn">+</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">nâ‚‚</span> <span class="fn">x</span> <span class="fn">aâ‚‚</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L199-L200">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.zero_term" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L202-L203">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.zero_termg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAdd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L205-L231">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalAdd" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></span></div></div><p>Interpret the sum of two expressions in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L233-L235">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_neg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚</span> : <span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">n</span> <span class="fn">=</span> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚‚</span> : <span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalNeg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L237-L248">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalNeg" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></span></div></div><p>Interpret a negated expression in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details id="instances-for-list-Mathlib.Tactic.Abel.evalNeg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L250-L251">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.zero_smul" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">0</span></span> <span class="fn">=</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L253-L254">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.zero_smulg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">0</span></span> <span class="fn">=</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L256-L259">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_smul" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚</span> : <span class="fn"><span class="fn"><span class="fn">c</span> <span class="fn">*</span> <span class="fn">n</span></span> <span class="fn">=</span> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚‚</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L261-L264">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_smulg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚</span> : <span class="fn"><span class="fn"><span class="fn">c</span> <span class="fn">*</span> <span class="fn">n</span></span> <span class="fn">=</span> <span class="fn">n'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hâ‚‚</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L266-L275">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalSMul" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">â„¤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></span></div></div><p>Auxiliary function for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'">evalSMul'</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L277-L277">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_atom" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atomg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L278-L278">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_atomg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L279-L280">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_atom_pf" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn">x'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pfg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L281-L282">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_atom_pfg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn">x'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L284-L291">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalAtom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>Interpret an expression as an atom for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details id="instances-for-list-Mathlib.Tactic.Abel.evalAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L293-L294">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.unfold_sub" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoid">SubtractionMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">+</span> <a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">b</span></span> <span class="fn">=</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">-</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L296-L297">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.unfold_smul" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">n</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">â€¢</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L299-L300">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.unfold_smulg" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">(<span class="fn">Int.ofNat</span> <span class="fn">n</span>)</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">â†‘<span class="fn">n</span></span> <span class="fn">â€¢</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_zsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L302-L303">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.unfold_zsmul" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">n</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">â€¢</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L305-L307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn"><span class="fn">l</span> <span class="fn">=</span> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L309-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn"><span class="fn">l</span> <span class="fn">=</span> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">l</span> <span class="fn">r</span></span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul_upcast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L313-L316">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">zl</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prlâ‚</span> : <span class="fn"><span class="fn">l</span> <span class="fn">=</span> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prlâ‚‚</span> : <span class="fn"><span class="fn">â†‘<span class="fn">tl</span></span> <span class="fn">=</span> <span class="fn">zl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">zl</span> <span class="fn">tr</span></span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L318-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">r </span><span class="fn">tl </span><span class="fn">tr </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn"><span class="fn">l</span> <span class="fn">=</span> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><span class="fn"><span class="fn">tl</span> <span class="fn">+</span> <span class="fn">tr</span></span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span> <span class="fn">+</span> <span class="fn">r</span></span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_addg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L322-L324">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">r </span><span class="fn">tl </span><span class="fn">tr </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn"><span class="fn">l</span> <span class="fn">=</span> <span class="fn">tl</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">tr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><span class="fn"><span class="fn">tl</span> <span class="fn">+</span> <span class="fn">tr</span></span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span> <span class="fn">+</span> <span class="fn">r</span></span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_negg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L326-L328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">ta </span><span class="fn">t</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pra</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">ta</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">ta</span> <span class="fn">=</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">a</span> <span class="fn">=</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L330-L358">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalSMul'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">eval</span> : <span class="fn"><span class="fn">Lean.Expr</span> â†’ <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">is_smulg</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">orig </span><span class="fn">eâ‚ </span><span class="fn">eâ‚‚</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>Normalize a term <code>orig</code> of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> eâ‚ eâ‚‚</code> or <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> eâ‚ eâ‚‚</code>.
Normalized terms use <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> for monoids and <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> for groups,
so there are actually four cases to handle:</p><ul><li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> in a monoid just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul">subst_into_smul</a></code></li><li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a group just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg">subst_into_smulg</a></code></li><li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> a b</code> in a group requires converting <code>a</code> from a nat to an int and
then simplifying <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> â†‘a b</code> using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast">subst_into_smul_upcast</a></code></li><li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a monoid is impossible (or at least out of scope),
because you need a group argument to write a <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> term</li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.eval"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L360-L404">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.eval" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>Evaluate an expression into its <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form, by recursing into subexpressions.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.isAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L406-L427">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.isAtom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">isAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Bool</span></div></div><p>Determine whether <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> will be handled as an atom by the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic. The <code>match</code> in this
function should be preserved to be parallel in case-matching to that in the
<code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">Mathlib.Tactic.Abel.eval</a></code> metaprogram.</p><details id="instances-for-list-Mathlib.Tactic.Abel.isAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L429-L444">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abel1" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abel1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L447-L447">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abel1!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abel1!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L449-L449">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.term_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">â€¢</span> <span class="fn">x</span></span> <span class="fn">+</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L450-L451">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.termg_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">ðŸ“ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">Î±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">â„¤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">Î±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">â€¢</span> <span class="fn">x</span></span> <span class="fn">+</span> <span class="fn">a</span></span></span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n â€¢ x + a</code> in an additive commutative group.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.isAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L453-L456">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> â†’ <span class="fn">Bool</span></span></div></div><p>True if this represents an atomic expression.</p><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.isAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelMode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L458-L463">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.AbelMode" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The normalization style for <code>abel_nf</code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.term">term : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a><div class="inductive_ctor_doc"><p>The default form</p></div></li><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.raw">raw : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a><div class="inductive_ctor_doc"><p>Raw form: the representation <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> uses internally.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelMode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelNF.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L465-L468">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.AbelNF.Config" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></span><span class="decl_extends">extends</span> <span id="Mathlib.Tactic.Abel.AbelNF.Config.toConfig"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config">Mathlib.Tactic.AtomM.Recurse.Config</a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configuration for <code>abel_nf</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.AbelNF.Config.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config.red">red</a> : <span class="fn">Lean.Meta.TransparencyMode</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config.zetaDelta">zetaDelta</a> : <span class="fn">Bool</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config.contextual">contextual</a> : <span class="fn">Bool</span></div></li><li id="Mathlib.Tactic.Abel.AbelNF.Config.mode" class="structure_field"><div class="structure_field_info">mode : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a></div><div class="structure_field_doc"><p>The normalization style.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelNF.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L470-L471">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Syntax</span> â†’ <span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a></span></span></div></div><p>Function elaborating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.cleanup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L473-L484">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.cleanup" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.cleanup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">cleanup</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Lean.Meta.Simp.Result</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Meta.Simp.Result</span></span></div></div><p>A cleanup routine, which simplifies expressions in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form to a more human-friendly
format.</p><details id="instances-for-list-Mathlib.Tactic.Abel.cleanup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L486-L498">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.evalExpr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">Lean.Meta.Simp.Result</span></span></div></div><p>Evaluate an expression into its <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form.</p><p>This is a variant of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">Mathlib.Tactic.Abel.eval</a></code>, the main driver of the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.
It differs in</p><ul><li>outputting a <code>Simp.Result</code>, rather than a <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> Ã— Expr</code>;</li><li>throwing an error if the expression <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> is an atom for the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.</li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.evalExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L502-L509">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abelNF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abelNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel_nf!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L512-L513">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel_nf!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L515-L516">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abelNFConv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L518-L528">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p>Elaborator for the <code>abel_nf</code> tactic.</p><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel_nf!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L531-L531">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel_nf!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L538-L538">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.tacticAbel!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L541-L542">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.abelConv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.abelConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Abel.lean#L544-L545">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Abel.html#Mathlib.Tactic.Abel.convAbel!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Î±] (a b : Î±) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup Î±] (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We register <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> with the <code>hint</code> tactic.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>