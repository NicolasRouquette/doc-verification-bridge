<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.DepRewrite</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.DepRewrite";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Init.html">Mathlib.Init</a></li><li><a href="../.././Lean/Elab/Tactic/Config.html">Lean.Elab.Tactic.Config</a></li><li><a href="../.././Lean/Elab/Tactic/Rewrite.html">Lean.Elab.Tactic.Rewrite</a></li><li><a href="../.././Lean/Elab/Tactic/Simp.html">Lean.Elab.Tactic.Simp</a></li><li><a href="../.././Lean/Elab/Tactic/Conv/Basic.html">Lean.Elab.Tactic.Conv.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.DepRewrite" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.dcongrArg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">dcongrArg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.nddcongrArg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">nddcongrArg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.heqL"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">heqL</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.heqR"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">heqR</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.CastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">CastMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.instBEqCastMode.beq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instBEqCastMode</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.instBEqCastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instBEqCastMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.instToStringCastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instToStringCastMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.CastMode.toNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">CastMode</span>.<span class="name">toNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.instLECastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instLECastMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.instDecidableLECastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instDecidableLECastMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.canUseCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">canUseCache</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.checkCastAllowed"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">checkCastAllowed</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.zetaDelta"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">zetaDelta</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.castMData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castMData</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.castBack?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castBack?</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.castFwd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castFwd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.visitAndCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visitAndCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.visit"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visit</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.visitInner"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visitInner</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.dabstract"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">dabstract</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.depRewrite"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">depRewrite</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.cleanupCasts"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">cleanupCasts</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRewriteTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRwTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRewriteLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteLocalDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.depRwLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwLocalDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.elabDepRewriteConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">elabDepRewriteConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.evalDepRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">evalDepRewriteSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.evalDepRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">evalDepRwSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.depRewrite"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRewrite</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.depRw"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRw</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.depRewriteTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRewriteTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.depRwTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRwTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.evalDepRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">evalDepRewriteSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.DepRewrite.Conv.evalDepRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">evalDepRwSeq</span></a></div></nav><main>
<div class="mod_doc"><h2 id="Dependent-rewrite-tactic" class="markdown-heading">Dependent rewrite tactic <a class="hover-link" href="#Dependent-rewrite-tactic">#</a></h2></div><div class="decl" id="Mathlib.Tactic.DepRewrite.dcongrArg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L21-L24">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.dcongrArg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">dcongrArg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span> ‚Üí <a href="../.././foundational_types.html">Sort</a> v</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">‚ãØ</span> <span class="fn">‚ñ∏</span> <span class="fn"><span class="fn">f</span> <span class="fn">a'</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.nddcongrArg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L26-L29">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.nddcongrArg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">nddcongrArg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span> ‚Üí <span class="fn">Œ≤</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">‚ãØ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a'</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.heqL"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L31-L33">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.heqL"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">heqL</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">‚âç</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn"><span class="fn">cast</span> <span class="fn">‚ãØ</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.heqR"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L35-L37">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.heqR"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">heqR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">‚âç</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">cast</span> <span class="fn">‚ãØ</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.CastMode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L50-L62">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">CastMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>See <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">Config.castMode</a></code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.DepRewrite.CastMode.proofs">proofs : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a><div class="inductive_ctor_doc"><p>Only insert casts on proofs.</p><p>In this mode, it is <em>not</em> permitted to cast subterms of proofs that are not themselves proofs.</p></div></li><li class="constructor" id="Mathlib.Tactic.DepRewrite.CastMode.all">all : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a><div class="inductive_ctor_doc"><p>Insert casts whenever necessary.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.DepRewrite.CastMode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.instBEqCastMode.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L62-L62">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.instBEqCastMode.beq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.instBEqCastMode.beq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instBEqCastMode</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a> ‚Üí <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a> ‚Üí <span class="fn">Bool</span></span></div></div><details id="instances-for-list-Mathlib.Tactic.DepRewrite.instBEqCastMode.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.instBEqCastMode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L62-L62">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.instBEqCastMode" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.instBEqCastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instBEqCastMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">BEq</span> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.instToStringCastMode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L64-L66">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.instToStringCastMode" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.instToStringCastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instToStringCastMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">ToString</span> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.CastMode.toNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L68-L71">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode.toNat" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode.toNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">CastMode</span>.<span class="name">toNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a> ‚Üí <span class="fn">‚Ñï</span></span></div></div><p>Embedding of <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></code> into naturals.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.CastMode.toNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.instLECastMode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L73-L74">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.instLECastMode" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.instLECastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instLECastMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LE</span> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.instDecidableLECastMode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L76-L77">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.instDecidableLECastMode" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.instDecidableLECastMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">instDecidableLECastMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">DecidableLE</span> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L79-L96">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Config" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configures the behavior of the <code>rewrite!</code> and <code>rw!</code> tactics.</p><ul class="structure_fields" id="Mathlib.Tactic.DepRewrite.Config.mk"><li id="Mathlib.Tactic.DepRewrite.Config.transparency" class="structure_field"><div class="structure_field_info">transparency : <span class="fn">Lean.Meta.TransparencyMode</span></div><div class="structure_field_doc"><p>Which transparency level to use when unifying the rewrite rule's LHS
against subterms of the term being rewritten.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Config.occs" class="structure_field"><div class="structure_field_info">occs : <span class="fn">Lean.Meta.Occurrences</span></div><div class="structure_field_doc"><p>Which occurrences to rewrite.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Config.castMode" class="structure_field"><div class="structure_field_info">castMode : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a></div><div class="structure_field_doc"><p>The cast mode specifies when <code>rewrite!</code> is permitted to insert casts
in order to correct subterms that become type-incorrect
as a result of rewriting.</p><p>For example, given <code>P : Nat ‚Üí Prop</code>, <code>f : (n : Nat) ‚Üí P n ‚Üí Nat</code> and <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a> : P n‚ÇÄ</code>,
rewriting <code>f n‚ÇÄ <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code> by <code>eq : n‚ÇÄ = n‚ÇÅ</code> produces <code>f n‚ÇÅ <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code>,
where <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code> does not typecheck at <code>P n‚ÇÅ</code>.
The tactic will cast <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code> to <code>eq ‚ñ∏ <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a> : P n‚ÇÅ</code> iff <code>.<a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode.proofs">proofs</a> ‚â§ <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">castMode</a></code>.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Config.castTransparency" class="structure_field"><div class="structure_field_info">castTransparency : <span class="fn">Lean.Meta.TransparencyMode</span></div><div class="structure_field_doc"><p>Which transparency level to use when cleaning up casts to decide if a cast is a refl-cast.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L98-L125">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Context" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p><code>ReaderT</code> context for <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.M">M</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.DepRewrite.Context.mk"><li id="Mathlib.Tactic.DepRewrite.Context.cfg" class="structure_field"><div class="structure_field_info">cfg : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a></div><div class="structure_field_doc"><p>Configuration.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.p" class="structure_field"><div class="structure_field_info">p : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The pattern to generalize over.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.x" class="structure_field"><div class="structure_field_info">x : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The free variable to substitute for <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.p">p</a></code>.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.h" class="structure_field"><div class="structure_field_info">h : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>A proof of <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.p">p</a> = <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a></code>. Must be an fvar.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.Œî" class="structure_field"><div class="structure_field_info">Œî : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">Lean.FVarId</span> <span class="fn">√ó</span> <span class="fn">Lean.Expr</span>)</span></span></div><div class="structure_field_doc"><p>The list of <em>value-less</em> binders (<code>cdecl</code>s and nondependent <code>ldecl</code>s)
that we have introduced.
Together with each binder, we store its type abstracted over <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a></code> and <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code>,
and with all occurrences of previous entries in <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.Œî">Œî</a></code>
casted along the abstracting equation.</p><p>E.g., if the local context is <code>a : T, b : U</code>,
we store <code>(a, Ma)</code> where <code>Ma := fun (x' : Œ±) (h' : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a> = x') =&gt; T[x'/x, h'/h]</code>
and <code>(b, fun (x' : Œ±) (h' : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a> = x') =&gt; U[x'/x, h'/h, (Eq.rec (motive := Ma) a h)/a])</code>
See the docstring on <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visitAndCast">visitAndCast</a></code>.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.Œ¥" class="structure_field"><div class="structure_field_info">Œ¥ : <span class="fn"><span class="fn">Std.HashSet</span> <span class="fn">Lean.FVarId</span></span></div><div class="structure_field_doc"><p>The set of all <em>dependent</em> <code>ldecl</code>s that we have introduced.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.pHeadIdx" class="structure_field"><div class="structure_field_info">pHeadIdx : <span class="fn">Lean.HeadIndex</span></div><div class="structure_field_doc"><p>Cached <code>p.toHeadIndex</code>.</p></div></li><li id="Mathlib.Tactic.DepRewrite.Context.pNumArgs" class="structure_field"><div class="structure_field_info">pNumArgs : <span class="fn">‚Ñï</span></div><div class="structure_field_doc"><p>Cached <code>p.toNumArgs</code>.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.canUseCache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L127-L139">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.canUseCache" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.canUseCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">canUseCache</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cacheOcc </span><span class="fn">dCacheOcc </span><span class="fn">currOcc</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Meta.Occurrences</span> ‚Üí <span class="fn">Bool</span></span></div></div><p>We use a cache entry iff the upcoming traversal would abstract exactly the same occurrences
as the cached traversal.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.canUseCache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L141-L154">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.M" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Monad for computing <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.dabstract">dabstract</a></code>.</p><p>The <code>Nat</code> state tracks which occurrence of the pattern we are about to see, 1-indexed
(so the initial value is <code>1</code>).</p><p>The cache stores results of <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visit">visit</a></code> together with</p><ul><li>the <code>Nat</code> state before the cached call; and</li><li>the difference in the state resulting from the call.
We store these because even if the cache hits,
we must update the state as if the call had been made.
Storing the difference suffices because the state increases monotonically.
See also <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.canUseCache">canUseCache</a></code>.</li></ul><details id="instances-for-list-Mathlib.Tactic.DepRewrite.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.checkCastAllowed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L156-L166">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.checkCastAllowed" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.checkCastAllowed"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">checkCastAllowed</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">t</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">castMode</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.CastMode">CastMode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Unit</span></span></div></div><p>Check that casting <code>e : t</code> is allowed in the current mode.
(We don't need to know what type <code>e</code> is cast to:
we only check the sort of <code>t</code>, and it cannot change.)</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.checkCastAllowed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.zetaDelta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L168-L179">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.zetaDelta" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.zetaDelta"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">zetaDelta</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fvars</span> : <span class="fn"><span class="fn">Std.HashSet</span> <span class="fn">Lean.FVarId</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>In <code>e</code>, inline the values of those <code>ldecl</code>s that appear in <code>fvars</code>.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.zetaDelta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.castMData"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L181-L183">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.castMData" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.castMData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castMData</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.MData</span></div></div><p>A piece of metadata associated with <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Lean.MVarId.depRewrite">depRewrite</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.castMData" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.castBack?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L185-L220">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.castBack?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.castBack?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castBack?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">te </span><span class="fn">x </span><span class="fn">h</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œî</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">Lean.FVarId</span> <span class="fn">√ó</span> <span class="fn">Lean.Expr</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ¥</span> : <span class="fn"><span class="fn">Std.HashSet</span> <span class="fn">Lean.FVarId</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>If <code>e : te</code> is a term whose type mentions <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a></code>, <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a></code> (the generalization variables)
or entries in <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.Œî">Œî</a></code>/<code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.Œ¥">Œ¥</a></code>,
return <code>h.<a href="../.././Mathlib/Order/Defs/Unbundled.html#symm">symm</a> ‚ñ∏ e : te[p/x, rfl/h, ‚Ä¶]</code>.
Otherwise return <code>none</code>.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.castBack?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.castFwd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L222-L241">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.castFwd" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.castFwd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">castFwd</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">te </span><span class="fn">p </span><span class="fn">x </span><span class="fn">h</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œî</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">Lean.FVarId</span> <span class="fn">√ó</span> <span class="fn">Lean.Expr</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ¥</span> : <span class="fn"><span class="fn">Std.HashSet</span> <span class="fn">Lean.FVarId</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Cast <code>e : te[p/x, rfl/h, ...]</code> to <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.h">h</a> ‚ñ∏ e : te</code>.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.castFwd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.visitAndCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L245-L288">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.visitAndCast" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visitAndCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visitAndCast</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">et?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>Given <code>e</code>, return <code>e'</code> where <code>e'</code> has had</p><ul><li>the occurrences of <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.p">p</a></code> in <code>ctx.cfg.<a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.occs">occs</a></code> replaced by <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a></code>; and</li><li>subterms cast as appropriate in order to make <code>e'</code> type-correct.</li></ul><p>If <code>et?</code> is not <code>none</code>, the output is guaranteed to have type (defeq to) <code>et?</code>.</p><p>We do <em>not</em> assume that <code>e</code> is well-typed.
We use this when processing binders:
to traverse <code>‚àÄ (x : Œ±), Œ≤</code>,
we obtain <code>Œ±' ‚Üê <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visit">visit</a> Œ±</code>,
add <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a> : Œ±'</code> to the local context
and continue traversing <code>Œ≤</code>.
Although <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a> : Œ±' ‚ä¢ Œ≤</code> may not hold,
the output <code>Œ≤'</code> should have <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Context.x">x</a> : Œ±' ‚ä¢ Œ≤'</code> (otherwise we have a bug).</p><p>To achieve this, we maintain the invariant
that all entries in the local context that we have introduced
can be translated back to their original (pre-<code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visit">visit</a></code>) types
using the motive computed by <code>castBack?.motive</code>.
(But we have not attempted to prove this.)</p></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.visit"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L290-L304">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.visit" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visit"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">et?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>Like <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visitAndCast">visitAndCast</a></code>, but does not insert casts at the top level.
The expected types of certain subterms are computed from <code>et?</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.visitInner"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L309-L393">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.visitInner" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visitInner"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">visitInner</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">et?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.M">M</a> <span class="fn">Lean.Expr</span></span></div></div><p>See <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.visit">visit</a></code>.</p></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.dabstract"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L397-L408">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.dabstract" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.dabstract"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">dabstract</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">p</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Analogue of <code>kabstract</code> with support for inserting casts.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.dabstract" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.depRewrite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L410-L505">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Lean.MVarId.depRewrite" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Lean.MVarId.depRewrite"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">depRewrite</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">heq</span> : <span class="fn">Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span> := <span class="fn">false</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Mathlib.Tactic.DepRewrite.Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">Meta.RewriteResult</span></span></div></div><p>Analogue of <code>Lean.MVarId.rewrite</code> with support for inserting casts.</p><details id="instances-for-list-Lean.MVarId.depRewrite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.cleanupCasts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L507-L539">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.cleanupCasts" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.cleanupCasts"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">cleanupCasts</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Cleanup casts introduced by <code>rewrite!</code> in <code>e</code>.
The result is expected to be defeq to the original expression.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.cleanupCasts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L543-L556">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">castMode</a></code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRewriteSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L558-L562">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRwSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRewriteTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L564-L571">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteTarget" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteTarget</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rewrite!</code> to the goal.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRewriteTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRwTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L573-L582">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwTarget" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwTarget</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rw!</code> to the goal.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRwTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRewriteLocalDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L584-L594">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteLocalDecl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRewriteLocalDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fvarId</span> : <span class="fn">Lean.FVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rewrite!</code> to a local declaration.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRewriteLocalDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.depRwLocalDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L596-L608">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwLocalDecl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwLocalDecl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">depRwLocalDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fvarId</span> : <span class="fn">Lean.FVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rw!</code> to a local declaration.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.depRwLocalDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.elabDepRewriteConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L610-L611">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.elabDepRewriteConfig" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.elabDepRewriteConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">elabDepRewriteConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Syntax</span> ‚Üí <span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a></span></span></div></div><p>Elaborate <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">DepRewrite.Config</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.elabDepRewriteConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.evalDepRewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L613-L621">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.evalDepRewriteSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.evalDepRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">evalDepRewriteSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">castMode</a></code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.evalDepRewriteSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.evalDepRwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L623-L631">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.evalDepRwSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.evalDepRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">evalDepRwSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.evalDepRwSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.depRewrite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L636-L637">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRewrite" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRewrite"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRewrite</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">castMode</a></code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.depRewrite" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.depRw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L639-L640">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRw" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRw"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRw</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.depRw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.depRewriteTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L642-L649">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRewriteTarget" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRewriteTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRewriteTarget</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rewrite!</code> to the goal.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.depRewriteTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.depRwTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L651-L659">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRwTarget" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.depRwTarget"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">depRwTarget</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">symm</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config">Config</a> := <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">{</a> <a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>Apply <code>rw!</code> to the goal.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.depRwTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.evalDepRewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L661-L669">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.evalDepRewriteSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.evalDepRewriteSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">evalDepRewriteSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code><a href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Config.castMode">castMode</a></code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.evalDepRewriteSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.DepRewrite.Conv.evalDepRwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/DepRewrite.lean#L671-L679">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.evalDepRwSeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.Conv.evalDepRwSeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">DepRewrite</span>.<span class="name">Conv</span>.<span class="name">evalDepRwSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><details id="instances-for-list-Mathlib.Tactic.DepRewrite.Conv.evalDepRwSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>