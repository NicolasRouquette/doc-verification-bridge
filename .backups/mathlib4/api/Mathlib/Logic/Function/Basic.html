<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Function.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Function.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Function</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Batteries/Tactic/Init.html">Batteries.Tactic.Init</a></li><li><a href="../../.././Mathlib/Logic/Basic.html">Mathlib.Logic.Basic</a></li><li><a href="../../.././Mathlib/Logic/ExistsUnique.html">Mathlib.Logic.ExistsUnique</a></li><li><a href="../../.././Mathlib/Logic/Nonempty.html">Mathlib.Logic.Nonempty</a></li><li><a href="../../.././Mathlib/Data/Set/Defs.html">Mathlib.Data.Set.Defs</a></li><li><a href="../../.././Mathlib/Logic/Function/Defs.html">Mathlib.Logic.Function.Defs</a></li><li><a href="../../.././Mathlib/Logic/Nontrivial/Defs.html">Mathlib.Logic.Nontrivial.Defs</a></li><li><a href="../../.././Mathlib/Order/Defs/Unbundled.html">Mathlib.Order.Defs.Unbundled</a></li><li><a href="../../.././Mathlib/Tactic/Attr/Register.html">Mathlib.Tactic.Attr.Register</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Function.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Function.eval"><span class="name">Function</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Function.eval_apply"><span class="name">Function</span>.<span class="name">eval_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_def"><span class="name">Function</span>.<span class="name">const_def</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_injective"><span class="name">Function</span>.<span class="name">const_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_inj"><span class="name">Function</span>.<span class="name">const_inj</span></a></div><div class="nav_link"><a class="break_within" href="#Function.onFun_apply"><span class="name">Function</span>.<span class="name">onFun_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.hfunext"><span class="name">Function</span>.<span class="name">hfunext</span></a></div><div class="nav_link"><a class="break_within" href="#Function.ne_iff"><span class="name">Function</span>.<span class="name">ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.funext_iff_of_subsingleton"><span class="name">Function</span>.<span class="name">funext_iff_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap_lt"><span class="name">Function</span>.<span class="name">swap_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap_le"><span class="name">Function</span>.<span class="name">swap_le</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap_gt"><span class="name">Function</span>.<span class="name">swap_gt</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap_ge"><span class="name">Function</span>.<span class="name">swap_ge</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.injective"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.surjective"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_injective_iff"><span class="name">Function</span>.<span class="name">not_injective_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_injective_const"><span class="name">Function</span>.<span class="name">not_injective_const</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.decidableEq"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">decidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.of_comp"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.of_comp_iff"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.of_comp_right"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.bijective‚ÇÇ_of_injective"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">bijective‚ÇÇ_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.piMap"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">piMap</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.comp_left"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_comp_left_iff"><span class="name">Function</span>.<span class="name">injective_comp_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_of_subsingleton"><span class="name">Function</span>.<span class="name">injective_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Function.bijective_of_subsingleton"><span class="name">Function</span>.<span class="name">bijective_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.dite"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">dite</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.of_comp"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.of_comp_iff"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.of_comp_left"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.bijective‚ÇÇ_of_surjective"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">bijective‚ÇÇ_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.decidableEqPFun"><span class="name">Function</span>.<span class="name">decidableEqPFun</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.forall"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.forall‚ÇÇ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.forall‚ÇÉ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.exists"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.exists‚ÇÇ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.exists‚ÇÉ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.injective_comp_right"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">injective_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_comp_right_iff_surjective"><span class="name">Function</span>.<span class="name">injective_comp_right_iff_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.right_cancellable"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">right_cancellable</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_of_right_cancellable_Prop"><span class="name">Function</span>.<span class="name">surjective_of_right_cancellable_Prop</span></a></div><div class="nav_link"><a class="break_within" href="#Function.bijective_iff_existsUnique"><span class="name">Function</span>.<span class="name">bijective_iff_existsUnique</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.existsUnique"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">existsUnique</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.existsUnique_iff"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">existsUnique_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.of_comp_iff"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">of_comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">of_comp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.cantor_surjective"><span class="name">Function</span>.<span class="name">cantor_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.cantor_injective"><span class="name">Function</span>.<span class="name">cantor_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_surjective_Type"><span class="name">Function</span>.<span class="name">not_surjective_Type</span></a></div><div class="nav_link"><a class="break_within" href="#Function.IsPartialInv"><span class="name">Function</span>.<span class="name">IsPartialInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.isPartialInv_left"><span class="name">Function</span>.<span class="name">isPartialInv_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_of_isPartialInv"><span class="name">Function</span>.<span class="name">injective_of_isPartialInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_of_isPartialInv_right"><span class="name">Function</span>.<span class="name">injective_of_isPartialInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.eq"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.comp_eq_id"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">comp_eq_id</span></a></div><div class="nav_link"><a class="break_within" href="#Function.leftInverse_iff_comp"><span class="name">Function</span>.<span class="name">leftInverse_iff_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.comp_eq_id"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">comp_eq_id</span></a></div><div class="nav_link"><a class="break_within" href="#Function.rightInverse_iff_comp"><span class="name">Function</span>.<span class="name">rightInverse_iff_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.comp"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.comp"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.rightInverse"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.leftInverse"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.surjective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.injective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.rightInverse_of_injective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.rightInverse_of_surjective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.leftInverse_of_surjective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.RightInverse.leftInverse_of_injective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.eq_rightInverse"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.partialInv"><span class="name">Function</span>.<span class="name">partialInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.partialInv_of_injective"><span class="name">Function</span>.<span class="name">partialInv_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.partialInv_left"><span class="name">Function</span>.<span class="name">partialInv_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun"><span class="name">Function</span>.<span class="name">invFun</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun_eq"><span class="name">Function</span>.<span class="name">invFun_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.apply_invFun_apply"><span class="name">Function</span>.<span class="name">apply_invFun_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun_neg"><span class="name">Function</span>.<span class="name">invFun_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun_eq_of_injective_of_rightInverse"><span class="name">Function</span>.<span class="name">invFun_eq_of_injective_of_rightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.rightInverse_invFun"><span class="name">Function</span>.<span class="name">rightInverse_invFun</span></a></div><div class="nav_link"><a class="break_within" href="#Function.leftInverse_invFun"><span class="name">Function</span>.<span class="name">leftInverse_invFun</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun_surjective"><span class="name">Function</span>.<span class="name">invFun_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.invFun_comp"><span class="name">Function</span>.<span class="name">invFun_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.hasLeftInverse"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">hasLeftInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_iff_hasLeftInverse"><span class="name">Function</span>.<span class="name">injective_iff_hasLeftInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjInv"><span class="name">Function</span>.<span class="name">surjInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjInv_eq"><span class="name">Function</span>.<span class="name">surjInv_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_surjInv"><span class="name">Function</span>.<span class="name">comp_surjInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.rightInverse_surjInv"><span class="name">Function</span>.<span class="name">rightInverse_surjInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.leftInverse_surjInv"><span class="name">Function</span>.<span class="name">leftInverse_surjInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.hasRightInverse"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">hasRightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_iff_hasRightInverse"><span class="name">Function</span>.<span class="name">surjective_iff_hasRightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.bijective_iff_has_inverse"><span class="name">Function</span>.<span class="name">bijective_iff_has_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.injective_surjInv"><span class="name">Function</span>.<span class="name">injective_surjInv</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_to_subsingleton"><span class="name">Function</span>.<span class="name">surjective_to_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.piMap"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">piMap</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Surjective.comp_left"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_comp_left_iff"><span class="name">Function</span>.<span class="name">surjective_comp_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.piMap"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">piMap</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.comp_left"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update"><span class="name">Function</span>.<span class="name">update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_self"><span class="name">Function</span>.<span class="name">update_self</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_of_ne"><span class="name">Function</span>.<span class="name">update_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_apply"><span class="name">Function</span>.<span class="name">update_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_eq_const_of_subsingleton"><span class="name">Function</span>.<span class="name">update_eq_const_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_eval"><span class="name">Function</span>.<span class="name">surjective_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_injective"><span class="name">Function</span>.<span class="name">update_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.forall_update_iff"><span class="name">Function</span>.<span class="name">forall_update_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.exists_update_iff"><span class="name">Function</span>.<span class="name">exists_update_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_eq_iff"><span class="name">Function</span>.<span class="name">update_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.eq_update_iff"><span class="name">Function</span>.<span class="name">eq_update_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_eq_self_iff"><span class="name">Function</span>.<span class="name">update_eq_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.eq_update_self_iff"><span class="name">Function</span>.<span class="name">eq_update_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.ne_update_self_iff"><span class="name">Function</span>.<span class="name">ne_update_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_ne_self_iff"><span class="name">Function</span>.<span class="name">update_ne_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_eq_self"><span class="name">Function</span>.<span class="name">update_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_comp_eq_of_forall_ne'"><span class="name">Function</span>.<span class="name">update_comp_eq_of_forall_ne'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_comp_eq_of_forall_ne"><span class="name">Function</span>.<span class="name">update_comp_eq_of_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_comp_eq_of_injective'"><span class="name">Function</span>.<span class="name">update_comp_eq_of_injective'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_apply_of_injective"><span class="name">Function</span>.<span class="name">update_apply_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_comp_eq_of_injective"><span class="name">Function</span>.<span class="name">update_comp_eq_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.rec_update"><span class="name">Function</span>.<span class="name">rec_update</span></a></div><div class="nav_link"><a class="break_within" href="#Option.rec_update"><span class="name">Option</span>.<span class="name">rec_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.apply_update"><span class="name">Function</span>.<span class="name">apply_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.apply_update‚ÇÇ"><span class="name">Function</span>.<span class="name">apply_update‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Function.pred_update"><span class="name">Function</span>.<span class="name">pred_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_update"><span class="name">Function</span>.<span class="name">comp_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_comm"><span class="name">Function</span>.<span class="name">update_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Function.update_idem"><span class="name">Function</span>.<span class="name">update_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.map_update"><span class="name">Pi</span>.<span class="name">map_update</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.map_injective"><span class="name">Pi</span>.<span class="name">map_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend"><span class="name">Function</span>.<span class="name">extend</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough"><span class="name">Function</span>.<span class="name">FactorsThrough</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_def"><span class="name">Function</span>.<span class="name">extend_def</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.factorsThrough"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">factorsThrough</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough.extend_apply"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">extend_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.extend_apply"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">extend_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_apply'"><span class="name">Function</span>.<span class="name">extend_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_id"><span class="name">Function</span>.<span class="name">extend_id</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.extend_comp"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">extend_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.factorsThrough_iff"><span class="name">Function</span>.<span class="name">factorsThrough_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.apply_extend"><span class="name">Function</span>.<span class="name">apply_extend</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_injective"><span class="name">Function</span>.<span class="name">extend_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough.extend_comp"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">extend_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_const"><span class="name">Function</span>.<span class="name">extend_const</span></a></div><div class="nav_link"><a class="break_within" href="#Function.extend_comp"><span class="name">Function</span>.<span class="name">extend_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.surjective_comp_right'"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">surjective_comp_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective.surjective_comp_right"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">surjective_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.surjective_comp_right_iff_injective"><span class="name">Function</span>.<span class="name">surjective_comp_right_iff_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Bijective.comp_right"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough.rfl"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough.comp_left"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.FactorsThrough.comp_right"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_def"><span class="name">Function</span>.<span class="name">uncurry_def</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_injective"><span class="name">Function</span>.<span class="name">uncurry_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.curry_injective"><span class="name">Function</span>.<span class="name">curry_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_flip"><span class="name">Function</span>.<span class="name">uncurry_flip</span></a></div><div class="nav_link"><a class="break_within" href="#Function.flip_curry"><span class="name">Function</span>.<span class="name">flip_curry</span></a></div><div class="nav_link"><a class="break_within" href="#Function.curry_update"><span class="name">Function</span>.<span class="name">curry_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_update_update"><span class="name">Function</span>.<span class="name">uncurry_update_update</span></a></div><div class="nav_link"><a class="break_within" href="#Function.bicompl"><span class="name">Function</span>.<span class="name">bicompl</span></a></div><div class="nav_link"><a class="break_within" href="#Function.bicompr"><span class="name">Function</span>.<span class="name">bicompr</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_bicompr"><span class="name">Function</span>.<span class="name">uncurry_bicompr</span></a></div><div class="nav_link"><a class="break_within" href="#Function.uncurry_bicompl"><span class="name">Function</span>.<span class="name">uncurry_bicompl</span></a></div><div class="nav_link"><a class="break_within" href="#Function.HasUncurry"><span class="name">Function</span>.<span class="name">HasUncurry</span></a></div><div class="nav_link"><a class="break_within" href="#Function.¬´term‚Üø_¬ª"><span class="name">Function</span>.<span class="name">¬´term‚Üø_¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#Function.hasUncurryBase"><span class="name">Function</span>.<span class="name">hasUncurryBase</span></a></div><div class="nav_link"><a class="break_within" href="#Function.hasUncurryInduction"><span class="name">Function</span>.<span class="name">hasUncurryInduction</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive"><span class="name">Function</span>.<span class="name">Involutive</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.involutive_not"><span class="name">Bool</span>.<span class="name">involutive_not</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.comp_self"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">comp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.leftInverse"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">leftInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.leftInverse_iff"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">leftInverse_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.rightInverse"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">rightInverse</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.injective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.surjective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.bijective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">bijective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.ite_not"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">ite_not</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Involutive.eq_iff"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_involutive"><span class="name">Function</span>.<span class="name">not_involutive</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_injective"><span class="name">Function</span>.<span class="name">not_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_surjective"><span class="name">Function</span>.<span class="name">not_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.not_bijective"><span class="name">Function</span>.<span class="name">not_bijective</span></a></div><div class="nav_link"><a class="break_within" href="#Function.symmetric_apply_eq_iff"><span class="name">Function</span>.<span class="name">symmetric_apply_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2"><span class="name">Function</span>.<span class="name">Injective2</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.left"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">left</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.right"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">right</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.uncurry"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">uncurry</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.left'"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">left'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.right'"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">right'</span></a></div><div class="nav_link"><a class="break_within" href="#Function.Injective2.eq_iff"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.sometimes"><span class="name">Function</span>.<span class="name">sometimes</span></a></div><div class="nav_link"><a class="break_within" href="#Function.sometimes_eq"><span class="name">Function</span>.<span class="name">sometimes_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.sometimes_spec"><span class="name">Function</span>.<span class="name">sometimes_spec</span></a></div><div class="nav_link"><a class="break_within" href="#forall_existsUnique_iff"><span class="name">forall_existsUnique_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_existsUnique_iff'"><span class="name">forall_existsUnique_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.forall_existsUnique_iff'"><span class="name">Symmetric</span>.<span class="name">forall_existsUnique_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.forall_existsUnique_iff"><span class="name">Symmetric</span>.<span class="name">forall_existsUnique_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Set.piecewise"><span class="name">Set</span>.<span class="name">piecewise</span></a></div><div class="nav_link"><a class="break_within" href="#eq_rec_on_bijective"><span class="name">eq_rec_on_bijective</span></a></div><div class="nav_link"><a class="break_within" href="#eq_mp_bijective"><span class="name">eq_mp_bijective</span></a></div><div class="nav_link"><a class="break_within" href="#eq_mpr_bijective"><span class="name">eq_mpr_bijective</span></a></div><div class="nav_link"><a class="break_within" href="#cast_bijective"><span class="name">cast_bijective</span></a></div><div class="nav_link"><a class="break_within" href="#eq_rec_inj"><span class="name">eq_rec_inj</span></a></div><div class="nav_link"><a class="break_within" href="#cast_inj"><span class="name">cast_inj</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.eq_rec_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.eq_rec_on_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rec_on_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Function.LeftInverse.cast_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">cast_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Set.SeparatesPoints"><span class="name">Set</span>.<span class="name">SeparatesPoints</span></a></div><div class="nav_link"><a class="break_within" href="#InvImage.equivalence"><span class="name">InvImage</span>.<span class="name">equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableUncurryOfFstSnd_mathlib"><span class="name">instDecidableUncurryOfFstSnd_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableCurryOfMk_mathlib"><span class="name">instDecidableCurryOfMk_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.map_id"><span class="name">Pi</span>.<span class="name">map_id</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.map_id'"><span class="name">Pi</span>.<span class="name">map_id'</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.map_comp_map"><span class="name">Pi</span>.<span class="name">map_comp_map</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Miscellaneous-function-constructions-and-lemmas" class="markdown-heading">Miscellaneous function constructions and lemmas <a class="hover-link" href="#Miscellaneous-function-constructions-and-lemmas">#</a></h1></div><div class="decl" id="Function.eval"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L35-L37">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.eval" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval"><span class="name">Function</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">x</span></span></div></div><p>Evaluate a function at an argument. Useful if you want to talk about the partially applied
<code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> x : (‚àÄ x, Œ≤ x) ‚Üí Œ≤ x</code>.</p><details id="instances-for-list-Function.eval" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.eval_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L39-L40">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.eval_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval_apply"><span class="name">Function</span>.<span class="name">eval_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">eval</a> <span class="fn">x</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Function.const_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L42-L43">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.const_def"><span class="name">Function</span>.<span class="name">const_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(fun (<span class="fn">x</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">y</span>)</span> <span class="fn">=</span> <span class="fn"><span class="fn">const</span> <span class="fn">Œ±</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Function.const_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L45-L47">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.const_injective"><span class="name">Function</span>.<span class="name">const_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">const</span> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Function.const_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L49-L51">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.const_inj"><span class="name">Function</span>.<span class="name">const_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y‚ÇÅ </span><span class="fn">y‚ÇÇ</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">const</span> <span class="fn">Œ±</span> <span class="fn">y‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">const</span> <span class="fn">Œ±</span> <span class="fn">y‚ÇÇ</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">y‚ÇÅ</span> <span class="fn">=</span> <span class="fn">y‚ÇÇ</span></span></span></div></div></div></div><div class="decl" id="Function.onFun_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L53-L54">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.onFun_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.onFun_apply"><span class="name">Function</span>.<span class="name">onFun_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.onFun">onFun</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">b</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.hfunext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L56-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.hfunext"><span class="name">Function</span>.<span class="name">hfunext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤'</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f'</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±'</span>) ‚Üí <span class="fn"><span class="fn">Œ≤'</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hŒ±</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">=</span> <span class="fn">Œ±'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>) (<span class="fn">a'</span> : <span class="fn">Œ±'</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">‚âç</span> <span class="fn">a'</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">‚âç</span> <span class="fn"><span class="fn">f'</span> <span class="fn">a'</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">‚âç</span> <span class="fn">f'</span></span></div></div></div></div><div class="decl" id="Function.ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L64-L65">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.ne_iff"><span class="name">Function</span>.<span class="name">ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f‚ÇÅ </span><span class="fn">f‚ÇÇ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f‚ÇÅ</span> <span class="fn">‚â†</span> <span class="fn">f‚ÇÇ</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f‚ÇÅ</span> <span class="fn">a</span></span> <span class="fn">‚â†</span> <span class="fn"><span class="fn">f‚ÇÇ</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="Function.funext_iff_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L67-L71">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.funext_iff_of_subsingleton"><span class="name">Function</span>.<span class="name">funext_iff_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.swap_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L73-L73">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.swap_lt" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.swap_lt"><span class="name">Function</span>.<span class="name">swap_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LT</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">swap</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">x2</span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">x1</span> <span class="fn">&gt;</span> <span class="fn">x2</span></span></span></span></div></div></div></div><div class="decl" id="Function.swap_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L74-L74">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.swap_le" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.swap_le"><span class="name">Function</span>.<span class="name">swap_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">swap</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x2</span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">x1</span> <span class="fn">‚â•</span> <span class="fn">x2</span></span></span></span></div></div></div></div><div class="decl" id="Function.swap_gt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L75-L75">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.swap_gt" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.swap_gt"><span class="name">Function</span>.<span class="name">swap_gt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LT</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">swap</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">x1</span> <span class="fn">&gt;</span> <span class="fn">x2</span></span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LT.lt">&lt;</a> <span class="fn">x2</span></span></span></div></div></div></div><div class="decl" id="Function.swap_ge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L76-L76">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.swap_ge" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.swap_ge"><span class="name">Function</span>.<span class="name">swap_ge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">swap</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">x1</span> <span class="fn">‚â•</span> <span class="fn">x2</span></span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn">x2</span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L78-L78">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.injective"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Bijective.surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L79-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.surjective"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.not_injective_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_injective_iff"><span class="name">Function</span>.<span class="name">not_injective_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>) (<span class="fn">b</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">a</span> <span class="fn">‚â†</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Function.not_injective_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L84-L88">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_injective_const"><span class="name">Function</span>.<span class="name">not_injective_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Function.Injective.decidableEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L90-L93">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.decidableEq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.decidableEq"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">decidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span></div></div><p>If the co-domain <code>Œ≤</code> of an injective function <code>f : Œ± ‚Üí Œ≤</code> has decidable equality, then
the domain <code>Œ±</code> also has decidable equality.</p><details id="instances-for-list-Function.Injective.decidableEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.Injective.of_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.Injective.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L98-L101">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.Injective.of_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L103-L107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_right"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Surjective.bijective‚ÇÇ_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L109-L111">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Surjective.bijective‚ÇÇ_of_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.bijective‚ÇÇ_of_injective"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">bijective‚ÇÇ_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.Injective.of_comp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L113-L116">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">of_comp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Injective.piMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L118-L120">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.piMap" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.piMap"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">piMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.Injective.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L122-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.comp_left"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">x</span></span></span></span></div></div><p>Composition by an injective function on the left is itself injective.</p></div></div><div class="decl" id="Function.injective_comp_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L126-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_comp_left_iff"><span class="name">Function</span>.<span class="name">injective_comp_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">Injective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">x</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.injective_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L131-L132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_of_subsingleton"><span class="name">Function</span>.<span class="name">injective_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.bijective_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L134-L135">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.bijective_of_subsingleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.bijective_of_subsingleton"><span class="name">Function</span>.<span class="name">bijective_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Injective.dite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L137-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.dite"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">dite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">{</span> <span class="fn">a</span> <span class="fn">:</span> <span class="fn">Œ±</span> <span class="fn">//</span> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <span class="fn">}</span></span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f'</span> : <span class="fn"><span class="fn"><span class="fn">{</span> <span class="fn">a</span> <span class="fn">:</span> <span class="fn">Œ±</span> <span class="fn">//</span> <span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span> <span class="fn">}</span></span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf'</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">im_disj</span> : <span class="fn">‚àÄ {<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">Œ±</span>} {<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>} {<span class="fn">hx'</span> : <span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">p</span> <span class="fn">x'</span></span></span>}, <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">‚ü®</span><span class="fn">x</span>, <span class="fn">hx</span><span class="fn">‚ü©</span></span></span> <span class="fn">‚â†</span> <span class="fn"><span class="fn">f'</span> <span class="fn"><span class="fn">‚ü®</span><span class="fn">x'</span>, <span class="fn">hx'</span><span class="fn">‚ü©</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">if h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> then <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">‚ü®</span><span class="fn">x</span>, <span class="fn">h</span><span class="fn">‚ü©</span></span></span> else <span class="fn"><span class="fn">f'</span> <span class="fn"><span class="fn">‚ü®</span><span class="fn">x</span>, <span class="fn">h</span><span class="fn">‚ü©</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.of_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L144-L146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Surjective.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L148-L151">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.of_comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L153-L154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_left"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.Injective.bijective‚ÇÇ_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L156-L158">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.bijective‚ÇÇ_of_surjective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.bijective‚ÇÇ_of_surjective"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">bijective‚ÇÇ_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span> <span class="fn">‚àß</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.of_comp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L160-L163">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">of_comp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.decidableEqPFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L165-L167">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.decidableEqPFun" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.decidableEqPFun"><span class="name">Function</span>.<span class="name">decidableEqPFun</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <span class="fn"><span class="fn">p</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_4</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span>) ‚Üí <span class="fn"><span class="fn">DecidableEq</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">hp</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">DecidableEq</span> <span class="fn">((<span class="fn">hp</span> : <span class="fn">p</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">hp</span></span>)</span></span></div></div></div></div><div class="decl" id="Function.Surjective.forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L169-L173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.forall"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">y</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.forall‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L175-L177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.forall‚ÇÇ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">y‚ÇÅ </span><span class="fn">y‚ÇÇ</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y‚ÇÅ</span> <span class="fn">y‚ÇÇ</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÅ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÇ</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.forall‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L179-L181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.forall‚ÇÉ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">forall‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">y‚ÇÅ </span><span class="fn">y‚ÇÇ </span><span class="fn">y‚ÇÉ</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y‚ÇÅ</span> <span class="fn">y‚ÇÇ</span> <span class="fn">y‚ÇÉ</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ </span><span class="fn">x‚ÇÉ</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÅ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÇ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÉ</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L183-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.exists"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÉ (<span class="fn">y</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.exists‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L190-L192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.exists‚ÇÇ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÉ (<span class="fn">y‚ÇÅ</span> : <span class="fn">Œ≤</span>) (<span class="fn">y‚ÇÇ</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y‚ÇÅ</span> <span class="fn">y‚ÇÇ</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">x‚ÇÅ</span> : <span class="fn">Œ±</span>) (<span class="fn">x‚ÇÇ</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÅ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÇ</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.exists‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L194-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.exists‚ÇÉ"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">exists‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÉ (<span class="fn">y‚ÇÅ</span> : <span class="fn">Œ≤</span>) (<span class="fn">y‚ÇÇ</span> : <span class="fn">Œ≤</span>) (<span class="fn">y‚ÇÉ</span> : <span class="fn">Œ≤</span>), <span class="fn"><span class="fn">p</span> <span class="fn">y‚ÇÅ</span> <span class="fn">y‚ÇÇ</span> <span class="fn">y‚ÇÉ</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">x‚ÇÅ</span> : <span class="fn">Œ±</span>) (<span class="fn">x‚ÇÇ</span> : <span class="fn">Œ±</span>) (<span class="fn">x‚ÇÉ</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÅ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÇ</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x‚ÇÉ</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.injective_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L198-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.injective_comp_right"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">injective_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="Function.injective_comp_right_iff_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L201-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_comp_right_iff_surjective"><span class="name">Function</span>.<span class="name">injective_comp_right_iff_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">Œ≥</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">Injective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Surjective.right_cancellable"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L210-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.right_cancellable"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">right_cancellable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">g‚ÇÅ</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g‚ÇÇ</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">g‚ÇÅ</span> <span class="fn">=</span> <span class="fn">g‚ÇÇ</span></span></span></div></div></div></div><div class="decl" id="Function.surjective_of_right_cancellable_Prop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L214-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_of_right_cancellable_Prop"><span class="name">Function</span>.<span class="name">surjective_of_right_cancellable_Prop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">g‚ÇÅ</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g‚ÇÇ</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span> ‚Üí <span class="fn"><span class="fn">g‚ÇÅ</span> <span class="fn">=</span> <span class="fn">g‚ÇÇ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.bijective_iff_existsUnique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L218-L222">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.bijective_iff_existsUnique" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.bijective_iff_existsUnique"><span class="name">Function</span>.<span class="name">bijective_iff_existsUnique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">b</span> : <span class="fn">Œ≤</span>), <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">a</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ±</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.existsUnique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L224-L227">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Bijective.existsUnique" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">existsUnique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">a</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ±</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></div></div><p>Shorthand for using projection notation with <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.bijective_iff_existsUnique">Function.bijective_iff_existsUnique</a></code>.</p></div></div><div class="decl" id="Function.Bijective.existsUnique_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L229-L237">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Bijective.existsUnique_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.existsUnique_iff"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">existsUnique_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">y</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ≤</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>) <span class="fn">‚Üî</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">x</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ±</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.of_comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L239-L241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">of_comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.of_comp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L243-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.of_comp_iff'"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">of_comp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.cantor_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L247-L251">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.cantor_surjective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.cantor_surjective"><span class="name">Function</span>.<span class="name">cantor_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œ±</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></span></div></div><p><strong>Cantor's diagonal argument</strong> implies that there are no surjective functions from <code>Œ±</code>
to <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±</code>.</p></div></div><div class="decl" id="Function.cantor_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L253-L257">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.cantor_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.cantor_injective"><span class="name">Function</span>.<span class="name">cantor_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></span></div></div><p><strong>Cantor's diagonal argument</strong> implies that there are no injective functions from <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±</code>
to <code>Œ±</code>.</p></div></div><div class="decl" id="Function.not_surjective_Type"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L259-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_surjective_Type"><span class="name">Function</span>.<span class="name">not_surjective_Type</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> (max u v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">¬¨</span><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></span></div></div><p>There is no surjection from <code>Œ± : Type u</code> into <code>Type (max u v)</code>. This theorem
demonstrates why <code>Type : Type</code> would be inconsistent in Lean.</p></div></div><div class="decl" id="Function.IsPartialInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L274-L278">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.IsPartialInv" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.IsPartialInv"><span class="name">Function</span>.<span class="name">IsPartialInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>g</code> is a partial inverse to <code>f</code> (an injective but not necessarily
surjective function) if <code>g y = some x</code> implies <code>f x = y</code>, and <code>g y = none</code>
implies that <code>y</code> is not in the range of <code>f</code>.</p><details id="instances-for-list-Function.IsPartialInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.isPartialInv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L280-L281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.isPartialInv_left"><span class="name">Function</span>.<span class="name">isPartialInv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.IsPartialInv">IsPartialInv</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">some</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Function.injective_of_isPartialInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L283-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv"><span class="name">Function</span>.<span class="name">injective_of_isPartialInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.IsPartialInv">IsPartialInv</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.injective_of_isPartialInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L287-L289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_of_isPartialInv_right"><span class="name">Function</span>.<span class="name">injective_of_isPartialInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.IsPartialInv">IsPartialInv</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ</span> : <span class="fn"><span class="fn">b</span> <span class="fn">‚àà</span> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ</span> : <span class="fn"><span class="fn">b</span> <span class="fn">‚àà</span> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L291-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Function.RightInverse.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L293-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.eq"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.comp_eq_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L295-L296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp_eq_id"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">comp_eq_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Function.leftInverse_iff_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.leftInverse_iff_comp"><span class="name">Function</span>.<span class="name">leftInverse_iff_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn">id</span></span></span></div></div></div></div><div class="decl" id="Function.RightInverse.comp_eq_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L301-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp_eq_id"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">comp_eq_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Function.rightInverse_iff_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L304-L305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.rightInverse_iff_comp"><span class="name">Function</span>.<span class="name">rightInverse_iff_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">id</span></span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L307-L309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.comp"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hh</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">h</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">(<span class="fn">h</span> <span class="fn">‚àò</span> <span class="fn">f</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">i</span>)</span></span></div></div></div></div><div class="decl" id="Function.RightInverse.comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L311-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.comp"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hh</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">h</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">(<span class="fn">h</span> <span class="fn">‚àò</span> <span class="fn">f</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">i</span>)</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.rightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L315-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.RightInverse.leftInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L318-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L321-L322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.surjective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.RightInverse.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L324-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.injective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.rightInverse_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L327-L329">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_injective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.rightInverse_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L331-L333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.rightInverse_of_surjective"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">rightInverse_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.RightInverse.leftInverse_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L335-L337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_surjective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span> ‚Üí <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="Function.RightInverse.leftInverse_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L339-L341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.RightInverse.leftInverse_of_injective"><span class="name">Function</span>.<span class="name">RightInverse</span>.<span class="name">leftInverse_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">g</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">Injective</span> <span class="fn">g</span></span> ‚Üí <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.eq_rightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L343-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rightInverse"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g‚ÇÅ </span><span class="fn">g‚ÇÇ</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g‚ÇÅ</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">g‚ÇÇ</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">g‚ÇÅ</span> <span class="fn">=</span> <span class="fn">g‚ÇÇ</span></span></div></div></div></div><div class="decl" id="Function.partialInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L349-L353">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.partialInv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.partialInv"><span class="name">Function</span>.<span class="name">partialInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></div></div><p>We can use choice to construct explicitly a partial inverse for
a given injective function <code>f</code>.</p><details id="instances-for-list-Function.partialInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.partialInv_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L355-L368">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.partialInv_of_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.partialInv_of_injective"><span class="name">Function</span>.<span class="name">partialInv_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.IsPartialInv">IsPartialInv</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.partialInv">partialInv</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.partialInv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L370-L371">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.partialInv_left" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.partialInv_left"><span class="name">Function</span>.<span class="name">partialInv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">I</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.partialInv">partialInv</a> <span class="fn">f</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">some</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Function.invFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L379-L384">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun"><span class="name">Function</span>.<span class="name">invFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span></div></div><p>The inverse of a function (which is a left inverse if <code>f</code> is injective
and a right inverse if <code>f</code> is surjective).</p><details id="instances-for-list-Function.invFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.invFun_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L386-L387">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun_eq"><span class="name">Function</span>.<span class="name">invFun_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span> <span class="fn">b</span>)</span></span> <span class="fn">=</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Function.apply_invFun_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L389-L391">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.apply_invFun_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.apply_invFun_apply"><span class="name">Function</span>.<span class="name">apply_invFun_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.invFun_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L393-L394">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun_neg" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun_neg"><span class="name">Function</span>.<span class="name">invFun_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">¬¨</span><span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">Classical.choice</span> <span class="fn">inst‚úù</span></span></span></div></div></div></div><div class="decl" id="Function.invFun_eq_of_injective_of_rightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L396-L402">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun_eq_of_injective_of_rightInverse" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun_eq_of_injective_of_rightInverse"><span class="name">Function</span>.<span class="name">invFun_eq_of_injective_of_rightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">RightInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.rightInverse_invFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L404-L405">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.rightInverse_invFun" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.rightInverse_invFun"><span class="name">Function</span>.<span class="name">rightInverse_invFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.leftInverse_invFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L407-L408">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.leftInverse_invFun" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.leftInverse_invFun"><span class="name">Function</span>.<span class="name">leftInverse_invFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.invFun_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L410-L411">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun_surjective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun_surjective"><span class="name">Function</span>.<span class="name">invFun_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.invFun_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L413-L414">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.invFun_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun_comp"><span class="name">Function</span>.<span class="name">invFun_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a> <span class="fn">f</span></span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Function.Injective.hasLeftInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L416-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.hasLeftInverse"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">hasLeftInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">HasLeftInverse</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.injective_iff_hasLeftInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L419-L420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_iff_hasLeftInverse"><span class="name">Function</span>.<span class="name">injective_iff_hasLeftInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">HasLeftInverse</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.surjInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L428-L431">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.surjInv" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv"><span class="name">Function</span>.<span class="name">surjInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Œ±</span></div></div><p>The inverse of a surjective function. (Unlike <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.invFun">invFun</a></code>, this does not require
<code>Œ±</code> to be inhabited.)</p><details id="instances-for-list-Function.surjInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.surjInv_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L433-L434">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.surjInv_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv_eq"><span class="name">Function</span>.<span class="name">surjInv_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv">surjInv</a> <span class="fn">h</span> <span class="fn">b</span>)</span></span> <span class="fn">=</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Function.comp_surjInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L436-L438">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.comp_surjInv" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.comp_surjInv"><span class="name">Function</span>.<span class="name">comp_surjInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv">surjInv</a> <span class="fn">hf</span></span></span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Function.rightInverse_surjInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L440-L441">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.rightInverse_surjInv" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.rightInverse_surjInv"><span class="name">Function</span>.<span class="name">rightInverse_surjInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv">surjInv</a> <span class="fn">hf</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.leftInverse_surjInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L443-L444">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.leftInverse_surjInv" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.leftInverse_surjInv"><span class="name">Function</span>.<span class="name">leftInverse_surjInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv">surjInv</a> <span class="fn">‚ãØ</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Surjective.hasRightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L446-L447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.hasRightInverse"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">hasRightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">HasRightInverse</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.surjective_iff_hasRightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L449-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_iff_hasRightInverse"><span class="name">Function</span>.<span class="name">surjective_iff_hasRightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">HasRightInverse</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.bijective_iff_has_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L452-L454">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.bijective_iff_has_inverse" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.bijective_iff_has_inverse"><span class="name">Function</span>.<span class="name">bijective_iff_has_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>), <span class="fn"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">RightInverse</span> <span class="fn">g</span> <span class="fn">f</span></span></span></span></span></div></div></div></div><div class="decl" id="Function.injective_surjInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L456-L457">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.injective_surjInv" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.injective_surjInv"><span class="name">Function</span>.<span class="name">injective_surjInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjInv">surjInv</a> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Function.surjective_to_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L459-L461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_to_subsingleton"><span class="name">Function</span>.<span class="name">surjective_to_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">na</span> : <span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Surjective.piMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L463-L465">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Surjective.piMap" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.piMap"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">piMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">Surjective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.Surjective.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L467-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Surjective.comp_left"><span class="name">Function</span>.<span class="name">Surjective</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">x</span></span></span></span></div></div><p>Composition by a surjective function on the left is itself surjective.</p></div></div><div class="decl" id="Function.surjective_comp_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L472-L476">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_comp_left_iff"><span class="name">Function</span>.<span class="name">surjective_comp_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">Surjective</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">x</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Surjective</span> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.piMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L478-L480">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Bijective.piMap" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.piMap"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">piMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.Bijective.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L482-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_left"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">x</span></span></span></span></div></div><p>Composition by a bijective function on the left is itself bijective.</p></div></div><div class="decl" id="Function.update"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L495-L498">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update"><span class="name">Function</span>.<span class="name">update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></div></div><p>Replacing the value of a function at a given point by a given value.</p><details id="instances-for-list-Function.update" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.update_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L500-L502">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_self" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_self"><span class="name">Function</span>.<span class="name">update_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">v</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Function.update_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L504-L506">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_of_ne" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_of_ne"><span class="name">Function</span>.<span class="name">update_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">‚â†</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a'</span> <span class="fn">v</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.update_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L508-L511">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_apply"><span class="name">Function</span>.<span class="name">update_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a'</span> <span class="fn">b</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">if</span> <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span> <span class="fn">then</span> <span class="fn">b</span> <span class="fn">else</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div><p>On non-dependent functions, <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a></code> can be expressed as an <code>ite</code></p></div></div><div class="decl" id="Function.update_eq_const_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L513-L516">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_eq_const_of_subsingleton" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_eq_const_of_subsingleton"><span class="name">Function</span>.<span class="name">update_eq_const_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Subsingleton</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">v</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">const</span> <span class="fn">Œ±</span> <span class="fn">v</span></span></span></div></div></div></div><div class="decl" id="Function.surjective_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L518-L521">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.surjective_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_eval"><span class="name">Function</span>.<span class="name">surjective_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<span class="fn">Œ≤</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">eval</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="Function.update_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L523-L525">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_injective"><span class="name">Function</span>.<span class="name">update_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a'</span>)</span></span></div></div></div></div><div class="decl" id="Function.forall_update_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L527-L530">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.forall_update_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.forall_update_iff"><span class="name">Function</span>.<span class="name">forall_update_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">‚àß</span> <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <span class="fn">‚â†</span> <span class="fn">a</span></span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Function.exists_update_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L532-L535">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.exists_update_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.exists_update_iff"><span class="name">Function</span>.<span class="name">exists_update_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÉ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">‚à®</span> <span class="fn">‚àÉ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <span class="fn">‚â†</span> <span class="fn">a</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Function.update_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L537-L539">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_eq_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_eq_iff"><span class="name">Function</span>.<span class="name">update_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn">g</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">b</span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span> <span class="fn">‚àß</span> <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <span class="fn">‚â†</span> <span class="fn">a</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Function.eq_update_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L541-L543">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.eq_update_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.eq_update_iff"><span class="name">Function</span>.<span class="name">eq_update_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span> <span class="fn">‚àß</span> <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <span class="fn">‚â†</span> <span class="fn">a</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Function.update_eq_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L545-L545">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_eq_self_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_eq_self_iff"><span class="name">Function</span>.<span class="name">update_eq_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">b</span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="Function.eq_update_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L547-L547">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.eq_update_self_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.eq_update_self_iff"><span class="name">Function</span>.<span class="name">eq_update_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Function.ne_update_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L549-L549">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.ne_update_self_iff"><span class="name">Function</span>.<span class="name">ne_update_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚â†</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">‚â†</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Function.update_ne_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L551-L551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_ne_self_iff"><span class="name">Function</span>.<span class="name">update_ne_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">‚â†</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">b</span> <span class="fn">‚â†</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="Function.update_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L553-L555">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_eq_self" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_eq_self"><span class="name">Function</span>.<span class="name">update_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.update_comp_eq_of_forall_ne'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L557-L559">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_comp_eq_of_forall_ne'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne'"><span class="name">Function</span>.<span class="name">update_comp_eq_of_forall_ne'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±'</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <span class="fn">‚â†</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(fun (<span class="fn">j</span> : <span class="fn">Œ±'</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">j</span> : <span class="fn">Œ±'</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.update_comp_eq_of_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L563-L566">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_comp_eq_of_forall_ne" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne"><span class="name">Function</span>.<span class="name">update_comp_eq_of_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i</span> : <span class="fn">Œ±'</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <span class="fn">‚â†</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">a</span></span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></div></div><p>Non-dependent version of <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_forall_ne'">Function.update_comp_eq_of_forall_ne'</a></code></p></div></div><div class="decl" id="Function.update_comp_eq_of_injective'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L568-L570">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_comp_eq_of_injective'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective'"><span class="name">Function</span>.<span class="name">update_comp_eq_of_injective'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(fun (<span class="fn">j</span> : <span class="fn">Œ±'</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span>)</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">Œ±'</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span>)</span> <span class="fn">i</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.update_apply_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L572-L576">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_apply_of_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_apply_of_injective"><span class="name">Function</span>.<span class="name">update_apply_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">j</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">Œ±'</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span>)</span> <span class="fn">i</span> <span class="fn">a</span> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="Function.update_comp_eq_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L578-L582">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_comp_eq_of_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective"><span class="name">Function</span>.<span class="name">update_comp_eq_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span> <span class="fn">a</span></span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span>)</span> <span class="fn">i</span> <span class="fn">a</span></span></span></div></div><p>Non-dependent version of <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comp_eq_of_injective'">Function.update_comp_eq_of_injective'</a></code></p></div></div><div class="decl" id="Function.rec_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L584-L600">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.rec_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.rec_update"><span class="name">Function</span>.<span class="name">rec_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ∫</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œ∫</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ∫</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ctor</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">Œ∫</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Injective</span> <span class="fn">ctor</span></span> ‚Üí
  <span class="fn">‚àÄ (<span class="fn">recursor</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn">(<span class="fn">i</span> : <span class="fn">Œ∫</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span></span></span>)
    (<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span></span>) (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn"><span class="fn">recursor</span> <span class="fn">f</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span></span></span>)
    (<span class="fn">h2</span> : <span class="fn">‚àÄ (<span class="fn">f‚ÇÅ </span><span class="fn">f‚ÇÇ</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span></span>) (<span class="fn">k</span> : <span class="fn">Œ∫</span>), <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn"><span class="fn">ctor</span> <span class="fn">i</span></span> <span class="fn">‚â†</span> <span class="fn">k</span></span>)</span> ‚Üí <span class="fn"><span class="fn"><span class="fn">recursor</span> <span class="fn">f‚ÇÅ</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">recursor</span> <span class="fn">f‚ÇÇ</span> <span class="fn">k</span></span></span></span></span>)
    (<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span></span>) (<span class="fn">i</span> : <span class="fn">Œπ</span>) (<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">recursor</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">i</span> <span class="fn">x</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">recursor</span> <span class="fn">f</span>)</span> <span class="fn">(<span class="fn">ctor</span> <span class="fn">i</span>)</span> <span class="fn">x</span></span></span></span></span></div></div><p>Recursors can be pushed inside <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a></code>.</p><p>The <code>ctor</code> argument should be a one-argument constructor like <code>Sum.inl</code>,
and <code>recursor</code> should be an inductive recursor partially applied in all but that constructor,
such as <code>(Sum.rec ¬∑ g)</code>.</p><p>In future, we should build some automation to generate applications like <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Option.rec_update">Option.rec_update</a></code> for all
inductive types.</p></div></div><div class="decl" id="Option.rec_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L602-L608">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Option.rec_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Option.rec_update"><span class="name">Option</span>.<span class="name">rec_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">none</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">(<span class="fn">some</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">(<span class="fn">some</span> <span class="fn">a</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(fun (<span class="fn">t</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span>) =&gt; <span class="fn"><span class="fn">rec</span> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a> <span class="fn">g</span> <span class="fn">a</span> <span class="fn">x</span>)</span> <span class="fn">t</span></span>)</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a> <span class="fn">(fun (<span class="fn">t</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span>) =&gt; <span class="fn"><span class="fn">rec</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">t</span></span>)</span> <span class="fn">(<span class="fn">some</span> <span class="fn">a</span>)</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Function.apply_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L610-L613">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.apply_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.apply_update"><span class="name">Function</span>.<span class="name">apply_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn">Œπ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">j</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">v</span> <span class="fn">j</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(fun (<span class="fn">k</span> : <span class="fn">Œπ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<span class="fn">g</span> <span class="fn">k</span>)</span></span>)</span> <span class="fn">i</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span> <span class="fn">v</span>)</span> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="Function.apply_update‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L615-L618">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.apply_update‚ÇÇ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.apply_update‚ÇÇ"><span class="name">Function</span>.<span class="name">apply_update‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≥</span> <span class="fn">i</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn">Œπ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">j</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">v</span> <span class="fn">j</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">h</span> <span class="fn">i</span> <span class="fn">w</span> <span class="fn">j</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(fun (<span class="fn">k</span> : <span class="fn">Œπ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<span class="fn">g</span> <span class="fn">k</span>)</span> <span class="fn">(<span class="fn">h</span> <span class="fn">k</span>)</span></span>)</span> <span class="fn">i</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span> <span class="fn">v</span> <span class="fn">w</span>)</span> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="Function.pred_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L620-L622">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.pred_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.pred_update"><span class="name">Function</span>.<span class="name">pred_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn">‚¶É<span class="fn">a</span> : <span class="fn">Œ±</span>‚¶Ñ ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a'</span> <span class="fn">v</span> <span class="fn">a</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">P</span> <span class="fn">v</span></span></span> <span class="fn">‚à®</span> <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">‚â†</span> <span class="fn">a'</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="Function.comp_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L624-L626">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.comp_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.comp_update"><span class="name">Function</span>.<span class="name">comp_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">v</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span> <span class="fn">i</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.update_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L628-L630">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_comm" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_comm"><span class="name">Function</span>.<span class="name">update_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">‚â†</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">v</span>)</span> <span class="fn">b</span> <span class="fn">w</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">b</span> <span class="fn">w</span>)</span> <span class="fn">a</span> <span class="fn">v</span></span></span></div></div></div></div><div class="decl" id="Function.update_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L632-L635">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.update_idem" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.update_idem"><span class="name">Function</span>.<span class="name">update_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">v </span><span class="fn">w</span> : <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">v</span>)</span> <span class="fn">a</span> <span class="fn">w</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">w</span></span></span></div></div></div></div><div class="decl" id="Pi.map_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L637-L643">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Pi.map_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Pi.map_update"><span class="name">Pi</span>.<span class="name">map_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a> <span class="fn">g</span> <span class="fn">i</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">Function.update</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span> <span class="fn">g</span>)</span> <span class="fn">i</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span> <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="Pi.map_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L645-L655">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Pi.map_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Pi.map_injective"><span class="name">Pi</span>.<span class="name">map_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">Nonempty</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Function.Injective</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span>)</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">Function.Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Function.extend"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L663-L677">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend"><span class="name">Function</span>.<span class="name">extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></div></div><p>Extension of a function <code>g : Œ± ‚Üí Œ≥</code> along a function <code>f : Œ± ‚Üí Œ≤</code>.</p><p>For every <code>a : Œ±</code>, <code>f a</code> is sent to <code>g a</code>. <code>f</code> might not be surjective, so we use an auxiliary
function <code>j : Œ≤ ‚Üí Œ≥</code> by sending <code>b : Œ≤</code> not in the range of <code>f</code> to <code>j b</code>. If you do not care about
the behavior outside the range, <code>j</code> can be used as a junk value by setting it to be <code>0</code> or
<code><a href="../../.././Mathlib/Logic/Nonempty.html#Classical.arbitrary">Classical.arbitrary</a></code> (assuming <code>Œ≥</code> is nonempty).</p><p>This definition is mathematically meaningful only when <code>f a‚ÇÅ = f a‚ÇÇ ‚Üí g a‚ÇÅ = g a‚ÇÇ</code> (spelled
<code>g.<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> f</code>). In particular this holds if <code>f</code> is injective.</p><p>A typical use case is extending a function from a subtype to the entire type. If you wish to extend
<code>g : {b : Œ≤ // p b} ‚Üí Œ≥</code> to a function <code>Œ≤ ‚Üí Œ≥</code>, you should use <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">Function.extend</a> Subtype.val g j</code>.</p><details id="instances-for-list-Function.extend" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.FactorsThrough"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L679-L681">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.FactorsThrough" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough"><span class="name">Function</span>.<span class="name">FactorsThrough</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>g factors through f : <code>f a = f b ‚Üí g a = g b</code></p><details id="instances-for-list-Function.FactorsThrough" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.extend_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L683-L686">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_def" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_def"><span class="name">Function</span>.<span class="name">extend_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">(‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn">if h : <span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span> then <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">Classical.choose</span> <span class="fn">h</span>)</span></span> else <span class="fn"><span class="fn">e'</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Function.Injective.factorsThrough"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L688-L689">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.factorsThrough" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.factorsThrough"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">factorsThrough</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.FactorsThrough.extend_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L691-L695">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.FactorsThrough.extend_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_apply"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">extend_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.Injective.extend_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L697-L700">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.extend_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.extend_apply"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">extend_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.extend_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L702-L706">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_apply'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_apply'"><span class="name">Function</span>.<span class="name">extend_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn">¬¨</span><span class="fn">‚àÉ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span> <span class="fn">b</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">e'</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Function.extend_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L708-L711">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_id"><span class="name">Function</span>.<span class="name">extend_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g </span><span class="fn">e'</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">id</span> <span class="fn">g</span> <span class="fn">e'</span></span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.Injective.extend_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L713-L727">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective.extend_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.extend_comp"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">extend_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±‚ÇÅ</span> : <a href="../../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±‚ÇÇ</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±‚ÇÉ</span> : <a href="../../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f‚ÇÅ‚ÇÇ</span> : <span class="fn"><span class="fn">Œ±‚ÇÅ</span> ‚Üí <span class="fn">Œ±‚ÇÇ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ‚ÇÇ</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f‚ÇÅ‚ÇÇ</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f‚ÇÇ‚ÇÉ</span> : <span class="fn"><span class="fn">Œ±‚ÇÇ</span> ‚Üí <span class="fn">Œ±‚ÇÉ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ‚ÇÉ</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f‚ÇÇ‚ÇÉ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±‚ÇÅ</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ±‚ÇÉ</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">(<span class="fn">f‚ÇÇ‚ÇÉ</span> <span class="fn">‚àò</span> <span class="fn">f‚ÇÅ‚ÇÇ</span>)</span> <span class="fn">g</span> <span class="fn">e'</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f‚ÇÇ‚ÇÉ</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f‚ÇÅ‚ÇÇ</span> <span class="fn">g</span> <span class="fn">(<span class="fn">e'</span> <span class="fn">‚àò</span> <span class="fn">f‚ÇÇ‚ÇÉ</span>)</span>)</span> <span class="fn">e'</span></span></span></div></div></div></div><div class="decl" id="Function.factorsThrough_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L729-L732">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.factorsThrough_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.factorsThrough_iff"><span class="name">Function</span>.<span class="name">factorsThrough_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ≥</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">e</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>), <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn"><span class="fn">e</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></span></span></div></div></div></div><div class="decl" id="Function.apply_extend"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L734-L736">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.apply_extend" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.apply_extend"><span class="name">Function</span>.<span class="name">apply_extend</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span> <span class="fn">b</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">(<span class="fn">F</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span> <span class="fn">(<span class="fn">F</span> <span class="fn">‚àò</span> <span class="fn">e'</span>)</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Function.extend_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L738-L743">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_injective"><span class="name">Function</span>.<span class="name">extend_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span></span></span></span></div></div></div></div><div class="decl" id="Function.FactorsThrough.extend_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L745-L747">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.FactorsThrough.extend_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.extend_comp"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">extend_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span></span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.extend_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L749-L751">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_const" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_const"><span class="name">Function</span>.<span class="name">extend_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">Œ≥</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn">c</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">Œ≤</span>) =&gt; <span class="fn">c</span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">Œ≤</span>) =&gt; <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Function.extend_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L753-L755">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.extend_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend_comp"><span class="name">Function</span>.<span class="name">extend_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e'</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.extend">extend</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">e'</span></span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Function.Injective.surjective_comp_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L757-L759">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right'"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">surjective_comp_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g‚ÇÄ</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="Function.Injective.surjective_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L761-L763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective.surjective_comp_right"><span class="name">Function</span>.<span class="name">Injective</span>.<span class="name">surjective_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ≥</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="Function.surjective_comp_right_iff_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L765-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.surjective_comp_right_iff_injective"><span class="name">Function</span>.<span class="name">surjective_comp_right_iff_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">Œ≥</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">Surjective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Bijective.comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L778-L781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Bijective.comp_right"><span class="name">Function</span>.<span class="name">Bijective</span>.<span class="name">comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="Function.FactorsThrough.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L787-L787">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.FactorsThrough.rfl" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.rfl"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">f</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.FactorsThrough.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L789-L791">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_left"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">(<span class="fn">g'</span> <span class="fn">‚àò</span> <span class="fn">g</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.FactorsThrough.comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L793-L795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough.comp_right"><span class="name">Function</span>.<span class="name">FactorsThrough</span>.<span class="name">comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn"><span class="fn">Œ¥</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">FactorsThrough</a> <span class="fn">(<span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn">g'</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">g'</span>)</span></span></div></div></div></div><div class="decl" id="Function.uncurry_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L801-L802">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_def"><span class="name">Function</span>.<span class="name">uncurry_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≤</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.1</span> <span class="fn"><span class="fn">p</span>.2</span></span></span></span></div></div></div></div><div class="decl" id="Function.uncurry_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L804-L805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_injective"><span class="name">Function</span>.<span class="name">uncurry_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">uncurry</span></span></div></div></div></div><div class="decl" id="Function.curry_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.curry_injective"><span class="name">Function</span>.<span class="name">curry_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">curry</span></span></div></div></div></div><div class="decl" id="Function.uncurry_flip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_flip"><span class="name">Function</span>.<span class="name">uncurry_flip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">(<span class="fn">flip</span> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">f</span></span> <span class="fn">‚àò</span> <span class="fn">Prod.swap</span></span></span></div></div></div></div><div class="decl" id="Function.flip_curry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L813-L814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.flip_curry"><span class="name">Function</span>.<span class="name">flip_curry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≤</span></span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">flip</span> <span class="fn">(<span class="fn">curry</span> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">curry</span> <span class="fn">(<span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">Prod.swap</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.curry_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L816-L822">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.curry_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.curry_update"><span class="name">Function</span>.<span class="name">curry_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ±'</span></span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">aa'</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ±'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">curry</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">aa'</span> <span class="fn">b</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">curry</span> <span class="fn">f</span>)</span> <span class="fn"><span class="fn">aa'</span>.1</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">curry</span> <span class="fn">f</span> <span class="fn"><span class="fn">aa'</span>.1</span>)</span> <span class="fn"><span class="fn">aa'</span>.2</span> <span class="fn">b</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.uncurry_update_update"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L824-L829">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.uncurry_update_update" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_update_update"><span class="name">Function</span>.<span class="name">uncurry_update_update</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±'</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ±'</span> ‚Üí <span class="fn">Œ≤</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">Œ±'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">a'</span> <span class="fn">b</span>)</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.update">update</a> <span class="fn">(<span class="fn">uncurry</span> <span class="fn">f</span>)</span> <span class="fn"><span class="fn">(</span><span class="fn">a</span><span class="fn">,</span> <span class="fn">a'</span><span class="fn">)</span></span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Function.bicompl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L837-L840">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.bicompl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.bicompl"><span class="name">Function</span>.<span class="name">bicompl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œµ</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn"><span class="fn">Œ¥</span> ‚Üí <span class="fn">Œµ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Œµ</span></div></div><p>Compose a binary function <code>f</code> with a pair of unary functions <code>g</code> and <code>h</code>.
If both arguments of <code>f</code> have the same type and <code>g = h</code>, then <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.bicompl">bicompl</a> f g g = f on g</code>.</p><details id="instances-for-list-Function.bicompl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.bicompr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L842-L844">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.bicompr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.bicompr"><span class="name">Function</span>.<span class="name">bicompr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Œ¥</span></div></div><p>Compose a unary function <code>f</code> with a binary function <code>g</code>.</p><details id="instances-for-list-Function.bicompr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.uncurry_bicompr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L849-L850">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.uncurry_bicompr" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompr"><span class="name">Function</span>.<span class="name">uncurry_bicompr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.bicompr">bicompr</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">g</span> <span class="fn">‚àò</span> <span class="fn"><span class="fn">uncurry</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="Function.uncurry_bicompl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L852-L854">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.uncurry_bicompl" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.uncurry_bicompl"><span class="name">Function</span>.<span class="name">uncurry_bicompl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œµ</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≥</span> ‚Üí <span class="fn"><span class="fn">Œ¥</span> ‚Üí <span class="fn">Œµ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≥</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ¥</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.bicompl">bicompl</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn">uncurry</span> <span class="fn">f</span></span> <span class="fn">‚àò</span> <span class="fn"><span class="fn">Prod.map</span> <span class="fn">g</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="Function.HasUncurry"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L862-L869">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.HasUncurry" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.HasUncurry"><span class="name">Function</span>.<span class="name">HasUncurry</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_5)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">outParam</span> <a href="../../.././foundational_types.html">(Type</a> u_6)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">outParam</span> <a href="../../.././foundational_types.html">(Type</a> u_7)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max (max u_5 u_6) u_7)</div></div><p>Records a way to turn an element of <code>Œ±</code> into a function from <code>Œ≤</code> to <code>Œ≥</code>. The most generic use
is to recursively uncurry. For instance <code>f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥</code> will be turned into
<code>‚Üøf : Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œ¥</code>. One can also add instances for bundled maps.</p><ul class="structure_fields" id="Function.HasUncurry.mk"><li id="Function.HasUncurry.uncurry" class="structure_field"><div class="structure_field_info">uncurry : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span></div><div class="structure_field_doc"><p>Uncurrying operator. The most generic use is to recursively uncurry. For instance
<code>f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥</code> will be turned into <code>‚Üøf : Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œ¥</code>. One can also add instances
for bundled maps.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Function.HasUncurry" class="instances-list"></ul></details></div></div><div class="decl" id="Function.¬´term‚Üø_¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L871-L871">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.¬´term‚Üø_¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.¬´term‚Üø_¬ª"><span class="name">Function</span>.<span class="name">¬´term‚Üø_¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Uncurrying operator. The most generic use is to recursively uncurry. For instance
<code>f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥</code> will be turned into <code>‚Üøf : Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œ¥</code>. One can also add instances
for bundled maps.</p><details id="instances-for-list-Function.¬´term‚Üø_¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.hasUncurryBase"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L873-L874">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.hasUncurryBase" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.hasUncurryBase"><span class="name">Function</span>.<span class="name">hasUncurryBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.HasUncurry">HasUncurry</a> <span class="fn">(<span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span>)</span> <span class="fn">Œ±</span> <span class="fn">Œ≤</span></span></div></div></div></div><div class="decl" id="Function.hasUncurryInduction"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L876-L877">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.hasUncurryInduction" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.hasUncurryInduction"><span class="name">Function</span>.<span class="name">hasUncurryInduction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ¥</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.HasUncurry">HasUncurry</a> <span class="fn">Œ≤</span> <span class="fn">Œ≥</span> <span class="fn">Œ¥</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.HasUncurry">HasUncurry</a> <span class="fn">(<span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span>)</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≥</span>)</span> <span class="fn">Œ¥</span></span></div></div></div></div><div class="decl" id="Function.Involutive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L881-L883">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Involutive" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive"><span class="name">Function</span>.<span class="name">Involutive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function is involutive, if <code>f ‚àò f = id</code>.</p><details id="instances-for-list-Function.Involutive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bool.involutive_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L885-L886">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Bool.involutive_not" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Bool.involutive_not"><span class="name">Bool</span>.<span class="name">involutive_not</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Function.Involutive</a> <span class="fn">not</span></span></div></div></div></div><div class="decl" id="Function.Involutive.comp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L894-L896">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.comp_self"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">comp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Function.Involutive.leftInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L898-L898">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">leftInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">f</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Involutive.leftInverse_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L900-L902">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.leftInverse_iff"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">leftInverse_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Involutive.rightInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L904-L904">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.rightInverse"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">rightInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">RightInverse</span> <span class="fn">f</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Involutive.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L906-L906">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.injective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Involutive.surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L908-L908">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.surjective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Involutive.bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L910-L910">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Involutive.bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.bijective"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">bijective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Function.Involutive.ite_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L912-L914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.ite_not"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">ite_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">if</span> <span class="fn">P</span> <span class="fn">then</span> <span class="fn">x</span> <span class="fn">else</span> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">if</span> <span class="fn"><span class="fn">¬¨</span><span class="fn">P</span></span> <span class="fn">then</span> <span class="fn">x</span> <span class="fn">else</span> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></span></span></div></div><p>Involuting an <code>ite</code> of an involuted value <code>x : Œ±</code> negates the <code>Prop</code> condition in the <code>ite</code>.</p></div></div><div class="decl" id="Function.Involutive.eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L916-L918">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.eq_iff"><span class="name">Function</span>.<span class="name">Involutive</span>.<span class="name">eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn">y</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span></span></div></div><p>An involution commutes across an equality. Compare to <code>Function.Injective.<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive.eq_iff">eq_iff</a></code>.</p></div></div><div class="decl" id="Function.not_involutive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L922-L922">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.not_involutive" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_involutive"><span class="name">Function</span>.<span class="name">not_involutive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">Not</span></span></div></div></div></div><div class="decl" id="Function.not_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L923-L923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_injective"><span class="name">Function</span>.<span class="name">not_injective</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">Not</span></span></div></div></div></div><div class="decl" id="Function.not_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L924-L924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_surjective"><span class="name">Function</span>.<span class="name">not_surjective</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Surjective</span> <span class="fn">Not</span></span></div></div></div></div><div class="decl" id="Function.not_bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L925-L925">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.not_bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.not_bijective"><span class="name">Function</span>.<span class="name">not_bijective</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Bijective</a> <span class="fn">Not</span></span></div></div></div></div><div class="decl" id="Function.symmetric_apply_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L927-L929">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.symmetric_apply_eq_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.symmetric_apply_eq_iff"><span class="name">Function</span>.<span class="name">symmetric_apply_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x1</span></span> <span class="fn">=</span> <span class="fn">x2</span></span></span>)</span> <span class="fn">‚Üî</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Involutive</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Function.Injective2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L931-L935">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.Injective2" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2"><span class="name">Function</span>.<span class="name">Injective2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>The property of a binary function <code>f : Œ± ‚Üí Œ≤ ‚Üí Œ≥</code> being injective.
Mathematically this should be thought of as the corresponding function <code>Œ± √ó Œ≤ ‚Üí Œ≥</code> being injective.</p><details id="instances-for-list-Function.Injective2" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.Injective2.left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L941-L943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.left"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div><p>A binary injective function is injective when only the left argument varies.</p></div></div><div class="decl" id="Function.Injective2.right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L945-L947">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.right"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div><p>A binary injective function is injective when only the right argument varies.</p></div></div><div class="decl" id="Function.Injective2.uncurry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L949-L951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.uncurry"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">uncurry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">(<span class="fn">uncurry</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Function.Injective2.left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L953-L956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.left'"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">f</span></span></div></div><p>As a map from the left argument to a unary function, <code>f</code> is injective.</p></div></div><div class="decl" id="Function.Injective2.right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L958-L962">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.right'"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Injective</span> <span class="fn">fun (<span class="fn">b</span> : <span class="fn">Œ≤</span>) (<span class="fn">a</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div><p>As a map from the right argument to a unary function, <code>f</code> is injective.</p></div></div><div class="decl" id="Function.Injective2.eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L964-L965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2.eq_iff"><span class="name">Function</span>.<span class="name">Injective2</span>.<span class="name">eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≥</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Injective2">Injective2</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a‚ÇÅ </span><span class="fn">a‚ÇÇ</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b‚ÇÅ </span><span class="fn">b‚ÇÇ</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a‚ÇÅ</span> <span class="fn">b‚ÇÅ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a‚ÇÇ</span> <span class="fn">b‚ÇÇ</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">a‚ÇÅ</span> <span class="fn">=</span> <span class="fn">a‚ÇÇ</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">b‚ÇÅ</span> <span class="fn">=</span> <span class="fn">b‚ÇÇ</span></span></span></span></div></div></div></div><div class="decl" id="Function.sometimes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L971-L976">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.sometimes" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes"><span class="name">Function</span>.<span class="name">sometimes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Œ≤</span></div></div><p><code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes">sometimes</a> f</code> evaluates to some value of <code>f</code>, if it exists. This function is especially
interesting in the case where <code>Œ±</code> is a proposition, in which case <code>f</code> is necessarily a
constant function, so that <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes">sometimes</a> f = f a</code> for all <code>a</code>.</p><details id="instances-for-list-Function.sometimes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.sometimes_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L978-L979">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.sometimes_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes_eq"><span class="name">Function</span>.<span class="name">sometimes_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">p</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes">sometimes</a> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.sometimes_spec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L981-L983">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Function.sometimes_spec" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes_spec"><span class="name">Function</span>.<span class="name">sometimes_spec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">p</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">p</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">P</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.sometimes">sometimes</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="forall_existsUnique_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L991-L1000">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#forall_existsUnique_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff"><span class="name">forall_existsUnique_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">b</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ≤</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>), <span class="fn">‚àÄ {<span class="fn">a</span> : <span class="fn">Œ±</span>} {<span class="fn">b</span> : <span class="fn">Œ≤</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></span></span></span></div></div><p>A relation <code>r : Œ± ‚Üí Œ≤ ‚Üí Prop</code> is &quot;function-like&quot;
(for each <code>a</code> there exists a unique <code>b</code> such that <code>r a b</code>)
if and only if it is <code>(f ¬∑ = ¬∑)</code> for some function <code>f</code>.</p></div></div><div class="decl" id="forall_existsUnique_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1002-L1007">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#forall_existsUnique_iff'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#forall_existsUnique_iff'"><span class="name">forall_existsUnique_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">b</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ≤</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> : <span class="fn">Œ±</span>) (<span class="fn">x2</span> : <span class="fn">Œ≤</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x1</span></span> <span class="fn">=</span> <span class="fn">x2</span></span></span></span></span></span></div></div><p>A relation <code>r : Œ± ‚Üí Œ≤ ‚Üí Prop</code> is &quot;function-like&quot;
(for each <code>a</code> there exists a unique <code>b</code> such that <code>r a b</code>)
if and only if it is <code>(f ¬∑ = ¬∑)</code> for some function <code>f</code>.</p></div></div><div class="decl" id="Symmetric.forall_existsUnique_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1009-L1016">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Symmetric.forall_existsUnique_iff'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff'"><span class="name">Symmetric</span>.<span class="name">forall_existsUnique_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">b</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ±</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Function.Involutive</a> <span class="fn">f</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">Œ±</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x1</span></span> <span class="fn">=</span> <span class="fn">x2</span></span></span></span></span></span></span></div></div><p>A symmetric relation <code>r : Œ± ‚Üí Œ± ‚Üí Prop</code> is &quot;function-like&quot;
(for each <code>a</code> there exists a unique <code>b</code> such that <code>r a b</code>)
if and only if it is <code>(f ¬∑ = ¬∑)</code> for some involutive function <code>f</code>.</p></div></div><div class="decl" id="Symmetric.forall_existsUnique_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1018-L1023">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Symmetric.forall_existsUnique_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Symmetric.forall_existsUnique_iff"><span class="name">Symmetric</span>.<span class="name">forall_existsUnique_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">a</span> : <span class="fn">Œ±</span>), <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">‚àÉ!</a> <span class="fn">b</span> <a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">:</a> <span class="fn">Œ±</span><a href="../../.././Mathlib/Logic/ExistsUnique.html#ExistsUnique">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <span class="fn">‚Üî</span> <span class="fn">‚àÉ (<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.Involutive">Function.Involutive</a> <span class="fn">f</span></span> <span class="fn">‚àß</span> <span class="fn">‚àÄ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Œ±</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <span class="fn">=</span> <span class="fn">b</span></span></span></span></span></span></span></div></div><p>A symmetric relation <code>r : Œ± ‚Üí Œ± ‚Üí Prop</code> is &quot;function-like&quot;
(for each <code>a</code> there exists a unique <code>b</code> such that <code>r a b</code>)
if and only if it is <code>(f ¬∑ = ¬∑)</code> for some involutive function <code>f</code>.</p></div></div><div class="decl" id="Set.piecewise"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1025-L1028">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Set.piecewise" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Set.piecewise"><span class="name">Set</span>.<span class="name">piecewise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">j</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">j</span> <span class="fn">‚àà</span> <span class="fn">s</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></div></div><p><code>s.<a href="../../.././Mathlib/Logic/Function/Basic.html#Set.piecewise">piecewise</a> f g</code> is the function equal to <code>f</code> on the set <code>s</code>, and to <code>g</code> on its complement.</p><details id="instances-for-list-Set.piecewise" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Bijectivity-of-Eq-rec-Eq-mp-Eq-mpr-and-cast" class="markdown-heading">Bijectivity of <code>Eq.rec</code>, <code>Eq.mp</code>, <code>Eq.mpr</code>, and <code>cast</code> <a class="hover-link" href="#Bijectivity-of-Eq-rec-Eq-mp-Eq-mpr-and-cast">#</a></h3></div><div class="decl" id="eq_rec_on_bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1033-L1035">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#eq_rec_on_bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#eq_rec_on_bijective"><span class="name">eq_rec_on_bijective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Function.Bijective</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>) =&gt; <span class="fn"><span class="fn">h</span> <span class="fn">‚ñ∏</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="eq_mp_bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1037-L1041">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#eq_mp_bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#eq_mp_bijective"><span class="name">eq_mp_bijective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">=</span> <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Function.Bijective</a> <span class="fn"><span class="fn">h</span>.<span class="fn">mp</span></span></span></div></div></div></div><div class="decl" id="eq_mpr_bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1043-L1045">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#eq_mpr_bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#eq_mpr_bijective"><span class="name">eq_mpr_bijective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">=</span> <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Function.Bijective</a> <span class="fn"><span class="fn">h</span>.<span class="fn">mpr</span></span></span></div></div></div></div><div class="decl" id="cast_bijective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1047-L1049">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#cast_bijective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#cast_bijective"><span class="name">cast_bijective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">=</span> <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Bijective">Function.Bijective</a> <span class="fn">(<span class="fn">cast</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="mod_doc"><p>Note these lemmas apply to <code>Type*</code> not <code>Sort*</code>, as the latter interferes with <code>simp</code>, and
is trivial anyway.</p></div><div class="decl" id="eq_rec_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1054-L1057">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#eq_rec_inj"><span class="name">eq_rec_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> <span class="fn">=</span> <span class="fn">a'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_3</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h</span> <span class="fn">‚ñ∏</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">h</span> <span class="fn">‚ñ∏</span> <span class="fn">y</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="cast_inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1059-L1061">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#cast_inj"><span class="name">cast_inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ± </span><span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">=</span> <span class="fn">Œ≤</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">cast</span> <span class="fn">h</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">cast</span> <span class="fn">h</span> <span class="fn">y</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.eq_rec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1063-L1067">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≥</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">‚ãØ</span> <span class="fn">‚ñ∏</span> <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span>)</span></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.eq_rec_on_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1069-L1073">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.eq_rec_on_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">eq_rec_on_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≥</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Eq.recOn</span> <span class="fn">‚ãØ</span> <span class="fn">(<span class="fn">C</span> <span class="fn">(<span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span>)</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Function.LeftInverse.cast_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1075-L1078">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Function.LeftInverse.cast_eq"><span class="name">Function</span>.<span class="name">LeftInverse</span>.<span class="name">cast_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ±</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">LeftInverse</span> <span class="fn">g</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn">Œ≥</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">cast</span> <span class="fn">‚ãØ</span> <span class="fn">(<span class="fn">C</span> <span class="fn">(<span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span>)</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Set.SeparatesPoints"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1080-L1083">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Set.SeparatesPoints" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Set.SeparatesPoints"><span class="name">Set</span>.<span class="name">SeparatesPoints</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A set of functions &quot;separates points&quot;
if for each pair of distinct points there is a function taking different values on them.</p><details id="instances-for-list-Set.SeparatesPoints" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="InvImage.equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1085-L1087">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#InvImage.equivalence"><span class="name">InvImage</span>.<span class="name">equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">Equivalence</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Equivalence</span> <span class="fn">(<span class="fn">InvImage</span> <span class="fn">r</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="instDecidableUncurryOfFstSnd_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1089-L1091">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#instDecidableUncurryOfFstSnd_mathlib" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#instDecidableUncurryOfFstSnd_mathlib"><span class="name">instDecidableUncurryOfFstSnd_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≤</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">r</span> <span class="fn"><span class="fn">x</span>.1</span> <span class="fn"><span class="fn">x</span>.2</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">Function.uncurry</span> <span class="fn">r</span> <span class="fn">x</span>)</span></span></div></div></div></div><div class="decl" id="instDecidableCurryOfMk_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1093-L1095">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#instDecidableCurryOfMk_mathlib" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#instDecidableCurryOfMk_mathlib"><span class="name">instDecidableCurryOfMk_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≤</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Œ±</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Œ≤</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">r</span> <span class="fn"><span class="fn">(</span><span class="fn">a</span><span class="fn">,</span> <span class="fn">b</span><span class="fn">)</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">Function.curry</span> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Pi.map_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1101-L1101">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Pi.map_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Pi.map_id"><span class="name">Pi</span>.<span class="name">map_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">Œπ</span>) =&gt; <span class="fn">id</span></span>)</span> <span class="fn">=</span> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="Pi.map_id'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1103-L1103">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Pi.map_id'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Pi.map_id'"><span class="name">Pi</span>.<span class="name">map_id'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">Œπ</span>) (<span class="fn">a</span> : <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span>) =&gt; <span class="fn">a</span></span>)</span> <span class="fn">=</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span></span>) =&gt; <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Pi.map_comp_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Logic/Function/Basic.lean#L1105-L1107">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Logic_Function_Basic.html#Pi.map_comp_map" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/Basic.html#Pi.map_comp_map"><span class="name">Pi</span>.<span class="name">map_comp_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≥</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_6</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ±</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">Œ≤</span> <span class="fn">i</span></span> ‚Üí <span class="fn"><span class="fn">Œ≥</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">g</span></span> <span class="fn">‚àò</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">f</span></span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Pi.map">Pi.map</a> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">Œπ</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">i</span></span> <span class="fn">‚àò</span> <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span></span></span></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>