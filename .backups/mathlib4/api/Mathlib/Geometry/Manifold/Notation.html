<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Geometry.Manifold.Notation</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Geometry.Manifold.Notation";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Geometry</span>.<span class="name">Manifold</span>.<span class="name">Notation</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html">Mathlib.Geometry.Manifold.ContMDiff.Defs</a></li><li><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html">Mathlib.Geometry.Manifold.MFDeriv.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Geometry.Manifold.Notation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.totalSpaceMk"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">totalSpaceMk</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termT%_Â»"><span class="name">Manifold</span>.<span class="name">Â«termT%_Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.NormedSpaceInfo"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">NormedSpaceInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.instInhabitedNormedSpaceInfo.default"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedNormedSpaceInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.instInhabitedNormedSpaceInfo"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedNormedSpaceInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.FindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">FindModelResult</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.instInhabitedFindModelResult.default"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedFindModelResult</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.instInhabitedFindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedFindModelResult</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.instCoeExprFindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instCoeExprFindModelResult</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.findModelInner"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModelInner</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.findModel"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModel</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Elab.findModels"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModels</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termMDiffAt[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMDiffAt[_]__Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.termMDiffAt__"><span class="name">Manifold</span>.<span class="name">termMDiffAt__</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termMDiff[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMDiff[_]__Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.termMDiff__"><span class="name">Manifold</span>.<span class="name">termMDiff__</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termCMDiffAt[_]____Â»"><span class="name">Manifold</span>.<span class="name">Â«termCMDiffAt[_]____Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.termCMDiffAt____"><span class="name">Manifold</span>.<span class="name">termCMDiffAt____</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termCMDiff[_]____Â»"><span class="name">Manifold</span>.<span class="name">Â«termCMDiff[_]____Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.termCMDiff____"><span class="name">Manifold</span>.<span class="name">termCMDiff____</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termMfderiv[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMfderiv[_]__Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termMfderiv%__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMfderiv%__Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termHasMFDerivAt[_]______Â»"><span class="name">Manifold</span>.<span class="name">Â«termHasMFDerivAt[_]______Â»</span></a></div><div class="nav_link"><a class="break_within" href="#Manifold.Â«termHasMFDerivAt%______Â»"><span class="name">Manifold</span>.<span class="name">Â«termHasMFDerivAt%______Â»</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Elaborators-for-differential-geometry" class="markdown-heading">Elaborators for differential geometry <a class="hover-link" href="#Elaborators-for-differential-geometry">#</a></h1><p>This file defines custom elaborators for differential geometry to allow for more compact notation.
We introduce a class of elaborators for handling differentiability on manifolds, and the elaborator
<code>T%</code> for converting dependent sections of fibre bundles into non-dependent functions into the total
space.</p><p>All of these elaborators are scoped to the <code>Manifold</code> namespace.</p><h2 id="Differentiability-on-manifolds" class="markdown-heading">Differentiability on manifolds <a class="hover-link" href="#Differentiability-on-manifolds">#</a></h2><p>We provide compact notation for differentiability and continuous differentiability on manifolds,
including inference of the model with corners.</p><table><thead><tr><th>Notation</th><th>Elaborates to</th></tr></thead><tbody><tr><td><code>MDiff f</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiable">MDifferentiable</a> I J f</code></td></tr><tr><td><code>MDiffAt f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableAt">MDifferentiableAt</a> I J f x</code></td></tr><tr><td><code>MDiff[u] f</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableOn">MDifferentiableOn</a> I J f u</code></td></tr><tr><td><code>MDiffAt[u] f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableWithinAt">MDifferentiableWithinAt</a> I J f u x</code></td></tr><tr><td><code>CMDiff n f</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiff">ContMDiff</a> I J n f</code></td></tr><tr><td><code>CMDiffAt n f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffAt">ContMDiffAt</a> I J n f x</code></td></tr><tr><td><code>CMDiff[u] n f</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffOn">ContMDiffOn</a> I J n f u</code></td></tr><tr><td><code>CMDiffAt[u] n f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffWithinAt">ContMDiffWithinAt</a> I J n f u x</code></td></tr><tr><td><code>mfderiv[u] f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#mfderivWithin">mfderivWithin</a> I J f u x</code></td></tr><tr><td><code>mfderiv% f x</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#mfderiv">mfderiv</a> I J f x</code></td></tr><tr><td><code>HasMFDerivAt[s] f x f'</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#HasMFDerivWithinAt">HasMFDerivWithinAt</a> I J f s x f'</code></td></tr><tr><td><code>HasMFDerivAt% f x f'</code></td><td><code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#HasMFDerivAt">HasMFDerivAt</a> I J f x f'</code></td></tr></tbody></table><p>In each of these cases, the models with corners are inferred from the domain and codomain of <code>f</code>.
The search for models with corners uses the local context and is (almost) only based on expression
structure, hence hopefully fast enough to always run.</p><p>Inferring models with corners supports all current <code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#ModelWithCorners">ModelWithCorners</a></code> instances in mathlib.
This will need to be updated as new instances are added.</p><p>For products of manifolds, we explicitly track if the resulting space is a product of normed spaces:
that case is ambiguous, and the elaborators would need to make a choice between e.g. the
trivial model with corners on a product <code>E Ã— F</code> and the product of the trivial models on <code>E</code> and
<code>F</code>). If we encounter such an ambiguity, we warn about it and do not infer a model with corners.</p><h2 id="T" class="markdown-heading"><code>T%</code> <a class="hover-link" href="#T">#</a></h2><p>Secondly, this file adds an elaborator <code>T%</code> to ease working with sections in a fibre bundle,
which converts a section <code>s : Î  x : M, V x</code> to a non-dependent function into the total space of the
bundle.</p><pre><code class="language-lean">-- omitted: let `V` be a fibre bundle over `M`

variable {Ïƒ : Î  x : M, V x} in
#check T% Ïƒ -- `(fun x â†¦ TotalSpace.mk' F x (Ïƒ x)) : M â†’ TotalSpace F V`

-- Note how the name of the bound variable `x` is preserved.
variable {Ïƒ : (x : E) â†’ Trivial E E' x} in
#check T% Ïƒ -- `(fun x â†¦ TotalSpace.mk' E' x (Ïƒ x)) : E â†’ TotalSpace E' (Trivial E E')`

variable {s : E â†’ E'} in
#check T% s -- `(fun a â†¦ TotalSpace.mk' E' a (s a)) : E â†’ TotalSpace E' (Trivial E E')`
</code></pre><hr>
<p>These elaborators can be combined: <code>CMDiffAt[u] n (T% s) x</code></p><h2 id="TODO" class="markdown-heading">TODO <a class="hover-link" href="#TODO">#</a></h2><ul><li>try an opinionated strategy on products of normed spaces:
is one guess correct more often than the other?</li><li>alternatively, can the elaborator generate two <code>Try this</code> suggestions, corresponding to the
possible options?</li><li>add delaborators for these elaborators</li><li>add elaborators for more notation</li><li>make the model finding extensible, by converting it to an environment extension</li></ul><p>If you would like to work on any of these, please coordinate with Michael Rothgang (@grunweg)
to avoid duplicating or conflicting work.</p></div><div class="decl" id="Manifold.Elab.totalSpaceMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L124-L188">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.totalSpaceMk" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.totalSpaceMk"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">totalSpaceMk</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Utility for sections in a fibre bundle: if an expression <code>e</code> is a section
<code>s : Î  x : M, V x</code> as a dependent function, convert it to a non-dependent function into the total
space. This handles the cases of</p><ul><li>sections of a trivial bundle</li><li>vector fields on a manifold (i.e., sections of the tangent bundle)</li><li>sections of an explicit fibre bundle</li><li>turning a bare function <code>E â†’ E'</code> into a section of the trivial bundle <code><a href="../../.././Mathlib/Data/Bundle.html#Bundle.Trivial">Bundle.Trivial</a> E E'</code></li></ul><p>This searches the local context for suitable hypotheses for the above cases by matching
on the expression structure, avoiding <code>isDefEq</code>. Therefore, it should be fast enough to always run.
This process can be traced with <code>set_option Elab.DiffGeo.TotalSpaceMk true</code>.</p><p>All applications of <code>e</code> in the resulting expression are beta-reduced.
If none of the handled cases apply, we simply return <code>e</code> (after beta-reducing).</p><p>This function is used for implementing the <code>T%</code> elaborator.</p><details id="instances-for-list-Manifold.Elab.totalSpaceMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termT%_Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L193-L206">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termT%_Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termT%_Â»"><span class="name">Manifold</span>.<span class="name">Â«termT%_Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Elaborator for sections in a fibre bundle: converts a section <code>s : Î  x : M, V x</code> as a dependent
function to a non-dependent function into the total space. This handles the cases of</p><ul><li>sections of a trivial bundle</li><li>vector fields on a manifold (i.e., sections of the tangent bundle)</li><li>sections of an explicit fibre bundle</li><li>turning a bare function <code>E â†’ E'</code> into a section of the trivial bundle <code><a href="../../.././Mathlib/Data/Bundle.html#Bundle.Trivial">Bundle.Trivial</a> E E'</code></li></ul><p>This elaborator searches the local context for suitable hypotheses for the above cases by matching
on the expression structure, avoiding <code>isDefEq</code>. Therefore, it should be fast enough to always run.
The search can be traced with <code>set_option Elab.DiffGeo.TotalSpaceMk true</code>.</p><details id="instances-for-list-Manifold.Â«termT%_Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.NormedSpaceInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L227-L240">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.NormedSpaceInfo" class="verification-badge comp-datatype" title="Computational datatype">ğŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.NormedSpaceInfo"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">NormedSpaceInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Captures information when a model with corners is the trivial model on a normed space
(or on an inner product space, which is also a normed space):
contains the expressions describing the normed space and its base field.</p><p>Searching for a model with corners will return an <code>Option <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.NormedSpaceInfo">NormedSpaceInfo</a></code>,
which is <code>some</code> if and only if the trivial model on a normed space was found.</p><ul class="structure_fields" id="Manifold.Elab.NormedSpaceInfo.mk"><li id="Manifold.Elab.NormedSpaceInfo.normedSpace" class="structure_field"><div class="structure_field_info">normedSpace : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The expression for the normed space itself.</p></div></li><li id="Manifold.Elab.NormedSpaceInfo.baseField" class="structure_field"><div class="structure_field_info">baseField : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The expression for the normed space's base field.</p></div></li></ul><details id="instances-for-list-Manifold.Elab.NormedSpaceInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.instInhabitedNormedSpaceInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L240-L240">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.instInhabitedNormedSpaceInfo.default" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.instInhabitedNormedSpaceInfo.default"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedNormedSpaceInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.NormedSpaceInfo">NormedSpaceInfo</a></div></div><details id="instances-for-list-Manifold.Elab.instInhabitedNormedSpaceInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.instInhabitedNormedSpaceInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L240-L240">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.instInhabitedNormedSpaceInfo" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.instInhabitedNormedSpaceInfo"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedNormedSpaceInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.NormedSpaceInfo">NormedSpaceInfo</a></span></div></div></div></div><div class="decl" id="Manifold.Elab.FindModelResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L242-L257">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.FindModelResult" class="verification-badge comp-datatype" title="Computational datatype">ğŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.FindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">FindModelResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Information about a model with corners found through <code><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModelInner">findModelInner</a></code>.
It includes the model with corners found, and, if this model is the trivial model with corners on a
normed space, information about that normed space. (Knowing this is important for forming products
of models.)</p><p>Most search results are not a model with corners for a normed space, so an <code>Expr</code> representing the
model with corners may be coerced directly to this type.</p><ul class="structure_fields" id="Manifold.Elab.FindModelResult.mk"><li id="Manifold.Elab.FindModelResult.model" class="structure_field"><div class="structure_field_info">model : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>Expression describing the model with corners found.</p></div></li><li id="Manifold.Elab.FindModelResult.normedSpaceInfo?" class="structure_field"><div class="structure_field_info">normedSpaceInfo? : <span class="fn"><span class="fn">Option</span> <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.NormedSpaceInfo">NormedSpaceInfo</a></span></div><div class="structure_field_doc"><p>Information on the underlying normed space,
if this model is the trivial model with corners on a normed space.</p></div></li></ul><details id="instances-for-list-Manifold.Elab.FindModelResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.instInhabitedFindModelResult.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L257-L257">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.instInhabitedFindModelResult.default" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.instInhabitedFindModelResult.default"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedFindModelResult</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.FindModelResult">FindModelResult</a></div></div><details id="instances-for-list-Manifold.Elab.instInhabitedFindModelResult.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.instInhabitedFindModelResult"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L257-L257">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.instInhabitedFindModelResult" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.instInhabitedFindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instInhabitedFindModelResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.FindModelResult">FindModelResult</a></span></div></div></div></div><div class="decl" id="Manifold.Elab.instCoeExprFindModelResult"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L259-L260">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.instCoeExprFindModelResult" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.instCoeExprFindModelResult"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">instCoeExprFindModelResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Coe</span> <span class="fn">Lean.Expr</span> <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.FindModelResult">FindModelResult</a></span></div></div></div></div><div class="decl" id="Manifold.Elab.findModelInner"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L297-L657">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.findModelInner" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModelInner"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModelInner</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">baseInfo</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span> := <span class="fn">none</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">(<span class="fn">Option</span> <a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.FindModelResult">FindModelResult</a>)</span></span></div></div><p>Try to find a <code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#ModelWithCorners">ModelWithCorners</a></code> instance on a type (represented by an expression <code>e</code>),
using the local context to infer the appropriate instance. This supports the following cases:</p><ul><li>the model with corners on the total space of a vector bundle</li><li>the model with corners on the tangent space of a manifold</li><li>a model with corners on a manifold, or on its underlying model space</li><li>a closed interval of real numbers (including the unit interval)</li><li>Euclidean space, Euclidean half-space and Euclidean quadrants</li><li>a metric sphere in a real or complex inner product space</li><li>the units of a normed algebra</li><li>the complex upper half plane</li><li>a space of continuous k-linear maps</li><li>the trivial model <code>ğ“˜(ğ•œ, E)</code> on a normed space</li><li>if the above are not found, try to find a <code><a href="../../.././Mathlib/Analysis/Normed/Field/Basic.html#NontriviallyNormedField">NontriviallyNormedField</a></code> instance on the type of <code>e</code>,
and if successful, return <code>ğ“˜(ğ•œ)</code>.</li></ul><p>Further cases can be added as necessary.
This method intentionally handles <strong>neither</strong> sums (disjoint unions) nor products of spaces,
nor an open subset of an existing manifold. These are handled in <code><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel">findModel</a></code>.</p><p>Return an expression describing the found model with corners, together with information about
whether the model is the trivial model with corners on a normed space. (This is important for
forming products of models.)</p><p><code>baseInfo</code> is only used for the first case, a model with corners on the total space of the vector
bundle. In this case, it contains a pair of expressions <code>(e, i)</code> describing the type of the base
and the model with corners on the base: these are required to construct the right model with
corners.</p><p>Note that the matching on <code>e</code> does not see through reducibility (e.g. we distinguish the <code>abbrev</code>
<code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#TangentBundle">TangentBundle</a></code> from its definition), so <code>whnfR</code> should not be run on <code>e</code> prior to calling
<code><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel">findModel</a></code> on it.</p><p>This implementation is not maximally robust yet.</p><details id="instances-for-list-Manifold.Elab.findModelInner" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.findModel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L660-L746">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.findModel" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModel</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">baseInfo</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span> := <span class="fn">none</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Try to find a <code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#ModelWithCorners">ModelWithCorners</a></code> instance on a type (represented by an expression <code>e</code>),
using the local context to infer the appropriate instance.
TODO not yet: This supports all <code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#ModelWithCorners">ModelWithCorners</a></code>
instances that are currently defined in mathlib. Further cases can be added as necessary.</p><p>Return an expression describing the found model with corners.</p><p><code>baseInfo</code> is only used for the first case, a model with corners on the total space of the vector
bundle. In this case, it contains a pair of expressions <code>(e, i)</code> describing the type of the base
and the model with corners on the base: these are required to construct the right model with
corners.</p><p>Note that the matching on <code>e</code> does not see through reducibility (e.g. we distinguish the <code>abbrev</code>
<code><a href="../../.././Mathlib/Geometry/Manifold/IsManifold/Basic.html#TangentBundle">TangentBundle</a></code> from its definition), so <code>whnfR</code> should not be run on <code>e</code> prior to calling
<code><a href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel">findModel</a></code> on it.</p><p>This implementation is not maximally robust yet.</p><details id="instances-for-list-Manifold.Elab.findModel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Elab.findModels"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L748-L773">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Elab.findModels" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModels"><span class="name">Manifold</span>.<span class="name">Elab</span>.<span class="name">findModels</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">es</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">(<span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span>)</span></span></div></div><p>If the type of <code>e</code> is a non-dependent function between spaces <code>src</code> and <code>tgt</code>, try to find a
model with corners on both <code>src</code> and <code>tgt</code>. If successful, return both models.</p><p>We pass <code>e</code> instead of just its type for better diagnostics.</p><p>If <code>es</code> is <code>some</code>, we verify that <code>src</code> and the type of <code>es</code> are definitionally equal.</p><details id="instances-for-list-Manifold.Elab.findModels" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termMDiffAt[_]__Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L779-L786">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termMDiffAt[_]__Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiffAt[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMDiffAt[_]__Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>MDiffAt[s] f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableWithinAt">MDifferentiableWithinAt</a> I J f s x</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.
The argument <code>x</code> can be omitted.</p><details id="instances-for-list-Manifold.Â«termMDiffAt[_]__Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.termMDiffAt__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L788-L794">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.termMDiffAt__" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiffAt__"><span class="name">Manifold</span>.<span class="name">termMDiffAt__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>MDiffAt f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableAt">MDifferentiableAt</a> I J f x</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.
The argument <code>x</code> can be omitted.</p><details id="instances-for-list-Manifold.termMDiffAt__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termMDiff[_]__Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L815-L821">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termMDiff[_]__Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiff[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMDiff[_]__Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>MDiff[s] f</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiableOn">MDifferentiableOn</a> I J f s</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.Â«termMDiff[_]__Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.termMDiff__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L823-L828">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.termMDiff__" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiff__"><span class="name">Manifold</span>.<span class="name">termMDiff__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>MDiff f</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#MDifferentiable">MDifferentiable</a> I J f</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.termMDiff__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termCMDiffAt[_]____Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L835-L844">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termCMDiffAt[_]____Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiffAt[_]____Â»"><span class="name">Manifold</span>.<span class="name">Â«termCMDiffAt[_]____Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>CMDiffAt[s] n f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffWithinAt">ContMDiffWithinAt</a> I J n f s x</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.
<code>n</code> is coerced to <code><a href="../../.././Mathlib/Order/TypeTags.html#WithTop">WithTop</a> â„•âˆ</code> if necessary (so passing a <code>â„•</code>, <code>âˆ</code> or <code>Ï‰</code> are all supported).
The argument <code>x</code> can be omitted.</p><details id="instances-for-list-Manifold.Â«termCMDiffAt[_]____Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.termCMDiffAt____"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L846-L854">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.termCMDiffAt____" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiffAt____"><span class="name">Manifold</span>.<span class="name">termCMDiffAt____</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>CMDiffAt n f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffAt">ContMDiffAt</a> I J n f x</code>
trying to determine <code>I</code> and <code>J</code> from the local context.
<code>n</code> is coerced to <code><a href="../../.././Mathlib/Order/TypeTags.html#WithTop">WithTop</a> â„•âˆ</code> if necessary (so passing a <code>â„•</code>, <code>âˆ</code> or <code>Ï‰</code> are all supported).
The argument <code>x</code> can be omitted.</p><details id="instances-for-list-Manifold.termCMDiffAt____" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termCMDiff[_]____Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L856-L864">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termCMDiff[_]____Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiff[_]____Â»"><span class="name">Manifold</span>.<span class="name">Â«termCMDiff[_]____Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>CMDiff[s] n f</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiffOn">ContMDiffOn</a> I J n f s</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.
<code>n</code> is coerced to <code><a href="../../.././Mathlib/Order/TypeTags.html#WithTop">WithTop</a> â„•âˆ</code> if necessary (so passing a <code>â„•</code>, <code>âˆ</code> or <code>Ï‰</code> are all supported).</p><details id="instances-for-list-Manifold.Â«termCMDiff[_]____Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.termCMDiff____"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L866-L873">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.termCMDiff____" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiff____"><span class="name">Manifold</span>.<span class="name">termCMDiff____</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>CMDiff n f</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/ContMDiff/Defs.html#ContMDiff">ContMDiff</a> I J n f</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.
<code>n</code> is coerced to <code><a href="../../.././Mathlib/Order/TypeTags.html#WithTop">WithTop</a> â„•âˆ</code> if necessary (so passing a <code>â„•</code>, <code>âˆ</code> or <code>Ï‰</code> are all supported).</p><details id="instances-for-list-Manifold.termCMDiff____" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termMfderiv[_]__Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L875-L881">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termMfderiv[_]__Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv[_]__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMfderiv[_]__Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>mfderiv[u] f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#mfderivWithin">mfderivWithin</a> I J f u x</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.Â«termMfderiv[_]__Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termMfderiv%__Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L883-L888">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termMfderiv%__Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv%__Â»"><span class="name">Manifold</span>.<span class="name">Â«termMfderiv%__Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>mfderiv% f x</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#mfderiv">mfderiv</a> I J f x</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.Â«termMfderiv%__Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termHasMFDerivAt[_]______Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L890-L899">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termHasMFDerivAt[_]______Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt[_]______Â»"><span class="name">Manifold</span>.<span class="name">Â«termHasMFDerivAt[_]______Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>HasMFDerivAt[s] f x f'</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#HasMFDerivWithinAt">HasMFDerivWithinAt</a> I J f s x f'</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.Â«termHasMFDerivAt[_]______Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Manifold.Â«termHasMFDerivAt%______Â»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Geometry/Manifold/Notation.lean#L901-L909">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Geometry_Manifold_Notation.html#Manifold.Â«termHasMFDerivAt%______Â»" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt%______Â»"><span class="name">Manifold</span>.<span class="name">Â«termHasMFDerivAt%______Â»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>HasMFDerivAt% f x f'</code> elaborates to <code><a href="../../.././Mathlib/Geometry/Manifold/MFDeriv/Defs.html#HasMFDerivAt">HasMFDerivAt</a> I J f x f'</code>,
trying to determine <code>I</code> and <code>J</code> from the local context.</p><details id="instances-for-list-Manifold.Â«termHasMFDerivAt%______Â»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Trace-classes" class="markdown-heading">Trace classes <a class="hover-link" href="#Trace-classes">#</a></h3><p>Note that the overall <code>Elab</code> trace class does not inherit the trace classes defined in this
section, since they provide verbose information.</p></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>