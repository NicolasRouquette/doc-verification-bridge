<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="./style.css"></link><link rel="icon" href="./favicon.svg"></link><link rel="mask-icon" href="./favicon.svg" color="#000000"></link><link rel="prefetch" href=".//declarations/declaration-data.bmp" as="image"></link><title>Tactics</title><script defer="true" src="./mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="./";</script><script type="module" src="./jump-src.js"></script><script type="module" src="./search.js"></script><script type="module" src="./expand-nav.js"></script><script type="module" src="./how-about.js"></script><script type="module" src="./instances.js"></script><script type="module" src="./importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Tactics</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='./search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p><a href="#Batteries.Tactic.seq_focus">&lt;;&gt;</a></p><p><a href="#Batteries.Tactic.tactic_">_</a></p><p><a href="#Batteries.Tactic.tacticAbsurd_">absurd</a></p><p><a href="#Batteries.Tactic.byContra">by_contra</a></p><p><a href="#Batteries.Tactic.casePatt">case</a></p><p><a href="#Batteries.Tactic.casePatt'">case'</a></p><p><a href="#Batteries.Tactic.congrConfig">congr</a></p><p><a href="#Batteries.Tactic.congrConfigWith">congr</a></p><p><a href="#Batteries.Tactic.tacticEapply_">eapply</a></p><p><a href="#Batteries.Tactic.exacts">exacts</a></p><p><a href="#Batteries.Tactic.tacticFapply_">fapply</a></p><p><a href="#Batteries.Tactic.generalizeProofsElab">generalize_proofs</a></p><p><a href="#Batteries.Tactic.introDot">intro</a></p><p><a href="#Batteries.Tactic.«tacticMap_tacs[_;]»">map_tacs</a></p><p><a href="#Batteries.Tactic.«tacticMatch_,,With.»">match</a></p><p><a href="#Batteries.Tactic.«tacticOn_goal-_=&gt;_»">on_goal</a></p><p><a href="#Batteries.Tactic.«tacticPick_goal-_»">pick_goal</a></p><p><a href="#Batteries.Tactic.rcongr">rcongr</a></p><p><a href="#Batteries.Tactic.tacticSplit_ands">split_ands</a></p><p><a href="#Batteries.Tactic.squeezeScope">squeeze_scope</a></p><p><a href="#Batteries.Tactic.tacticSwap">swap</a></p><p><a href="#Batteries.Tactic.tacticTrans___">trans</a></p><p><a href="#Batteries.Tactic.tacticTransitivity___">transitivity</a></p><p><a href="#Batteries.Tactic.triv">triv</a></p><p><a href="#Batteries.Tactic.unreachable">unreachable!</a></p></nav><main>
<p>The tactic language is a special-purpose programming language for constructing proofs, indicated using the keyword <code>by</code>.</p><div id="Batteries.Tactic.seq_focus"><h2>&lt;;&gt;</h2><p><p><code>t &lt;;&gt; [t1; t2; ...; tn]</code> focuses on the first goal and applies <code>t</code>, which should result in <code>n</code>
subgoals. It then applies each <code>ti</code> to the corresponding goal and collects the resulting
subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.seq_focus">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Batteries.Tactic.tactic_"><h2>_</h2><p><p><code>_</code> in tactic position acts like the <code>done</code> tactic: it fails and gives the list
of goals if there are any. It is useful as a placeholder after starting a tactic block
such as <code>by _</code> to make it syntactically correct and show the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tactic_">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.tacticAbsurd_"><h2>absurd</h2><p><p>Given a proof <code>h</code> of <code>p</code>, <code>absurd h</code> changes the goal to <code>⊢ ¬ p</code>.
If <code>p</code> is a negation <code>¬q</code> then the goal is changed to <code>⊢ q</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticAbsurd_">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.byContra"><h2>by_contra</h2><p><p><code>by_contra h</code> proves <code>⊢ p</code> by contradiction,
introducing a hypothesis <code>h : ¬p</code> and proving <code>False</code>.</p><ul><li>If <code>p</code> is a negation <code>¬q</code>, <code>h : q</code> will be introduced instead of <code>¬¬q</code>.</li><li>If <code>p</code> is decidable, it uses <code>Decidable.byContradiction</code> instead of <code>Classical.byContradiction</code>.</li><li>If <code>h</code> is omitted, the introduced variable will be called <code>this</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.byContra">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.casePatt"><h2>case</h2><p><ul><li><p><code>case _ : t =&gt; tac</code> finds the first goal that unifies with <code>t</code> and then solves it
using <code>tac</code> or else fails. Like <code>show</code>, it changes the type of the goal to <code>t</code>.
The <code>_</code> can optionally be a case tag, in which case it only looks at goals
whose tag would be considered by <code>case</code> (goals with an exact tag match,
followed by goals with the tag as a suffix, followed by goals with the tag as a prefix).</p></li><li><p><code>case _ n₁ ... nₘ : t =&gt; tac</code> additionally names the <code>m</code> most recent hypotheses with
inaccessible names to the given names. The names are renamed before matching against <code>t</code>.
The <code>_</code> can optionally be a case tag.</p></li><li><p><code>case _ : t := e</code> is short for <code>case _ : t =&gt; exact e</code>.</p></li><li><p><code>case _ : t₁ | _ : t₂ | ... =&gt; tac</code>
is equivalent to <code>(case _ : t₁ =&gt; tac); (case _ : t₂ =&gt; tac); ...</code>
but with all matching done on the original list of goals --
each goal is consumed as they are matched, so patterns may repeat or overlap.</p></li><li><p><code>case _ : t</code> will make the matched goal be the first goal.
<code>case _ : t₁ | _ : t₂ | ...</code> makes the matched goals be the first goals in the given order.</p></li><li><p><code>case _ : t := _</code> and <code>case _ : t := ?m</code> are the same as <code>case _ : t</code> but in the <code>?m</code> case the
goal tag is changed to <code>m</code>.
In particular, the goal becomes metavariable <code>?m</code>.</p></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt">Batteries.Tactic.Case</a></dd></dl></div><div id="Batteries.Tactic.casePatt'"><h2>case'</h2><p><p><code>case' _ : t =&gt; tac</code> is similar to the <code>case _ : t =&gt; tac</code> tactic,
but it does not ensure the goal has been solved after applying <code>tac</code>,
nor does it admit the goal if <code>tac</code> failed.
Recall that <code>case</code> closes the goal using <code>sorry</code> when <code>tac</code> fails,
and the tactic execution is not interrupted.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt'">Batteries.Tactic.Case</a></dd></dl></div><div id="Batteries.Tactic.congrConfig"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ f as ≍ f bs</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code>congr</code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code>congr</code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code>congr 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfig">Batteries.Tactic.Congr</a></dd></dl></div><div id="Batteries.Tactic.congrConfigWith"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ f as ≍ f bs</code>.</p><ul><li><code>congr n</code> controls the depth of the recursive applications.
This is useful when <code>congr</code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code>congr</code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code>congr 2</code> produces the intended <code>⊢ x + y = y + x</code>.</li><li>If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.</li><li>You can use <code>congr with p (: n)?</code> to call <code>ext p (: n)?</code> to all subgoals generated by <code>congr</code>.
For example, if the goal is <code>⊢ f '' s = g '' s</code> then <code>congr with x</code> generates the goal
<code>x : α ⊢ f x = g x</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfigWith">Batteries.Tactic.Congr</a></dd></dl></div><div id="Batteries.Tactic.tacticEapply_"><h2>eapply</h2><p><p><code>eapply e</code> is like <code>apply e</code> but it does not add subgoals for variables that appear
in the types of other goals. Note that this can lead to a failure where there are
no goals remaining but there are still metavariables in the term:</p><pre><code>example (h : ∀ x : Nat, x = x → True) : True := by
  eapply h
  rfl
  -- no goals
-- (kernel) declaration has metavariables '_example'
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticEapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.exacts"><h2>exacts</h2><p><p>Like <code>exact</code>, but takes a list of terms and checks that all goals are discharged after the tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.exacts">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.tacticFapply_"><h2>fapply</h2><p><p><code>fapply e</code> is like <code>apply e</code> but it adds goals in the order they appear,
rather than putting the dependent goals first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticFapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.generalizeProofsElab"><h2>generalize_proofs</h2><p><p><code>generalize_proofs ids* [at locs]?</code> generalizes proofs in the current goal,
turning them into new local hypotheses.</p><ul><li><code>generalize_proofs</code> generalizes proofs in the target.</li><li><code>generalize_proofs at h₁ h₂</code> generalized proofs in hypotheses <code>h₁</code> and <code>h₂</code>.</li><li><code>generalize_proofs at *</code> generalizes proofs in the entire local context.</li><li><code>generalize_proofs pf₁ pf₂ pf₃</code> uses names <code>pf₁</code>, <code>pf₂</code>, and <code>pf₃</code> for the generalized proofs.
These can be <code>_</code> to not name proofs.</li></ul><p>If a proof is already present in the local context, it will use that rather than create a new
local hypothesis.</p><p>When doing <code>generalize_proofs at h</code>, if <code>h</code> is a let binding, its value is cleared,
and furthermore if <code>h</code> duplicates a preceding local hypothesis then it is eliminated.</p><p>The tactic is able to abstract proofs from under binders, creating universally quantified
proofs in the local context.
To disable this, use <code>generalize_proofs -abstract</code>.
The tactic is also set to recursively abstract proofs from the types of the generalized proofs.
This can be controlled with the <code>maxDepth</code> configuration option,
with <code>generalize_proofs (config := { maxDepth := 0 })</code> turning this feature off.</p><p>For example:</p><pre><code class="language-lean">def List.nthLe {α} (l : List α) (n : ℕ) (_h : n &lt; l.length) : α := sorry
example : List.nthLe [1, 2] 1 (by simp) = 2 := by
  -- ⊢ [1, 2].nthLe 1 ⋯ = 2
  generalize_proofs h
  -- h : 1 &lt; [1, 2].length
  -- ⊢ [1, 2].nthLe 1 h = 2
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/GeneralizeProofs.html#Batteries.Tactic.generalizeProofsElab">Batteries.Tactic.GeneralizeProofs</a></dd></dl></div><div id="Batteries.Tactic.introDot"><h2>intro</h2><p><p>The syntax <code>intro.</code> is deprecated in favor of <code>nofun</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/NoMatch.html#Batteries.Tactic.introDot">Batteries.Tactic.NoMatch</a></dd></dl></div><div id="Batteries.Tactic.«tacticMap_tacs[_;]»"><h2>map_tacs</h2><p><p>Assuming there are <code>n</code> goals, <code>map_tacs [t1; t2; ...; tn]</code> applies each <code>ti</code> to the respective
goal and leaves the resulting subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.«tacticMap_tacs[_;]»">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Batteries.Tactic.«tacticMatch_,,With.»"><h2>match</h2><p><p>The syntax <code>match ⋯ with.</code> has been deprecated in favor of <code>nomatch ⋯</code>.</p><p>Both now support multiple discriminants.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/NoMatch.html#Batteries.Tactic.«tacticMatch_,,With.»">Batteries.Tactic.NoMatch</a></dd></dl></div><div id="Batteries.Tactic.«tacticOn_goal-_=&gt;_»"><h2>on_goal</h2><p><p><code>on_goal n =&gt; tacSeq</code> creates a block scope for the <code>n</code>-th goal and tries the sequence
of tactics <code>tacSeq</code> on it.</p><p><code>on_goal -n =&gt; tacSeq</code> does the same, but the <code>n</code>-th goal is chosen by counting from the
bottom.</p><p>The goal is not required to be solved and any resulting subgoals are inserted back into the
list of goals, replacing the chosen goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.«tacticOn_goal-_=&gt;_»">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Batteries.Tactic.«tacticPick_goal-_»"><h2>pick_goal</h2><p><p><code>pick_goal n</code> will move the <code>n</code>-th goal to the front.</p><p><code>pick_goal -n</code> will move the <code>n</code>-th goal (counting from the bottom) to the front.</p><p>See also <code>Tactic.rotate_goals</code>, which moves goals from the front to the back and vice-versa.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.«tacticPick_goal-_»">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Batteries.Tactic.rcongr"><h2>rcongr</h2><p><p>Repeatedly apply <code>congr</code> and <code>ext</code>, using the given patterns as arguments for <code>ext</code>.</p><p>There are two ways this tactic stops:</p><ul><li><code>congr</code> fails (makes no progress), after having already applied <code>ext</code>.</li><li><code>congr</code> canceled out the last usage of <code>ext</code>. In this case, the state is reverted to before
the <code>congr</code> was applied.</li></ul><p>For example, when the goal is</p><pre><code>⊢ (fun x =&gt; f x + 3) '' s = (fun x =&gt; g x + 3) '' s
</code></pre><p>then <code>rcongr x</code> produces the goal</p><pre><code>x : α ⊢ f x = g x
</code></pre><p>This gives the same result as <code>congr; ext x; congr</code>.</p><p>In contrast, <code>congr</code> would produce</p><pre><code>⊢ (fun x =&gt; f x + 3) = (fun x =&gt; g x + 3)
</code></pre><p>and <code>congr with x</code> (or <code>congr; ext x</code>) would produce</p><pre><code>x : α ⊢ f x + 3 = g x + 3
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.rcongr">Batteries.Tactic.Congr</a></dd></dl></div><div id="Batteries.Tactic.tacticSplit_ands"><h2>split_ands</h2><p><p><code>split_ands</code> applies <code>And.intro</code> until it does not make progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticSplit_ands">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.squeezeScope"><h2>squeeze_scope</h2><p><p>The <code>squeeze_scope</code> tactic allows aggregating multiple calls to <code>simp</code> coming from the same syntax
but in different branches of execution, such as in <code>cases x &lt;;&gt; simp</code>.
The reported <code>simp</code> call covers all simp lemmas used by this syntax.</p><pre><code>@[simp] def bar (z : Nat) := 1 + z
@[simp] def baz (z : Nat) := 1 + z

@[simp] def foo : Nat → Nat → Nat
  | 0, z =&gt; bar z
  | _+1, z =&gt; baz z

example : foo x y = 1 + y := by
  cases x &lt;;&gt; simp? -- two printouts:
  -- &quot;Try this: simp only [foo, bar]&quot;
  -- &quot;Try this: simp only [foo, baz]&quot;

example : foo x y = 1 + y := by
  squeeze_scope
    cases x &lt;;&gt; simp -- only one printout: &quot;Try this: simp only [foo, baz, bar]&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SqueezeScope.html#Batteries.Tactic.squeezeScope">Batteries.Tactic.SqueezeScope</a></dd></dl></div><div id="Batteries.Tactic.tacticSwap"><h2>swap</h2><p><p><code>swap</code> is a shortcut for <code>pick_goal 2</code>, which interchanges the 1st and 2nd goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.tacticSwap">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Batteries.Tactic.tacticTrans___"><h2>trans</h2><p><p><code>trans</code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a transitive relation,
that is, a relation which has a transitivity lemma tagged with the attribute [trans].</p><ul><li><code>trans s</code> replaces the goal with the two subgoals <code>t ~ s</code> and <code>s ~ u</code>.</li><li>If <code>s</code> is omitted, then a metavariable is used instead.</li></ul><p>Additionally, <code>trans</code> also applies to a goal whose target has the form <code>t → u</code>,
in which case it replaces the goal with <code>t → s</code> and <code>s → u</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTrans___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.tacticTransitivity___"><h2>transitivity</h2><p><p>Synonym for <code>trans</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTransitivity___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.triv"><h2>triv</h2><p><p>Deprecated variant of <code>trivial</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.triv">Batteries.Tactic.Init</a></dd></dl></div><div id="Batteries.Tactic.unreachable"><h2>unreachable!</h2><p><p>This tactic causes a panic when run (at compile time).
(This is distinct from <code>exact unreachable!</code>, which inserts code which will panic at run time.)</p><p>It is intended for tests to assert that a tactic will never be executed, which is otherwise an
unusual thing to do (and the <code>unreachableTactic</code> linter will give a warning if you do).</p><p>The <code>unreachableTactic</code> linter has a special exception for uses of <code>unreachable!</code>.</p><pre><code>example : True := by trivial &lt;;&gt; unreachable!
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Unreachable.html#Batteries.Tactic.unreachable">Batteries.Tactic.Unreachable</a></dd></dl></div></main>
<nav class="nav"><iframe src="./navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>