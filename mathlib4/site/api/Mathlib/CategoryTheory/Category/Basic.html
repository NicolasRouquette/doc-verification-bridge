<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Category.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Category.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Category</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Tactic/Common.html">Mathlib.Tactic.Common</a></li><li><a href="../../.././Mathlib/Tactic/PPWithUniv.html">Mathlib.Tactic.PPWithUniv</a></li><li><a href="../../.././Mathlib/Tactic/StacksAttribute.html">Mathlib.Tactic.StacksAttribute</a></li><li><a href="../../.././Mathlib/Tactic/TryThis.html">Mathlib.Tactic.TryThis</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/Init.html">Mathlib.CategoryTheory.Category.Init</a></li><li><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html">Mathlib.Combinatorics.Quiver.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Category.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#LibraryNote.category_theory_universes"><span class="name">LibraryNote</span>.<span class="name">category_theory_universes</span></a></div><div class="nav_link"><a class="break_within" href="#LibraryNote.universe_output_parameters_and_typeclass_caching"><span class="name">LibraryNote</span>.<span class="name">universe_output_parameters_and_typeclass_caching</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CategoryStruct"><span class="name">CategoryTheory</span>.<span class="name">CategoryStruct</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.¬´termùüô¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´termùüô¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.¬´term_‚â´_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_‚â´_¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.sorryIfSorry"><span class="name">CategoryTheory</span>.<span class="name">sorryIfSorry</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.evalSorryIfSorry"><span class="name">CategoryTheory</span>.<span class="name">evalSorryIfSorry</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.rfl_cat"><span class="name">CategoryTheory</span>.<span class="name">rfl_cat</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.aesop_cat"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.aesop_cat?"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat?</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.aesop_cat_nonterminal"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat_nonterminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.categoryTheoryDischarger"><span class="name">CategoryTheory</span>.<span class="name">categoryTheoryDischarger</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cat_disch"><span class="name">CategoryTheory</span>.<span class="name">cat_disch</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Category"><span class="name">CategoryTheory</span>.<span class="name">Category</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.LargeCategory"><span class="name">CategoryTheory</span>.<span class="name">LargeCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.SmallCategory"><span class="name">CategoryTheory</span>.<span class="name">SmallCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Category.assoc'"><span class="name">CategoryTheory</span>.<span class="name">Category</span>.<span class="name">assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.eq_whisker"><span class="name">CategoryTheory</span>.<span class="name">eq_whisker</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.whisker_eq"><span class="name">CategoryTheory</span>.<span class="name">whisker_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.¬´term_=‚â´_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_=‚â´_¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.¬´term_‚â´=_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_‚â´=_¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.eq_of_comp_left_eq"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_left_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.eq_of_comp_right_eq"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_right_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.eq_of_comp_left_eq'"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_left_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.eq_of_comp_right_eq'"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_right_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.id_of_comp_left_id"><span class="name">CategoryTheory</span>.<span class="name">id_of_comp_left_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.id_of_comp_right_id"><span class="name">CategoryTheory</span>.<span class="name">id_of_comp_right_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.comp_ite"><span class="name">CategoryTheory</span>.<span class="name">comp_ite</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ite_comp"><span class="name">CategoryTheory</span>.<span class="name">ite_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.comp_dite"><span class="name">CategoryTheory</span>.<span class="name">comp_dite</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.dite_comp"><span class="name">CategoryTheory</span>.<span class="name">dite_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Epi"><span class="name">CategoryTheory</span>.<span class="name">Epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Mono"><span class="name">CategoryTheory</span>.<span class="name">Mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instEpiId"><span class="name">CategoryTheory</span>.<span class="name">instEpiId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instMonoId"><span class="name">CategoryTheory</span>.<span class="name">instMonoId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_epi"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_mono"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_epi_assoc_iff"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi_assoc_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_mono_assoc_iff"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono_assoc_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_epi_id"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.cancel_mono_id"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono_id</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.epi_comp"><span class="name">CategoryTheory</span>.<span class="name">epi_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.mono_comp"><span class="name">CategoryTheory</span>.<span class="name">mono_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.epi_comp'"><span class="name">CategoryTheory</span>.<span class="name">epi_comp'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.mono_comp'"><span class="name">CategoryTheory</span>.<span class="name">mono_comp'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.epi_of_epi"><span class="name">CategoryTheory</span>.<span class="name">epi_of_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.mono_of_mono"><span class="name">CategoryTheory</span>.<span class="name">mono_of_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.epi_of_epi_fac"><span class="name">CategoryTheory</span>.<span class="name">epi_of_epi_fac</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.mono_of_mono_fac"><span class="name">CategoryTheory</span>.<span class="name">mono_of_mono_fac</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.epi_iff_forall_injective"><span class="name">CategoryTheory</span>.<span class="name">epi_iff_forall_injective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.mono_iff_forall_injective"><span class="name">CategoryTheory</span>.<span class="name">mono_iff_forall_injective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instEpiOfIsThin"><span class="name">CategoryTheory</span>.<span class="name">instEpiOfIsThin</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instMonoOfIsThin"><span class="name">CategoryTheory</span>.<span class="name">instMonoOfIsThin</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.uliftCategory"><span class="name">CategoryTheory</span>.<span class="name">uliftCategory</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Categories" class="markdown-heading">Categories <a class="hover-link" href="#Categories">#</a></h1><p>Defines a category, as a type class parametrised by the type of objects.</p><h2 id="Notation" class="markdown-heading">Notation <a class="hover-link" href="#Notation">#</a></h2><p>Introduces notations in the <code>CategoryTheory</code> scope</p><ul><li><code>X ‚ü∂ Y</code> for the morphism spaces (type as <code>\hom</code>),</li><li><code>ùüô X</code> for the identity morphism on <code>X</code> (type as <code>\b1</code>),</li><li><code>f ‚â´ g</code> for composition in the 'arrows' convention (type as <code>\gg</code>).</li></ul><p>Users may like to add <code>g ‚äö f</code> for composition in the standard convention, using</p><pre><code class="language-lean">local notation:80 g &quot; ‚äö &quot; f:80 =&gt; <a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> f g    -- type as \oo
</code></pre></div><div class="decl" id="LibraryNote.category_theory_universes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L37-L80">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#LibraryNote.category_theory_universes" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#LibraryNote.category_theory_universes"><span class="name">LibraryNote</span>.<span class="name">category_theory_universes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Batteries.Util.LibraryNote</span></div></div><p>The typeclass <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category</a> C</code> describes morphisms associated to objects of type <code>C : Type u</code>.</p><p>The universe levels of the objects and morphisms are independent, and will often need to be
specified explicitly, as <code>Category.{v} C</code>.</p><p>Typically any concrete example will either be a <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a></code>, where <code>v = u</code>,
which can be introduced as</p><pre><code>universe u
variable {C : Type u} [SmallCategory C]
</code></pre><p>or a <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory">LargeCategory</a></code>, where <code>u = v+1</code>, which can be introduced as</p><pre><code>universe u
variable {C : Type (u+1)} [LargeCategory C]
</code></pre><p>In order for the library to handle these cases uniformly,
we generally work with the unconstrained <code>Category.{v u}</code>,
for which objects live in <code>Type u</code> and morphisms live in <code>Type v</code>.</p><p>Because the universe parameter <code>u</code> for the objects can be inferred from <code>C</code>
when we write <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category</a> C</code>, while the universe parameter <code>v</code> for the morphisms
cannot be automatically inferred, through the category theory library
we introduce universe parameters with morphism levels listed first,
as in</p><pre><code>universe v u
</code></pre><p>or</p><pre><code>universe v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ
</code></pre><p>when multiple independent universes are needed.</p><p>This has the effect that we can simply write <code>Category.{v} C</code>
(that is, only specifying a single parameter) while <code>u</code> will be inferred.</p><p>Often, however, it's not even necessary to include the <code>.{v}</code>.
(Although it was in earlier versions of Lean.)
If it is omitted a &quot;free&quot; universe will be used.</p><details id="instances-for-list-LibraryNote.category_theory_universes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LibraryNote.universe_output_parameters_and_typeclass_caching"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L82-L114">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#LibraryNote.universe_output_parameters_and_typeclass_caching" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#LibraryNote.universe_output_parameters_and_typeclass_caching"><span class="name">LibraryNote</span>.<span class="name">universe_output_parameters_and_typeclass_caching</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Batteries.Util.LibraryNote</span></div></div><p>Many classes in Mathlib have universe parameters that do not appear in their
input parameter types. For example:</p><ul><li><code>Category.{v} (C : Type u)</code> ‚Äî the morphism universe <code>v</code> is not determined by <code>C</code></li><li><code>HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} (C : Type u) [Category.{v} C]</code> ‚Äî the shape universes <code>v‚ÇÅ, u‚ÇÅ</code>
are not determined by <code>C</code></li><li><code>Small.{w} (Œ± : Type v)</code> ‚Äî the target universe <code>w</code> is not determined by <code>Œ±</code>
(but <code>v</code> is determined by <code>Œ±</code>, so <code>v</code> <em>is</em> an output)</li><li><code>Functor.IsContinuous.{t} (F) (J) (K)</code> ‚Äî the sheaf type universe <code>t</code> is not determined
by <code>F</code>, <code>J</code>, <code>K</code></li><li><code>UnivLE.{u, v}</code> ‚Äî has no input parameters at all</li></ul><p>By default (since <a href="https://github.com/leanprover/lean4/pull/12286">https://github.com/leanprover/lean4/pull/12286</a>), Lean treats any universe
parameter not occurring in input types as an output parameter, and erases it from typeclass
resolution cache keys. This means that queries differing only in such a universe share a
cache entry ‚Äî the first result found is reused.</p><p>This is correct when the universe truly is determined by the inputs (e.g., <code>v</code> in
<code>Small.{w} (Œ± : Type v)</code>), but incorrect when the universe is part of the <em>question</em>
(e.g., <code>v</code> in <code>Category.{v} C</code>). Cache collisions cause &quot;stuck at solving universe constraint&quot;
errors or silent misresolution.</p><p>The <code>@[univ_out_params]</code> attribute
(from <a href="https://github.com/leanprover/lean4/pull/12423">https://github.com/leanprover/lean4/pull/12423</a>) overrides the default:</p><ul><li><code>@[univ_out_params]</code> ‚Äî no universe parameters are output (all kept in cache key)</li><li><code>@[univ_out_params v]</code> ‚Äî only <code>v</code> is output</li></ul><p><strong>Rule of thumb:</strong> if the class is typically used with explicit universe annotations
(e.g., <code>HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C</code>) or is marked <code>@[pp_with_univ]</code>, its &quot;extra&quot; universe
parameters are likely inputs, not outputs, and the class should be annotated with
<code>@[univ_out_params]</code>.</p><details id="instances-for-list-LibraryNote.universe_output_parameters_and_typeclass_caching" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CategoryStruct"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L120-L127">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.CategoryStruct" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct"><span class="name">CategoryTheory</span>.<span class="name">CategoryStruct</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">obj</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span id="CategoryTheory.CategoryStruct.toQuiver"><span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver">Quiver</a> <span class="fn">obj</span></span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u (v + 1))</div></div><p>A preliminary structure on the way to defining a category,
containing the data, but none of the axioms.</p><ul class="structure_fields" id="CategoryTheory.CategoryStruct.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">Hom</a> : <span class="fn"><span class="fn">obj</span> ‚Üí <span class="fn">obj</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> v</span></div></li><li id="CategoryTheory.CategoryStruct.id" class="structure_field"><div class="structure_field_info">id<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">obj</span>)</span></span>
 : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span></div><div class="structure_field_doc"><p>The identity morphism on an object.</p></div></li><li id="CategoryTheory.CategoryStruct.comp" class="structure_field"><div class="structure_field_info">comp<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">obj</span>}</span></span>
</span> : <span class="fn">(<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>) ‚Üí <span class="fn">(<span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) ‚Üí (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span></div><div class="structure_field_doc"><p>Composition of morphisms in a category, written <code>f ‚â´ g</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.CategoryStruct" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.¬´termùüô¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L133-L134">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.¬´termùüô¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.¬´termùüô¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´termùüô¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Notation for the identity morphism in a category.</p><details id="instances-for-list-CategoryTheory.¬´termùüô¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.¬´term_‚â´_¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L136-L137">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.¬´term_‚â´_¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.¬´term_‚â´_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_‚â´_¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.TrailingParserDescr</span></div></div><p>Notation for composition of morphisms in a category.</p><details id="instances-for-list-CategoryTheory.¬´term_‚â´_¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.sorryIfSorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L139-L140">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.sorryIfSorry" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.sorryIfSorry"><span class="name">CategoryTheory</span>.<span class="name">sorryIfSorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Close the main goal with <code>sorry</code> if its type contains <code>sorry</code>, and fail otherwise.</p><details id="instances-for-list-CategoryTheory.sorryIfSorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.evalSorryIfSorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L143-L148">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.evalSorryIfSorry" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.evalSorryIfSorry"><span class="name">CategoryTheory</span>.<span class="name">evalSorryIfSorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Tactic.Tactic</span></div></div><p>Close the main goal with <code>sorry</code> if its type contains <code>sorry</code>, and fail otherwise.</p><details id="instances-for-list-CategoryTheory.evalSorryIfSorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.rfl_cat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L169-L169">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.rfl_cat" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.rfl_cat"><span class="name">CategoryTheory</span>.<span class="name">rfl_cat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.rfl_cat">rfl_cat</a></code> is a macro for <code>intros; rfl</code> which is attempted in <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">aesop_cat</a></code> before
doing the more expensive <code>aesop</code> tactic.</p><p>This gives a speedup because <code>simp</code> (called by <code>aesop</code>) can be very slow.
<a href="https://github.com/leanprover-community/mathlib4/pull/25475">https://github.com/leanprover-community/mathlib4/pull/25475</a> contains measurements from June 2025.</p><p>Implementation notes:</p><ul><li><code>refine <a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">id</a> ?_</code>:
In some cases it is important that the type of the proof matches the expected type exactly.
e.g. if the goal is <code>2 = 1 + 1</code>, the <code>rfl</code> tactic will give a proof of type <code>2 = 2</code>.
Starting a proof with <code>refine <a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">id</a> ?_</code> is a trick to make sure that the proof has exactly
the expected type, in this case <code>2 = 1 + 1</code>. See also
https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/changing.20a.20proof.20can.20break.20a.20later.20proof</li><li><code>apply_rfl</code>:
<code>rfl</code> is a macro that attempts both <code>eq_refl</code> and <code>apply_rfl</code>. Since <code>apply_rfl</code>
subsumes <code>eq_refl</code>, we can use <code>apply_rfl</code> instead. This fails twice as fast as <code>rfl</code>.</li></ul><details id="instances-for-list-CategoryTheory.rfl_cat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.aesop_cat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L177-L181">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.aesop_cat" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>A thin wrapper for <code>aesop</code> which adds the <code>CategoryTheory</code> rule set and
allows <code>aesop</code> to look through semireducible definitions when calling <code>intros</code>.
This tactic fails when it is unable to solve the goal, making it suitable for
use in auto-params.</p><details id="instances-for-list-CategoryTheory.aesop_cat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.aesop_cat?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L186-L190">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.aesop_cat?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat?"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>We also use <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat?">aesop_cat?</a></code> to pass along a <code>Try this</code> suggestion when using <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">aesop_cat</a></code></p><details id="instances-for-list-CategoryTheory.aesop_cat?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.aesop_cat_nonterminal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L196-L199">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.aesop_cat_nonterminal" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat_nonterminal"><span class="name">CategoryTheory</span>.<span class="name">aesop_cat_nonterminal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>A variant of <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">aesop_cat</a></code> which does not fail when it is unable to solve the
goal. Use this only for exploration! Nonterminal <code>aesop</code> is even worse than
nonterminal <code>simp</code>.</p><details id="instances-for-list-CategoryTheory.aesop_cat_nonterminal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.categoryTheoryDischarger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L204-L217">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.categoryTheoryDischarger" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.categoryTheoryDischarger"><span class="name">CategoryTheory</span>.<span class="name">categoryTheoryDischarger</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <span class="fn">Unit</span></span></div></div><p>A tactic for discharging easy category theory goals, widely used as an autoparameter.
Currently this defaults to the <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">aesop_cat</a></code> wrapper around <code>aesop</code>, but by setting
the option <code><a href="../../.././Mathlib/CategoryTheory/Category/Init.html#mathlib.tactic.category.grind">mathlib.tactic.category.grind</a></code> to <code>true</code>, it will use the <code>grind</code> tactic instead.</p><details id="instances-for-list-CategoryTheory.categoryTheoryDischarger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.cat_disch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L219-L221">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cat_disch" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cat_disch"><span class="name">CategoryTheory</span>.<span class="name">cat_disch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>A tactic for discharging easy category theory goals, widely used as an autoparameter.
Currently this defaults to the <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.aesop_cat">aesop_cat</a></code> wrapper around <code>aesop</code>, but by setting
the option <code><a href="../../.././Mathlib/CategoryTheory/Category/Init.html#mathlib.tactic.category.grind">mathlib.tactic.category.grind</a></code> to <code>true</code>, it will use the <code>grind</code> tactic instead.</p><details id="instances-for-list-CategoryTheory.cat_disch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Category"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L225-L240">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.Category" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category"><span class="name">CategoryTheory</span>.<span class="name">Category</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">obj</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_extends">extends</span> <span id="CategoryTheory.Category.toCategoryStruct"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct">CategoryTheory.CategoryStruct.{v, u}</a> <span class="fn">obj</span></span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u (v + 1))</div></div><p>The typeclass <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category</a> C</code> describes morphisms associated to objects of type <code>C</code>.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as <code>Category.{v} C</code>. (See also <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory">LargeCategory</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a></code>.)</p><ul class="structure_fields" id="CategoryTheory.Category.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">Hom</a> : <span class="fn"><span class="fn">obj</span> ‚Üí <span class="fn">obj</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> v</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">id</a><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">obj</span>)</span></span>
 : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">comp</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">obj</span>}</span></span>
</span> : <span class="fn">(<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>) ‚Üí <span class="fn">(<span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) ‚Üí (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span></div></li><li id="CategoryTheory.Category.id_comp" class="structure_field"><div class="structure_field_info">id_comp<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">obj</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">f</span></span></div><div class="structure_field_doc"><p>Identity morphisms are left identities for composition.</p></div></li><li id="CategoryTheory.Category.comp_id" class="structure_field"><div class="structure_field_info">comp_id<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">obj</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">Y</span>)</span></span> <span class="fn">=</span> <span class="fn">f</span></span></div><div class="structure_field_doc"><p>Identity morphisms are right identities for composition.</p></div></li><li id="CategoryTheory.Category.assoc" class="structure_field"><div class="structure_field_info">assoc<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">obj</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span>)</span></span></span></div><div class="structure_field_doc"><p>Composition in a category is associative.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Category" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.LargeCategory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L250-L254">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.LargeCategory" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory"><span class="name">CategoryTheory</span>.<span class="name">LargeCategory</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> (u + 1))</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (u + 1)</div></div><p>A <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.LargeCategory">LargeCategory</a></code> has objects in one universe level higher than the universe level of
the morphisms. It is useful for examples such as the category of types, or the category
of groups, etc.</p><details id="instances-for-list-CategoryTheory.LargeCategory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.SmallCategory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L256-L258">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.SmallCategory" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory"><span class="name">CategoryTheory</span>.<span class="name">SmallCategory</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (u + 1)</div></div><p>A <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a></code> has objects and morphisms in the same universe level.</p><details id="instances-for-list-CategoryTheory.SmallCategory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Category.assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L264-L266">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.Category.assoc'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category.assoc'"><span class="name">CategoryTheory</span>.<span class="name">Category</span>.<span class="name">assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">W</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span>)</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.eq_whisker"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L268-L271">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.eq_whisker" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.eq_whisker"><span class="name">CategoryTheory</span>.<span class="name">eq_whisker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></div></div><p>Postcompose an equation between morphisms by another morphism</p></div></div><div class="decl" id="CategoryTheory.whisker_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L269-L270">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.whisker_eq" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.whisker_eq"><span class="name">CategoryTheory</span>.<span class="name">whisker_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></div></div><p>Precompose an equation between morphisms by another morphism</p></div></div><div class="decl" id="CategoryTheory.¬´term_=‚â´_¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L273-L277">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.¬´term_=‚â´_¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.¬´term_=‚â´_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_=‚â´_¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.TrailingParserDescr</span></div></div><p>Notation for whiskering an equation by a morphism (on the right).
If <code>f g : X ‚ü∂ Y</code> and <code>w : f = g</code> and <code>h : Y ‚ü∂ Z</code>, then <code>w =‚â´ h : f ‚â´ h = g ‚â´ h</code>.</p><details id="instances-for-list-CategoryTheory.¬´term_=‚â´_¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.¬´term_‚â´=_¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L279-L283">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.¬´term_‚â´=_¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.¬´term_‚â´=_¬ª"><span class="name">CategoryTheory</span>.<span class="name">¬´term_‚â´=_¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.TrailingParserDescr</span></div></div><p>Notation for whiskering an equation by a morphism (on the left).
If <code>g h : Y ‚ü∂ Z</code> and <code>w : g = h</code> and <code>f : X ‚ü∂ Y</code>, then <code>f ‚â´= w : f ‚â´ g = f ‚â´ h</code>.</p><details id="instances-for-list-CategoryTheory.¬´term_‚â´=_¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.eq_of_comp_left_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L285-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.eq_of_comp_left_eq"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_left_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn">‚àÄ {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.eq_of_comp_right_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L285-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.eq_of_comp_right_eq"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_right_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn">‚àÄ {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.eq_of_comp_left_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L290-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.eq_of_comp_left_eq'"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_left_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">(fun {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span>)</span> <span class="fn">=</span> <span class="fn">fun {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.eq_of_comp_right_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L290-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.eq_of_comp_right_eq'"><span class="name">CategoryTheory</span>.<span class="name">eq_of_comp_right_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn">(fun {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span>)</span> <span class="fn">=</span> <span class="fn">fun {<span class="fn">Z</span> : <span class="fn">C</span>} (<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.id_of_comp_left_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L295-L298">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.id_of_comp_left_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.id_of_comp_left_id"><span class="name">CategoryTheory</span>.<span class="name">id_of_comp_left_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn">‚àÄ {<span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn">g</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.id_of_comp_right_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L295-L295">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.id_of_comp_right_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.id_of_comp_right_id"><span class="name">CategoryTheory</span>.<span class="name">id_of_comp_right_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn">‚àÄ {<span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">g</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.comp_ite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L300-L302">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.comp_ite" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.comp_ite"><span class="name">CategoryTheory</span>.<span class="name">comp_ite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g </span><span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn">if</span> <span class="fn">P</span> <span class="fn">then</span> <span class="fn">g</span> <span class="fn">else</span> <span class="fn">g'</span>)</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">if</span> <span class="fn">P</span> <span class="fn">then</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">else</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ite_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L300-L300">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.ite_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.ite_comp"><span class="name">CategoryTheory</span>.<span class="name">ite_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g </span><span class="fn">g'</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">if</span> <span class="fn">P</span> <span class="fn">then</span> <span class="fn">g</span> <span class="fn">else</span> <span class="fn">g'</span>)</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">if</span> <span class="fn">P</span> <span class="fn">then</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">else</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.comp_dite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L304-L307">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.comp_dite" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.comp_dite"><span class="name">CategoryTheory</span>.<span class="name">comp_dite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">P</span> ‚Üí (<span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn"><span class="fn"><span class="fn">¬¨</span><span class="fn">P</span></span> ‚Üí (<span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(if h : <span class="fn">P</span> then <span class="fn"><span class="fn">g</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">g'</span> <span class="fn">h</span></span>)</span></span> <span class="fn">=</span>   <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">h</span>)</span></span> else <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn">g'</span> <span class="fn">h</span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.dite_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L304-L304">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.dite_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.dite_comp"><span class="name">CategoryTheory</span>.<span class="name">dite_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Decidable</span> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">P</span> ‚Üí (<span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn"><span class="fn"><span class="fn">¬¨</span><span class="fn">P</span></span> ‚Üí (<span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(if h : <span class="fn">P</span> then <span class="fn"><span class="fn">g</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">g'</span> <span class="fn">h</span></span>)</span> <span class="fn">f</span></span> <span class="fn">=</span>   <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">g</span> <span class="fn">h</span>)</span> <span class="fn">f</span></span> else <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">g'</span> <span class="fn">h</span>)</span> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Epi"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L309-L313">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.Epi" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi"><span class="name">CategoryTheory</span>.<span class="name">Epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A morphism <code>f</code> is an epimorphism if it can be cancelled when precomposed:
<code>f ‚â´ g = f ‚â´ h</code> implies <code>g = h</code>.</p><p><a href="https://stacks.math.columbia.edu/tag/003B">Stacks Tag 003B</a></p><ul class="structure_fields" id="CategoryTheory.Epi.mk"><li id="CategoryTheory.Epi.left_cancellation" class="structure_field"><div class="structure_field_info">left_cancellation<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
 : <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span></span> ‚Üí <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn">h</span></span></span></div><div class="structure_field_doc"><p>A morphism <code>f</code> is an epimorphism if it can be cancelled when precomposed.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Epi" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.Mono"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L315-L320">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.Mono" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono"><span class="name">CategoryTheory</span>.<span class="name">Mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A morphism <code>f</code> is a monomorphism if it can be cancelled when postcomposed:
<code>g ‚â´ f = h ‚â´ f</code> implies <code>g = h</code>.</p><p><a href="https://stacks.math.columbia.edu/tag/003B">Stacks Tag 003B</a></p><ul class="structure_fields" id="CategoryTheory.Mono.mk"><li id="CategoryTheory.Mono.right_cancellation" class="structure_field"><div class="structure_field_info">right_cancellation<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
 : <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span></span> ‚Üí <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn">h</span></span></span></div><div class="structure_field_doc"><p>A morphism <code>f</code> is a monomorphism if it can be cancelled when postcomposed.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Mono" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.instEpiId"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L322-L324">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.instEpiId" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.instEpiId"><span class="name">CategoryTheory</span>.<span class="name">instEpiId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instMonoId"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L322-L322">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.instMonoId" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.instMonoId"><span class="name">CategoryTheory</span>.<span class="name">instMonoId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_epi"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L326-L328">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_epi" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_epi"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L326-L326">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_mono" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_mono"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">g</span> <span class="fn">=</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_epi_assoc_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L330-L333">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_epi_assoc_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_epi_assoc_iff"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi_assoc_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">l</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">W</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span>)</span> <span class="fn">l</span></span></span> <span class="fn">‚Üî</span>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">l</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_mono_assoc_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L330-L330">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_mono_assoc_iff" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_mono_assoc_iff"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono_assoc_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g </span><span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">u</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">k</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">u</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span>)</span></span></span> <span class="fn">‚Üî</span>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">k</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">u</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_epi_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L335-L338">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_epi_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_epi_id"><span class="name">CategoryTheory</span>.<span class="name">cancel_epi_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <span class="fn">=</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">h</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">Y</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.cancel_mono_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L335-L335">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.cancel_mono_id" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.cancel_mono_id"><span class="name">CategoryTheory</span>.<span class="name">cancel_mono_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn"><span class="fn">h</span> <span class="fn">=</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">Y</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.epi_comp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L340-L347">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.epi_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_comp"><span class="name">CategoryTheory</span>.<span class="name">epi_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span></div></div><p>The composition of epimorphisms is again an epimorphism. This version takes <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> f</code> and <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> g</code>
as typeclass arguments. For a version taking them as explicit arguments, see <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_comp'">epi_comp'</a></code>.</p></div></div><div class="decl" id="CategoryTheory.mono_comp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L342-L345">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.mono_comp" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_comp"><span class="name">CategoryTheory</span>.<span class="name">mono_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">g</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span></div></div><p>The composition of monomorphisms is again a monomorphism. This version takes <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> f</code> and
<code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> g</code> as typeclass arguments. For a version taking them as explicit arguments, see <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_comp'">mono_comp'</a></code>.</p></div></div><div class="decl" id="CategoryTheory.epi_comp'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L349-L356">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.epi_comp'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_comp'"><span class="name">CategoryTheory</span>.<span class="name">epi_comp'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span></div></div><p>The composition of epimorphisms is again an epimorphism. This version takes <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> f</code> and <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> g</code>
as explicit arguments. For a version taking them as typeclass arguments, see <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_comp">epi_comp</a></code>.</p></div></div><div class="decl" id="CategoryTheory.mono_comp'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L351-L354">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.mono_comp'" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_comp'"><span class="name">CategoryTheory</span>.<span class="name">mono_comp'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span></div></div><p>The composition of monomorphisms is again a monomorphism. This version takes <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> f</code> and
<code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> g</code> as explicit arguments. For a version taking them as typeclass arguments, see <code><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_comp">mono_comp</a></code>.</p></div></div><div class="decl" id="CategoryTheory.epi_of_epi"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L358-L360">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.epi_of_epi" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_of_epi"><span class="name">CategoryTheory</span>.<span class="name">epi_of_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.mono_of_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L358-L358">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.mono_of_mono" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_of_mono"><span class="name">CategoryTheory</span>.<span class="name">mono_of_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.epi_of_epi_fac"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L362-L364">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.epi_of_epi_fac" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_of_epi_fac"><span class="name">CategoryTheory</span>.<span class="name">epi_of_epi_fac</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">h</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <span class="fn">=</span> <span class="fn">h</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.mono_of_mono_fac"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L362-L362">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.mono_of_mono_fac" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_of_mono_fac"><span class="name">CategoryTheory</span>.<span class="name">mono_of_mono_fac</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">h</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">w</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">h</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.epi_iff_forall_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L366-L372">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.epi_iff_forall_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.epi_iff_forall_injective"><span class="name">CategoryTheory</span>.<span class="name">epi_iff_forall_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Function.Injective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Z</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span></span></span></span></span></div></div><p><code>f : X ‚ü∂ Y</code> is an epimorphism iff for all <code>Z</code>, composition of morphisms <code>Y ‚ü∂ Z</code> with <code>f</code>
is injective.</p></div></div><div class="decl" id="CategoryTheory.mono_iff_forall_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L368-L370">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.mono_iff_forall_injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.mono_iff_forall_injective"><span class="name">CategoryTheory</span>.<span class="name">mono_iff_forall_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span> <span class="fn">‚Üî</span> <span class="fn">‚àÄ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><span class="fn">Function.Injective</span> <span class="fn">fun (<span class="fn">g</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span></span></span></span></span></div></div><p><code>f : X ‚ü∂ Y</code> is a monomorphism iff for all <code>Z</code>, composition of morphisms <code>Z ‚ü∂ X</code> with <code>f</code>
is injective.</p></div></div><div class="decl" id="CategoryTheory.instEpiOfIsThin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L374-L376">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.instEpiOfIsThin" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.instEpiOfIsThin"><span class="name">CategoryTheory</span>.<span class="name">instEpiOfIsThin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">Epi</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instMonoOfIsThin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L374-L374">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.instMonoOfIsThin" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.instMonoOfIsThin"><span class="name">CategoryTheory</span>.<span class="name">instMonoOfIsThin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">Mono</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.uliftCategory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/CategoryTheory/Category/Basic.lean#L387-L394">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_CategoryTheory_Category_Basic.html#CategoryTheory.uliftCategory" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.uliftCategory"><span class="name">CategoryTheory</span>.<span class="name">uliftCategory</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, max u' u}</a> <span class="fn">(<span class="fn">ULift.{u', u}</span> <span class="fn">C</span>)</span></span></div></div><p>The category structure on <code>ULift C</code> that is induced from the category
structure on <code>C</code>. This is not made a global instance because of a diamond
when <code>C</code> is a preordered type.</p><details id="instances-for-list-CategoryTheory.uliftCategory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>