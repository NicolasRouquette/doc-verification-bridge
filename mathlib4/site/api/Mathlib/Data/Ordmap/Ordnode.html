<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.Ordmap.Ordnode</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.Ordmap.Ordnode";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">Ordmap</span>.<span class="name">Ordnode</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Batteries/Data/List.html">Batteries.Data.List</a></li><li><a href="../../.././Mathlib/Order/Compare.html">Mathlib.Order.Compare</a></li><li><a href="../../.././Mathlib/Data/Nat/PSub.html">Mathlib.Data.Nat.PSub</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.Ordmap.Ordnode" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Ordnode"><span class="name">Ordnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instEmptyCollection"><span class="name">Ordnode</span>.<span class="name">instEmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInhabited"><span class="name">Ordnode</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instSingleton"><span class="name">Ordnode</span>.<span class="name">instSingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instRepr"><span class="name">Ordnode</span>.<span class="name">instRepr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToString"><span class="name">Ordnode</span>.<span class="name">instToString</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToFormat"><span class="name">Ordnode</span>.<span class="name">instToFormat</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instDecidableRelEquivOfDecidableEq"><span class="name">Ordnode</span>.<span class="name">instDecidableRelEquivOfDecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux‚ÇÅ"><span class="name">Ordnode</span>.<span class="name">ofAscListAux‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux‚ÇÇ"><span class="name">Ordnode</span>.<span class="name">ofAscListAux‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instMembership"><span class="name">Ordnode</span>.<span class="name">instMembership</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInsert"><span class="name">Ordnode</span>.<span class="name">instInsert</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Ordered-sets" class="markdown-heading">Ordered sets <a class="hover-link" href="#Ordered-sets">#</a></h1><p>This file defines a data structure for ordered sets, supporting a
variety of useful operations including insertion and deletion,
logarithmic time lookup, set operations, folds,
and conversion from lists.</p><p>The <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> Œ±</code> operations all assume that <code>Œ±</code> has the structure of
a total preorder, meaning a <code>‚â§</code> operation that is</p><ul><li>Transitive: <code>x ‚â§ y ‚Üí y ‚â§ z ‚Üí x ‚â§ z</code></li><li>Reflexive: <code>x ‚â§ x</code></li><li>Total: <code>x ‚â§ y ‚à® y ‚â§ x</code></li></ul><p>For example, in order to use this data structure as a map type, one
can store pairs <code>(k, v)</code> where <code>(k, v) ‚â§ (k', v')</code> is defined to mean
<code>k ‚â§ k'</code> (assuming that the key values are linearly ordered).</p><p>Two values <code>x,y</code> are equivalent if <code>x ‚â§ y</code> and <code>y ‚â§ x</code>. An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> Œ±</code>
maintains the invariant that it never stores two equivalent nodes;
the insertion operation comes with two variants depending on whether
you want to keep the old value or the new value in case you insert a value
that is equivalent to one in the set.</p><p>The operations in this file are not verified, in the sense that they provide
&quot;raw operations&quot; that work for programming purposes but the invariants
are not explicitly in the structure. See <code><a href="../../.././Mathlib/Data/Ordmap/Ordset.html#Ordset">Ordset</a></code> for a verified version
of this data structure.</p><h2 id="Main-definitions" class="markdown-heading">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul><li><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> Œ±</code>: A set of values of type <code>Œ±</code></li></ul><h2 id="Implementation-notes" class="markdown-heading">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Based on weight balanced trees:</p><ul><li>Stephen Adams, &quot;Efficient sets: a balancing act&quot;,
Journal of Functional Programming 3(4):553-562, October 1993,
<a href="http://www.swiss.ai.mit.edu/~adams/BB/">http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li><li>J. Nievergelt and E.M. Reingold,
&quot;Binary search trees of bounded balance&quot;,
SIAM journal of computing 2(1), March 1973.</li></ul><p>Ported from Haskell's <code>Data.<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a></code>.</p><h2 id="Tags" class="markdown-heading">Tags <a class="hover-link" href="#Tags">#</a></h2><p>ordered map, ordered set, data structure</p></div><div class="decl" id="Ordnode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L69-L74">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode"><span class="name">Ordnode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> Œ±</code> is a finite set of values, represented as a tree.
The operations on this type maintain that the tree is balanced
and correctly stores subtree sizes at each level.</p><ul class="constructors"><li class="constructor" id="Ordnode.nil">nil<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></li><li class="constructor" id="Ordnode.node">node<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">size</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
 : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></li></ul><details id="instances-for-list-Ordnode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instEmptyCollection"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L81-L82">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instEmptyCollection" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection"><span class="name">Ordnode</span>.<span class="name">instEmptyCollection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">EmptyCollection</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L84-L85">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instInhabited" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited"><span class="name">Ordnode</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Inhabited</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L87-L97">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.delta" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Ñï</span></div></div><p><strong>Internal use only</strong></p><p>The maximal relative difference between the sizes of
two trees, it corresponds with the <code>w</code> in Adams' paper.</p><p>According to the Haskell comment, only <code>(delta, ratio)</code> settings
of <code>(3, 2)</code> and <code>(4, 2)</code> will work, and the proofs in
<code>Ordset.lean</code> assume <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta">delta</a> := 3</code> and <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio">ratio</a> := 2</code>.</p><details id="instances-for-list-Ordnode.delta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ratio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L99-L108">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ratio" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Ñï</span></div></div><p><strong>Internal use only</strong></p><p>The ratio between an outer and inner sibling of the
heavier subtree in an unbalanced setting. It determines
whether a double or single rotation should be performed
to restore balance. It is corresponds with the inverse
of <code>Œ±</code> in Adam's article.</p><details id="instances-for-list-Ordnode.ratio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.singleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L110-L115">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.singleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p>O(1). Construct a singleton set containing value <code>a</code>.</p><p>singleton 3 = {3}</p><details id="instances-for-list-Ordnode.singleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instSingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L119-L120">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instSingleton" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton"><span class="name">Ordnode</span>.<span class="name">instSingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Singleton</span> <span class="fn">Œ±</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L122-L128">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.size" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">‚Ñï</span></span></div></div><p>O(1). Get the size of the set.</p><p><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a> {2, 1, 1, 4} = 3</code></p><details id="instances-for-list-Ordnode.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.size_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L130-L131">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.size_nil" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil">nil</a>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <span class="fn">=</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Ordnode.size_node"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L132-L134">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.size_node" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sz</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span>)</span>.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">size</a></span> <span class="fn">=</span> <span class="fn">sz</span></span></div></div></div></div><div class="decl" id="Ordnode.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L136-L143">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.empty" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Bool</span></span></div></div><p>O(1). Is the set empty?</p><p>empty ‚àÖ = tt
empty {1, 2, 3} = ff</p><details id="instances-for-list-Ordnode.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dual"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L145-L153">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.dual" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p><strong>Internal use only</strong>, because it violates the BST property on the original order.</p><p>O(n). The dual of a tree is a tree with its left and right sides reversed throughout.
The dual of a valid BST is valid under the dual order. This is convenient for exploiting
symmetries in the algorithms.</p><details id="instances-for-list-Ordnode.dual" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.node'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L155-L160">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.node'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Construct a node with the correct size information, without rebalancing.</p><details id="instances-for-list-Ordnode.node'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L162-L172">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.repr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Repr</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Std.Format</span></div></div><p>Basic pretty printing for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> Œ±</code> that shows the structure of the tree.</p><p>repr {3, 1, 2, 4} = ((‚àÖ 1 ‚àÖ) 2 ((‚àÖ 3 ‚àÖ) 4 ‚àÖ))</p><details id="instances-for-list-Ordnode.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instRepr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L174-L175">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instRepr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr"><span class="name">Ordnode</span>.<span class="name">instRepr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Repr</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Repr</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.balanceL"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L178-L210">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.balanceL" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its left
side grow by 1, or its right side shrink by 1.</p><details id="instances-for-list-Ordnode.balanceL" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balanceR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L212-L244">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.balanceR" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its right
side grow by 1, or its left side shrink by 1.</p><details id="instances-for-list-Ordnode.balanceR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L246-L300">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.balance" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had one side change
by at most 1.</p><details id="instances-for-list-Ordnode.balance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L302-L308">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.All" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does every element of the map satisfy property <code>P</code>?</p><p>All (fun x ‚Ü¶ x &lt; 5) {1, 2, 3} = True
All (fun x ‚Ü¶ x &lt; 5) {1, 2, 3, 5} = False</p><details id="instances-for-list-Ordnode.All" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L310-L315">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.All.decidable" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.Any"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L317-L323">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Any" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does any element of the map satisfy property <code>P</code>?</p><p>Any (fun x ‚Ü¶ x &lt; 2) {1, 2, 3} = True
Any (fun x ‚Ü¶ x &lt; 2) {2, 3, 5} = False</p><details id="instances-for-list-Ordnode.Any" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Any.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L325-L330">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Any.decidable" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Any</a> <span class="fn">P</span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.Emem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L332-L339">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Emem" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Exact membership in the set. This is useful primarily for stating
correctness properties; use <code>‚àà</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 4 {1, 2, 3} = false 
</code></pre><details id="instances-for-list-Ordnode.Emem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Emem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L341-L342">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Emem.decidable" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> <span class="fn">x</span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.Amem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L344-L362">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Amem" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Approximate membership in the set, that is, whether some element in the
set is equivalent to this one in the preorder. This is useful primarily for stating
correctness properties; use <code>‚àà</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 4 {1, 2, 3} = false
</code></pre><p>To see the difference with <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a></code>, we need a preorder that is not a partial order.
For example, suppose we compare pairs of numbers using only their first coordinate. Then:
-- TODO: Verify below example
Emem (0, 1) {(0, 0), (1, 2)} = false
Amem (0, 1) {(0, 0), (1, 2)} = true
(0, 1) ‚àà {(0, 0), (1, 2)} = true</p><p>The <code>‚àà</code> relation is equivalent to <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code> as long as the <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a></code> is well formed,
and should always be used instead of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code>.</p><details id="instances-for-list-Ordnode.Amem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Amem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L364-L365">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Amem.decidable" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> <span class="fn">x</span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.findMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L367-L373">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findMin'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, or the provided default value.</p><p>findMin' 37 {1, 2, 3} = 1
findMin' 37 ‚àÖ = 37</p><details id="instances-for-list-Ordnode.findMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L375-L381">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findMin" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, if it exists.</p><p>findMin {1, 2, 3} = some 1
findMin ‚àÖ = none</p><details id="instances-for-list-Ordnode.findMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L383-L389">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findMax'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, or the provided default value.</p><p>findMax' 37 {1, 2, 3} = 3
findMax' 37 ‚àÖ = 37</p><details id="instances-for-list-Ordnode.findMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L391-L397">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, if it exists.</p><p>findMax {1, 2, 3} = some 3
findMax ‚àÖ = none</p><details id="instances-for-list-Ordnode.findMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L399-L406">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.eraseMin" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.</p><p>eraseMin {1, 2, 3} = {2, 3}
eraseMin ‚àÖ = ‚àÖ</p><details id="instances-for-list-Ordnode.eraseMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L408-L415">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.eraseMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.</p><p>eraseMax {1, 2, 3} = {1, 2}
eraseMax ‚àÖ = ‚àÖ</p><details id="instances-for-list-Ordnode.eraseMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L417-L424">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitMin'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the minimum element from a nonempty tree.</p><details id="instances-for-list-Ordnode.splitMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L426-L432">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitMin" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span></span></div></div><p>O(log n). Extract and remove the minimum element from the tree, if it exists.</p><p>split_min {1, 2, 3} = some (1, {2, 3})
split_min ‚àÖ = none</p><details id="instances-for-list-Ordnode.splitMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L434-L441">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitMax'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn">Œ±</span></span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the maximum element from a nonempty tree.</p><details id="instances-for-list-Ordnode.splitMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L443-L449">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn">Œ±</span>)</span></span></span></div></div><p>O(log n). Extract and remove the maximum element from the tree, if it exists.</p><p>split_max {1, 2, 3} = some ({1, 2}, 3)
split_max ‚àÖ = none</p><details id="instances-for-list-Ordnode.splitMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.glue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L451-L463">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.glue" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p><strong>Internal use only</strong></p><p>O(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other.</p><details id="instances-for-list-Ordnode.glue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.merge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L465-L477">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.merge" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log(m + n)). Concatenate two trees that are ordered with respect to each other.</p><p>merge {1, 2} {3, 4} = {1, 2, 3, 4}
merge {3, 4} {1, 2} = precondition violation</p><details id="instances-for-list-Ordnode.merge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L479-L486">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.insertMax" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>O(log n). Insert an element above all the others, without any comparisons.
(Assumes that the element is in fact above all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 4 = {1, 2, 4}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 0 = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.insertMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L488-L495">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.insertMin" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Insert an element below all the others, without any comparisons.
(Assumes that the element is in fact below all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 0 = {0, 1, 2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 4 = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.insertMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.link"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L497-L511">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.link" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log(m+n)). Build a tree from an element between two trees, without any
assumption on the relative sizes.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 3} 2 {5} = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.link" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L513-L521">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.filter" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(n). Filter the elements of a tree satisfying a predicate.</p><p>filter (fun x ‚Ü¶ x &lt; 3) {1, 2, 4} = {1, 2}
filter (fun x ‚Ü¶ x &gt; 5) {1, 2, 4} = ‚àÖ</p><details id="instances-for-list-Ordnode.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.partition"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L523-L531">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.partition" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.</p><p>partition (fun x ‚Ü¶ x &lt; 3) {1, 2, 4} = ({1, 2}, {3})</p><details id="instances-for-list-Ordnode.partition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L533-L540">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.map" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ≤</span></span></span></div></div><p>O(n). Map a function across a tree, without changing the structure. Only valid when
the function is strictly monotone, i.e. <code>x &lt; y ‚Üí f x &lt; f y</code>.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (fun x ‚Ü¶ x + 2) {1, 2, 4} = {2, 3, 6}
 <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (fun x : ‚Ñï ‚Ü¶ x - 2) {1, 2, 4} = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.fold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L542-L550">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.fold" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">z</span> : <span class="fn">Œ≤</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Œ≤</span></span></div></div><p>O(n). Fold a function across the structure of a tree.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">fold</a> z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)
</code></pre><p>The exact structure of function applications depends on the tree and so
is unspecified.</p><details id="instances-for-list-Ordnode.fold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L552-L557">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.foldl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Œ≤</span></span></span></div></div><p>O(n). Fold a function from left to right (in increasing order) across the tree.</p><p>foldl f z {1, 2, 4} = f (f (f z 1) 2) 4</p><details id="instances-for-list-Ordnode.foldl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L559-L564">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.foldr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ≤</span> ‚Üí <span class="fn">Œ≤</span></span></span></div></div><p>O(n). Fold a function from right to left (in decreasing order) across the tree.</p><p>foldr f {1, 2, 4} z = f 1 (f 2 (f 4 z))</p><details id="instances-for-list-Ordnode.foldr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L566-L571">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.toList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span></div></div><p>O(n). Build a list of elements in ascending order from the tree.</p><p>toList {1, 2, 4} = [1, 2, 4]
toList {2, 1, 1, 4} = [1, 2, 4]</p><details id="instances-for-list-Ordnode.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toRevList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L573-L578">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.toRevList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span></div></div><p>O(n). Build a list of elements in descending order from the tree.</p><p>toRevList {1, 2, 4} = [4, 2, 1]
toRevList {2, 1, 1, 4} = [4, 2, 1]</p><details id="instances-for-list-Ordnode.toRevList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instToString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L580-L581">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instToString" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString"><span class="name">Ordnode</span>.<span class="name">instToString</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">ToString</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">ToString</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.instToFormat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L583-L584">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instToFormat" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat"><span class="name">Ordnode</span>.<span class="name">instToFormat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Std.ToFormat</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Std.ToFormat</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.Equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L586-L591">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.Equiv" class="verification-badge math-definition" title="Mathematical definition (Prop-valued)">üîπ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÅ </span><span class="fn">t‚ÇÇ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>O(n). True if the trees have the same elements, ignoring structural differences.</p><p>Equiv {1, 2, 4} {2, 1, 1, 4} = true
Equiv {1, 2, 4} {1, 2, 3} = false</p><details id="instances-for-list-Ordnode.Equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instDecidableRelEquivOfDecidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L593-L594">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq"><span class="name">Ordnode</span>.<span class="name">instDecidableRelEquivOfDecidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableEq</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">DecidableRel</span> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv">Equiv</a></span></div></div></div></div><div class="decl" id="Ordnode.powerset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L596-L600">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.powerset" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div><p>O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.</p><p>powerset {1, 2, 3} = {‚àÖ, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}</p><details id="instances-for-list-Ordnode.powerset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.prod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L602-L606">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.prod" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÅ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÇ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">√ó</span> <span class="fn">Œ≤</span>)</span></span></div></div><p>O(m * n). The Cartesian product of two sets: <code>(a, b) ‚àà s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod">prod</a> t</code> iff <code>a ‚àà s</code> and <code>b ‚àà t</code>.</p><p>prod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)}</p><details id="instances-for-list-Ordnode.prod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.copair"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L608-L613">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.copair" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÅ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÇ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn">Œ±</span> <span class="fn">‚äï</span> <span class="fn">Œ≤</span>)</span></span></div></div><p>O(m + n). Build a set on the disjoint union by combining sets on the factors.
<code>Or.inl a ‚àà s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>a ‚àà s</code>, and <code>Or.inr b ‚àà s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>b ‚àà t</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} 
</code></pre><details id="instances-for-list-Ordnode.copair" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.pmap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L615-L621">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.pmap" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">Œ±</span>) ‚Üí <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> ‚Üí <span class="fn">Œ≤</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ≤</span></span></span></div></div><p>O(n). Map a partial function across a set. The result depends on a proof
that the function is defined on all members of the set.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">pmap</a> (fin.mk : ‚àÄ n, n &lt; 4 ‚Üí fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} 
</code></pre><details id="instances-for-list-Ordnode.pmap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.attach'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L623-L628">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.attach'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">All</a> <span class="fn">P</span> <span class="fn">t</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn"><span class="fn">{</span> <span class="fn">a</span> <span class="fn">:</span> <span class="fn">Œ±</span> <span class="fn">//</span> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> <span class="fn">}</span></span></span></span></div></div><p>O(n). &quot;Attach&quot; the information that every element of <code>t</code> satisfies property
P to these elements inside the set, producing a set in the subtype.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'">attach'</a> (fun x ‚Ü¶ x &lt; 4) {1, 2} H = ({1, 2} : <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> {x // x&lt;4}) 
</code></pre><details id="instances-for-list-Ordnode.attach'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.nth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L630-L640">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.nth" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></span></div></div><p>O(log n). Get the <code>i</code>th element of the set, by its index from left to right.</p><p>nth {a, b, c, d} 2 = some c
nth {a, b, c, d} 5 = none</p><details id="instances-for-list-Ordnode.nth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.removeNth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L642-L652">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.removeNth" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>O(log n). Remove the <code>i</code>th element of the set, by its index from left to right.</p><p>remove_nth {a, b, c, d} 2 = {a, b, d}
remove_nth {a, b, c, d} 5 = {a, b, c, d}</p><details id="instances-for-list-Ordnode.removeNth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L654-L667">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.takeAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 2 = {a, b}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 5 = {a, b, c, d} 
</code></pre><details id="instances-for-list-Ordnode.takeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.take"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L669-L674">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.take" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p>O(log n). Get the first <code>i</code> elements of the set, counted from the left.</p><p>take 2 {a, b, c, d} = {a, b}
take 5 {a, b, c, d} = {a, b, c, d}</p><details id="instances-for-list-Ordnode.take" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L676-L689">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.dropAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code> if you know the
index is within the range of the data structure.)</p><pre><code>drop_aux {a, b, c, d} 2 = {c, d}
drop_aux {a, b, c, d} 5 = ‚àÖ 
</code></pre><details id="instances-for-list-Ordnode.dropAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.drop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L691-L696">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.drop" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p>O(log n). Remove the first <code>i</code> elements of the set, counted from the left.</p><p>drop 2 {a, b, c, d} = {c, d}
drop 5 {a, b, c, d} = ‚àÖ</p><details id="instances-for-list-Ordnode.drop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L698-L715">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitAtAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 2 = ({a, b}, {c, d})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 5 = ({a, b, c, d}, ‚àÖ) 
</code></pre><details id="instances-for-list-Ordnode.splitAtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L717-L722">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.splitAt" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Split a set at the <code>i</code>th element, getting the first <code>i</code> and everything else.</p><p>splitAt 2 {a, b, c, d} = ({a, b}, {c, d})
splitAt 5 {a, b, c, d} = ({a, b, c, d}, ‚àÖ)</p><details id="instances-for-list-Ordnode.splitAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L724-L731">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.takeWhile" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Get an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y ‚Üí p y ‚Üí p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ‚Ü¶ x &lt; 4) {1, 2, 3, 4, 5} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ‚Ü¶ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.takeWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L733-L740">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.dropWhile" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Remove an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y ‚Üí p y ‚Üí p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ‚Ü¶ x &lt; 4) {1, 2, 3, 4, 5} = {4, 5}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ‚Ü¶ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.dropWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.span"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L742-L755">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.span" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidablePred</span> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>O(log n). Split the set into those satisfying and not satisfying the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y ‚Üí p y ‚Üí p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ‚Ü¶ x &lt; 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ‚Ü¶ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details id="instances-for-list-Ordnode.span" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux‚ÇÅ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L757-L774">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ofAscListAux‚ÇÅ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux‚ÇÅ"><span class="name">Ordnode</span>.<span class="name">ofAscListAux‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><span class="fn">{</span> <span class="fn">l'</span> <span class="fn">:</span> <span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span> <span class="fn">//</span> <span class="fn"><span class="fn">l'</span>.<span class="fn">length</span></span> <a href="../../.././Mathlib/Algebra/Order/Kleene.html#LE.le">‚â§</a> <span class="fn"><span class="fn">l</span>.<span class="fn">length</span></span> <span class="fn">}</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><p><strong>Note:</strong> This function is defined by well-founded recursion, so it will probably not compute
in the kernel, meaning that you probably can't prove things like
<code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a> [1, 2, 3] = {1, 2, 3}</code> by <code>rfl</code>.
This implementation is optimized for VM evaluation.</p><details id="instances-for-list-Ordnode.ofAscListAux‚ÇÅ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux‚ÇÇ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L776-L784">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ofAscListAux‚ÇÇ" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux‚ÇÇ"><span class="name">Ordnode</span>.<span class="name">ofAscListAux‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><details id="instances-for-list-Ordnode.ofAscListAux‚ÇÇ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L786-L792">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ofAscList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(n). Build a set from a list which is already sorted. Performs no comparisons.</p><p>ofAscList [1, 2, 3] = {1, 2, 3}
ofAscList [3, 2, 1] = precondition violation</p><details id="instances-for-list-Ordnode.ofAscList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.mem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L798-L814">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.mem" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Bool</span></span></div></div><p>O(log n). Does the set (approximately) contain the element <code>x</code>? That is,
is there an element that is equivalent to <code>x</code> in the order?</p><pre><code>1 ‚àà {1, 2, 3} = true
4 ‚àà {1, 2, 3} = false
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code>(1, 1) ‚àà {(0, 1), (1, 2)} = true
(3, 1) ‚àà {(0, 1), (1, 2)} = false 
</code></pre><details id="instances-for-list-Ordnode.mem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.find"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L816-L832">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.find" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Retrieve an element in the set that is equivalent to <code>x</code> in the order,
if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 1 {1, 2, 3} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 4 {1, 2, 3} = none
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (1, 1) {(0, 1), (1, 2)} = some (1, 2)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (3, 1) {(0, 1), (1, 2)} = none 
</code></pre><details id="instances-for-list-Ordnode.find" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instMembership"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L834-L835">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instMembership" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership"><span class="name">Ordnode</span>.<span class="name">instMembership</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Membership</span> <span class="fn">Œ±</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.mem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L837-L838">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.mem.decidable" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Decidable</span> <span class="fn">(<span class="fn">x</span> <span class="fn">‚àà</span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.insertWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L840-L857">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.insertWith" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the function <code>f</code> is used to generate
the element to insert (being passed the current value in the set).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 0 {1, 2, 3} = {0, 1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details id="instances-for-list-Ordnode.insertWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.adjustWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L859-L876">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.adjustWith" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details id="instances-for-list-Ordnode.adjustWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.updateWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L878-L894">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.updateWith" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                          = {a, 2, 3}  if f 1 = some a 
</code></pre><details id="instances-for-list-Ordnode.updateWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.alter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L896-L913">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.alter" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 0 {1, 2, 3} = {1, 2, 3}     if f none = none
                    = {a, 1, 2, 3}  if f none = some a
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                    = {a, 2, 3}  if f 1 = some a 
</code></pre><details id="instances-for-list-Ordnode.alter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L915-L931">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.insert" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, this replaces it.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details id="instances-for-list-Ordnode.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instInsert"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L933-L934">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.instInsert" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert"><span class="name">Ordnode</span>.<span class="name">instInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Insert</span> <span class="fn">Œ±</span> <span class="fn">(<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span>)</span></span></div></div></div></div><div class="decl" id="Ordnode.insert'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L936-L952">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.insert'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the set is returned as is.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details id="instances-for-list-Ordnode.insert'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L954-L975">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.split" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it.
If an element equivalent to <code>x</code> is in the set, it is discarded.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 2 {1, 2, 4} = ({1}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 3 {1, 2, 4} = ({1, 2}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 4 {1, 2, 4} = ({1, 2}, ‚àÖ)
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ‚àÖ)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ‚àÖ) 
</code></pre><details id="instances-for-list-Ordnode.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L977-L998">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.split3" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span> <span class="fn">√ó</span> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it,
plus an element equivalent to <code>x</code>, if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 2 {1, 2, 4} = ({1}, some 2, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 3 {1, 2, 4} = ({1, 2}, none, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 4 {1, 2, 4} = ({1, 2}, some 4, ‚àÖ)
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ‚àÖ)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ‚àÖ) 
</code></pre><details id="instances-for-list-Ordnode.split3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1000-L1016">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.erase" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Remove an element from the set equivalent to <code>x</code>. Does nothing if there
is no such element.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 1 {1, 2, 3} = {2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 4 {1, 2, 3} = {1, 2, 3}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details id="instances-for-list-Ordnode.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1018-L1021">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findLtAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">findLt</a></code>.</p><details id="instances-for-list-Ordnode.findLtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1023-L1030">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findLt" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>&lt; x</code>.</p><p>findLt 2 {1, 2, 4} = some 1
findLt 3 {1, 2, 4} = some 2
findLt 0 {1, 2, 4} = none</p><details id="instances-for-list-Ordnode.findLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1032-L1035">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findGtAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">findGt</a></code>.</p><details id="instances-for-list-Ordnode.findGtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1037-L1044">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findGt" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>&gt; x</code>.</p><p>findGt 2 {1, 2, 4} = some 4
findGt 3 {1, 2, 4} = some 4
findGt 4 {1, 2, 4} = none</p><details id="instances-for-list-Ordnode.findGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1046-L1053">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findLeAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">findLe</a></code>.</p><details id="instances-for-list-Ordnode.findLeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1055-L1066">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findLe" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>‚â§ x</code>.</p><p>findLe 2 {1, 2, 4} = some 2
findLe 3 {1, 2, 4} = some 2
findLe 0 {1, 2, 4} = none</p><details id="instances-for-list-Ordnode.findLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1068-L1075">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findGeAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ±</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">findGe</a></code>.</p><details id="instances-for-list-Ordnode.findGeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1077-L1088">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findGe" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">Œ±</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>‚â• x</code>.</p><p>findGe 2 {1, 2, 4} = some 2
findGe 3 {1, 2, 4} = some 4
findGe 5 {1, 2, 4} = none</p><details id="instances-for-list-Ordnode.findGe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndexAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1090-L1097">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findIndexAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><span class="fn">‚Ñï</span> ‚Üí <span class="fn"><span class="fn">Option</span> <span class="fn">‚Ñï</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a></code>.</p><details id="instances-for-list-Ordnode.findIndexAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1099-L1106">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.findIndex" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Œ±</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Option</span> <span class="fn">‚Ñï</span></span></div></div><p>O(log n). Get the index, counting from the left,
of an element equivalent to <code>x</code> if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 2 {1, 2, 4} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 4 {1, 2, 4} = some 2
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 5 {1, 2, 4} = none 
</code></pre><details id="instances-for-list-Ordnode.findIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubsetAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1108-L1114">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.isSubsetAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Bool</span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset">isSubset</a></code>.</p><details id="instances-for-list-Ordnode.isSubsetAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1116-L1121">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.isSubset" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t‚ÇÅ </span><span class="fn">t‚ÇÇ</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Bool</span></div></div><p>O(m + n). Is every element of <code>t‚ÇÅ</code> equivalent to some element of <code>t‚ÇÇ</code>?</p><p>is_subset {1, 4} {1, 2, 4} = tt
is_subset {1, 3} {1, 2, 4} = ff</p><details id="instances-for-list-Ordnode.isSubset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.disjoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1123-L1132">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.disjoint" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn">Bool</span></span></div></div><p>O(m + n). Is every element of <code>t‚ÇÅ</code> not equivalent to any element of <code>t‚ÇÇ</code>?</p><p>disjoint {1, 3} {2, 4} = tt
disjoint {1, 2} {2, 4} = ff</p><details id="instances-for-list-Ordnode.disjoint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1134-L1152">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.union" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(m * log(|m ‚à™ n| + 1)), m ‚â§ n. The union of two sets, preferring members of
<code>t‚ÇÅ</code> over those of <code>t‚ÇÇ</code> when equivalent elements are encountered.</p><p>union {1, 2} {2, 3} = {1, 2, 3}
union {1, 3} {2} = {1, 2, 3}</p><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><p>union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)}</p><details id="instances-for-list-Ordnode.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.diff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1154-L1165">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.diff" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(m * log(|m ‚à™ n| + 1)), m ‚â§ n. Difference of two sets.</p><p>diff {1, 2} {2, 3} = {1}
diff {1, 2, 3} {2} = {1, 3}</p><details id="instances-for-list-Ordnode.diff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.inter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1167-L1179">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.inter" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(m * log(|m ‚à™ n| + 1)), m ‚â§ n. Intersection of two sets, preferring members of
<code>t‚ÇÅ</code> over those of <code>t‚ÇÇ</code> when equivalent elements are encountered.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 2} {2, 3} = {2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 3} {2} = ‚àÖ 
</code></pre><details id="instances-for-list-Ordnode.inter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1181-L1191">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ofList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></div></div><p>O(n * log n). Build a set from a list, preferring elements that appear earlier in the list
in the case of equivalent elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [1, 2, 3] = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [2, 1, 1, 3] = {1, 2, 3}
</code></pre><p>Using a preorder on <code>‚Ñï √ó ‚Ñï</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} 
</code></pre><details id="instances-for-list-Ordnode.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1193-L1200">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.ofList'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ±</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">List</span> <span class="fn">Œ±</span></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span></span></div></div><p>O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending
on whether the input list is already sorted.</p><p>ofList' [1, 2, 3] = {1, 2, 3}
ofList' [2, 1, 1, 3] = {1, 2, 3}</p><details id="instances-for-list-Ordnode.ofList'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.image"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Data/Ordmap/Ordnode.lean#L1202-L1209">source</a></div><div class="verification_link">
<a href="../../../../modules/Mathlib_Data_Ordmap_Ordnode.html#Ordnode.image" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ±</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œ≤</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">LE</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">DecidableLE</span> <span class="fn">Œ≤</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">Œ±</span> ‚Üí <span class="fn">Œ≤</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ±</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">Œ≤</span></span></div></div><p>O(n * log n). Map a function on a set. Unlike <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">map</a></code> this has no requirements on
<code>f</code>, and the resulting set may be smaller than the input if <code>f</code> is noninjective.
Equivalent elements are selected with a preference for smaller source elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (fun x ‚Ü¶ x + 2) {1, 2, 4} = {3, 4, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (fun x : ‚Ñï ‚Ü¶ x - 2) {1, 2, 4} = {0, 2} 
</code></pre><details id="instances-for-list-Ordnode.image" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>