<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.CongrExclamation</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.CongrExclamation";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CongrExclamation</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Logic/Basic.html">Mathlib.Logic.Basic</a></li><li><a href="../.././Lean/Elab/Tactic/Config.html">Lean.Elab.Tactic.Config</a></li><li><a href="../.././Lean/Elab/Tactic/RCases.html">Lean.Elab.Tactic.RCases</a></li><li><a href="../.././Lean/Meta/Tactic/Assumption.html">Lean.Meta.Tactic.Assumption</a></li><li><a href="../.././Lean/Meta/Tactic/Rfl.html">Lean.Meta.Tactic.Rfl</a></li><li><a href="../.././Mathlib/Lean/Meta/CongrTheorems.html">Mathlib.Lean.Meta.CongrTheorems</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.CongrExclamation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Congr!.Config"><span class="name">Congr!</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.Config.unfoldSameFun"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">unfoldSameFun</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.Config.numArgsOk"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">numArgsOk</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.Config.maxArgsFor"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">maxArgsFor</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.plausiblyEqualTypes"><span class="name">Congr!</span>.<span class="name">plausiblyEqualTypes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.smartHCongr?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">smartHCongr?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrSimp?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrSimp?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.userCongr?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">userCongr?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrPi?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrPi?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.obviousFunext?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">obviousFunext?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.obviousHfunext?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">obviousHfunext?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrImplies?'"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrImplies?'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.subsingletonHelim?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">subsingletonHelim?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.beqInst?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">beqInst?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrPasses!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrPasses!</span></a></div><div class="nav_link"><a class="break_within" href="#CongrState"><span class="name">CongrState</span></a></div><div class="nav_link"><a class="break_within" href="#CongrMetaM"><span class="name">CongrMetaM</span></a></div><div class="nav_link"><a class="break_within" href="#CongrMetaM.nextPattern"><span class="name">CongrMetaM</span>.<span class="name">nextPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.introsClean"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">introsClean</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.preCongr!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">preCongr!</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrCore!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrCore!</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.postCongr!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">postCongr!</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.congrN!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrN!</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.elabConfig"><span class="name">Congr!</span>.<span class="name">elabConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Congr!.congr!"><span class="name">Congr!</span>.<span class="name">congr!</span></a></div></nav><main>
<div class="mod_doc"><h1 id="The-congr-tactic" class="markdown-heading">The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic <a class="hover-link" href="#The-congr-tactic">#</a></h1><p>This is a more powerful version of the <code>congr</code> tactic that knows about more congruence lemmas and
can apply to more situations. It is similar to the <code>congr'</code> tactic from Mathlib 3.</p><p>The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic is used by the <code>convert</code> and <code>convert_to</code> tactics.</p><h2 id="Detailed-description" class="markdown-heading">Detailed description <a class="hover-link" href="#Detailed-description">#</a></h2><p><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> equates pieces of the left-hand side of a goal to corresponding pieces of the right-hand
side by recursively applying congruence lemmas. For example, with <code>‚ä¢ f as = g bs</code> we could get
two goals <code>‚ä¢ f = g</code> and <code>‚ä¢ as = bs</code>.</p><p>Syntax:</p><pre><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a>
<a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> n
<a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> with x y z
<a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> n with x y z
</code></pre><p>Here, <code>n</code> is a natural number and <code>x</code>, <code>y</code>, <code>z</code> are <code>rintro</code> patterns (like <code>h</code>, <code>rfl</code>, <code>‚ü®x, y‚ü©</code>,
<code>_</code>, <code>-</code>, <code>(h | h)</code>, etc.).</p><p>The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic is similar to <code>congr</code> but is more insistent in trying to equate left-hand sides
to right-hand sides of goals. Here is an exhaustive list of things it can try:</p><ul><li><p>If <code>R</code> in <code>‚ä¢ R x y</code> is a reflexive relation, it will convert the goal to <code>‚ä¢ x = y</code> if possible.
The list of reflexive relations is maintained using the <code>@[refl]</code> attribute.
As a special case, <code>‚ä¢ p ‚Üî q</code> is converted to <code>‚ä¢ p = q</code> during congruence processing and then
returned to <code>‚ä¢ p ‚Üî q</code> form at the end.</p></li><li><p>If there is a user congruence lemma associated to the goal (for instance, a <code>@[congr]</code>-tagged
lemma applying to <code>‚ä¢ List.map f xs = List.map g ys</code>), then it will use that.</p></li><li><p>It uses a congruence lemma generator at least as capable as the one used by <code>congr</code> and <code>simp</code>.
If there is a subexpression that can be rewritten by <code>simp</code>, then <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> should be able
to generate an equality for it.</p></li><li><p>It can do congruences of pi types using lemmas like <code>implies_congr</code> and <code>pi_congr</code>.</p></li><li><p>Before applying congruences, it will run the <code>intros</code> tactic automatically.
The introduced variables can be given names using a <code>with</code> clause.
This helps when congruence lemmas provide additional assumptions in hypotheses.</p></li><li><p>When there is an equality between functions, so long as at least one is obviously a lambda, we
apply <code>funext</code> or <code><a href="../.././Mathlib/Logic/Function/Basic.html#Function.hfunext">Function.hfunext</a></code>, which allows for congruence of lambda bodies.</p></li><li><p>It can try to close goals using a few strategies, including checking
definitional equality, trying to apply <code>Subsingleton.elim</code> or <code>proof_irrel_heq</code>, and using the
<code>assumption</code> tactic.</p></li></ul><p>The optional parameter is the depth of the recursive applications.
This is useful when <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> is too aggressive in breaking down the goal.
For example, given <code>‚ä¢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> produces the goals <code>‚ä¢ x = y</code> and <code>‚ä¢ y = x</code>,
while <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> 2</code> produces the intended <code>‚ä¢ x + y = y + x</code>.</p><p>The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic also takes a configuration option, for example</p><pre><code class="language-lean"><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> (transparency := .default) 2
</code></pre><p>This overrides the default, which is to apply congruence lemmas at reducible transparency.</p><p>The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic is aggressive with equating two sides of everything. There is a predefined
configuration that uses a different strategy:</p><pre><code class="language-lean"><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> (config := .unfoldSameFun)
</code></pre><p>This only allows congruences between functions applications of definitionally equal functions,
and it applies congruence lemmas at default transparency (rather than just reducible).
This is somewhat like <code>congr</code>.</p><p>See <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code> for all options.</p></div><div class="decl" id="Congr!.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L101-L183">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.Config" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config"><span class="name">Congr!</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The configuration for the <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic.</p><ul class="structure_fields" id="Congr!.Config.mk"><li id="Congr!.Config.closePre" class="structure_field"><div class="structure_field_info">closePre : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>If <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePre">closePre</a> := true</code>, then try to close goals before applying congruence lemmas
using tactics such as <code>rfl</code> and <code>assumption</code>. These tactics are applied with the
transparency level specified by <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preTransparency">preTransparency</a></code>, which is <code>.reducible</code> by default.</p></div></li><li id="Congr!.Config.closePost" class="structure_field"><div class="structure_field_info">closePost : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>If <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePost">closePost</a> := true</code>, then try to close goals that remain after no more congruence
lemmas can be applied, using the same tactics as <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.closePre">closePre</a></code>. These tactics are applied
with current tactic transparency level.</p></div></li><li id="Congr!.Config.transparency" class="structure_field"><div class="structure_field_info">transparency : <span class="fn">Lean.Meta.TransparencyMode</span></div><div class="structure_field_doc"><p>The transparency level to use when applying a congruence theorem.
By default this is <code>.reducible</code>, which prevents unfolding of most definitions.</p></div></li><li id="Congr!.Config.preTransparency" class="structure_field"><div class="structure_field_info">preTransparency : <span class="fn">Lean.Meta.TransparencyMode</span></div><div class="structure_field_doc"><p>The transparency level to use when trying to close goals before applying congruence lemmas.
This includes trying to prove the goal by <code>rfl</code> and using the <code>assumption</code> tactic.
By default this is <code>.reducible</code>, which prevents unfolding of most definitions.</p></div></li><li id="Congr!.Config.preferLHS" class="structure_field"><div class="structure_field_info">preferLHS : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>For passes that synthesize a congruence lemma using one side of the equality,
we run the pass both for the left-hand side and the right-hand side. If <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS">preferLHS</a></code> is <code>true</code>
then we start with the left-hand side.</p><p>This can be used to control which side's definitions are expanded when applying the
congruence lemma (if <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS">preferLHS</a> = true</code> then the RHS can be expanded).</p></div></li><li id="Congr!.Config.partialApp" class="structure_field"><div class="structure_field_info">partialApp : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>Allow both sides to be partial applications.
When false, given an equality <code>f a b = g x y z</code> this means we never consider
proving <code>f a = g x y</code>.</p><p>In this case, we might still consider <code>f = g x</code> if a pass generates a congruence lemma using the
left-hand side. Use <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.sameFun">sameFun</a> := true</code> to ensure both sides are applications
of the same function (making it be similar to the <code>congr</code> tactic).</p></div></li><li id="Congr!.Config.sameFun" class="structure_field"><div class="structure_field_info">sameFun : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>Whether to require that both sides of an equality be applications of defeq functions.
That is, if true, <code>f a = g x</code> is only considered if <code>f</code> and <code>g</code> are defeq (making it be similar
to the <code>congr</code> tactic).</p></div></li><li id="Congr!.Config.maxArgs" class="structure_field"><div class="structure_field_info">maxArgs : <span class="fn"><span class="fn">Option</span> <span class="fn">‚Ñï</span></span></div><div class="structure_field_doc"><p>The maximum number of arguments to consider when doing congruence of function applications.
For example, with <code>f a b c = g w x y z</code>, setting <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a> := some 2</code> means it will only consider
either <code>f a b = g w x y</code> and <code>c = z</code> or <code>f a = g w x</code>, <code>b = y</code>, and <code>c = z</code>. Setting
<code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a> := none</code> (the default) means no limit.</p><p>When the functions are dependent, <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a></code> can prevent congruence from working at all.
In <code><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> Œ± = <a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> Œ≤</code>, one needs to have <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a></code> at <code>2</code> or higher since
there is a <code><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a></code> instance argument that depends on the first.</p><p>When there aren't such dependency issues, setting <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a> := some 1</code> causes <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> to
do congruence on a single argument at a time. This can be used in conjunction with the
iteration limit to control exactly how many arguments are to be processed by congruence.</p></div></li><li id="Congr!.Config.typeEqs" class="structure_field"><div class="structure_field_info">typeEqs : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>For type arguments that are implicit or have forward dependencies, whether or not <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code>
should generate equalities even if the types do not look plausibly equal.</p><p>We have a heuristic in the main congruence generator that types
<code>Œ±</code> and <code>Œ≤</code> are <em>plausibly equal</em> according to the following algorithm:</p><ul><li>If the types are both propositions, they are plausibly equal (<code>Iff</code>s are plausible).</li><li>If the types are from different universes, they are not plausibly equal.</li><li>Suppose in whnf we have <code>Œ± = f a‚ÇÅ ... a‚Çò</code> and <code>Œ≤ = g b‚ÇÅ ... b‚Çò</code>. If <code>f</code> is not definitionally
equal to <code>g</code> or <code>m ‚â† n</code>, then <code>Œ±</code> and <code>Œ≤</code> are not plausibly equal.</li><li>If there is some <code>i</code> such that <code>a·µ¢</code> and <code>b·µ¢</code> are not plausibly equal, then <code>Œ±</code> and <code>Œ≤</code> are
not plausibly equal.</li><li>Otherwise, <code>Œ±</code> and <code>Œ≤</code> are plausibly equal.</li></ul><p>The purpose of this is to prevent considering equalities like <code>‚Ñï = ‚Ñ§</code> while allowing equalities
such as <code>Fin n = Fin m</code> or <code>Subtype p = Subtype q</code> (so long as these are subtypes of the
same type).</p><p>The way this is implemented is that when the congruence generator is comparing arguments when
looking at an equality of function applications, it marks a function parameter as &quot;fixed&quot; if the
provided arguments are types that are not plausibly equal. The effect of this is that congruence
succeeds only if those arguments are defeq at <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.transparency">transparency</a></code> transparency.</p></div></li><li id="Congr!.Config.etaExpand" class="structure_field"><div class="structure_field_info">etaExpand : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>As a last pass, perform eta expansion of both sides of an equality. For example,
this transforms a bare <code>HAdd.hAdd</code> into <code>fun x y =&gt; x + y</code>.</p></div></li><li id="Congr!.Config.useCongrSimp" class="structure_field"><div class="structure_field_info">useCongrSimp : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>Whether to use the congruence generator that is used by <code>simp</code> and <code>congr</code>. This generator
is more strict, and it does not respect all configuration settings. It does respect
<code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS">preferLHS</a></code>, <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.partialApp">partialApp</a></code> and <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgs">maxArgs</a></code> and transparency settings. It acts as if <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.sameFun">sameFun</a> := true</code>
and it ignores <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.typeEqs">typeEqs</a></code>.</p></div></li><li id="Congr!.Config.beqEq" class="structure_field"><div class="structure_field_info">beqEq : <span class="fn">Bool</span></div><div class="structure_field_doc"><p>Whether to use a special congruence lemma for <code>BEq</code> instances.
This synthesizes <code>LawfulBEq</code> instances to discharge equalities of <code>BEq</code> instances.</p></div></li></ul><details id="instances-for-list-Congr!.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.Config.unfoldSameFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L185-L192">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.Config.unfoldSameFun" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.unfoldSameFun"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">unfoldSameFun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Config</a></div></div><p>A configuration option that makes <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> do the sorts of aggressive unfoldings that <code>congr</code>
does while also similarly preventing <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> from considering partial applications or congruences
between different functions being applied.</p><details id="instances-for-list-Congr!.Config.unfoldSameFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.Config.numArgsOk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L194-L196">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.Config.numArgsOk" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.numArgsOk"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">numArgsOk</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">numArgs</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Bool</span></div></div><p>Whether the given number of arguments is allowed to be considered.</p><details id="instances-for-list-Congr!.Config.numArgsOk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.Config.maxArgsFor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L198-L200">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.Config.maxArgsFor" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.maxArgsFor"><span class="name">Congr!</span>.<span class="name">Config</span>.<span class="name">maxArgsFor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">numArgs</span> : <span class="fn">‚Ñï</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Ñï</span></div></div><p>According to the configuration, how many of the arguments in <code>numArgs</code> should be considered.</p><details id="instances-for-list-Congr!.Config.maxArgsFor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.plausiblyEqualTypes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L223-L255">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.plausiblyEqualTypes" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.plausiblyEqualTypes"><span class="name">Congr!</span>.<span class="name">plausiblyEqualTypes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ty1 </span><span class="fn">ty2</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">maxDepth</span> : <span class="fn">‚Ñï</span> := <span class="fn">5</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Bool</span></span></div></div><p>Returns whether or not it's reasonable to consider an equality between types <code>ty1</code> and <code>ty2</code>.
The heuristic is the following:</p><ul><li>If <code>ty1</code> and <code>ty2</code> are in <code>Prop</code>, then yes.</li><li>If in whnf both <code>ty1</code> and <code>ty2</code> have the same head and if (recursively) it's reasonable to
consider an equality between corresponding type arguments, then yes.</li><li>Otherwise, no.</li></ul><p>This helps keep congr from going too far and generating hypotheses like <code>‚Ñù = ‚Ñ§</code>.</p><p>To keep things from going out of control, there is a <code>maxDepth</code>. Additionally, if we do the check
with <code>maxDepth = 0</code> then the heuristic answers &quot;no&quot;.</p><details id="instances-for-list-Congr!.plausiblyEqualTypes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.smartHCongr?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L257-L371">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.smartHCongr?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.smartHCongr?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">smartHCongr?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>This is like <code>Lean.MVarId.hcongr?</code> but (1) looks at both sides when generating the congruence lemma
and (2) inserts additional hypotheses from equalities from previous arguments.</p><p>It uses <code><a href="../.././Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr">Lean.Meta.mkRichHCongr</a></code> to generate the congruence lemmas.</p><p>If the goal is an <code>Eq</code>, it uses <code>eq_of_heq</code> first.</p><p>As a backup strategy, it uses the LHS/RHS method like in <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrSimp?">Lean.MVarId.congrSimp?</a></code>
(where <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS">Congr!.Config.preferLHS</a></code> determines which side to try first). This uses a particular side
of the target, generates the congruence lemma, then tries applying it. This can make progress
with higher transparency settings. To help the unifier, in this mode it assumes both sides have the
exact same function.</p><details id="instances-for-list-Lean.MVarId.smartHCongr?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrSimp?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L373-L412">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrSimp?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrSimp?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrSimp?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Like <code>Lean.MVarId.congr?</code> but instead of using only the congruence lemma associated to the LHS,
it tries the RHS too, in the order specified by <code>config.<a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.preferLHS">preferLHS</a></code>.</p><p>It uses <code>Lean.Meta.mkCongrSimp?</code> to generate a congruence lemma, like in the <code>congr</code> tactic.</p><p>Applies the congruence generated congruence lemmas according to <code>config</code>.</p><details id="instances-for-list-Lean.MVarId.congrSimp?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.userCongr?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L414-L448">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.userCongr?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.userCongr?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">userCongr?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Try applying user-provided congruence lemmas. If any are applicable,
returns a list of new goals.</p><p>Tries a congruence lemma associated to the LHS and then, if that failed, the RHS.</p><details id="instances-for-list-Lean.MVarId.userCongr?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrPi?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L450-L454">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrPi?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPi?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrPi?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Try to apply <code>pi_congr</code>. This is similar to <code>Lean.MVar.congrImplies?</code>.</p><details id="instances-for-list-Lean.MVarId.congrPi?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.obviousFunext?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L456-L467">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.obviousFunext?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousFunext?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">obviousFunext?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Try to apply <code>funext</code>, but only if it is an equality of two functions where at least one is
a lambda expression.</p><p>One thing this check prevents is accidentally applying <code>funext</code> to a set equality, but also when
doing congruence we don't want to apply <code>funext</code> unnecessarily.</p><details id="instances-for-list-Lean.MVarId.obviousFunext?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.obviousHfunext?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L469-L480">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.obviousHfunext?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousHfunext?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">obviousHfunext?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Try to apply <code><a href="../.././Mathlib/Logic/Function/Basic.html#Function.hfunext">Function.hfunext</a></code>, returning the new goals if it succeeds.
Like <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.obviousFunext?">Lean.MVarId.obviousFunext?</a></code>, we only do so if at least one side of the <code>HEq</code> is a lambda.
This prevents unfolding of things like <code><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a></code>.</p><p>Need to have <code><a href="../.././Mathlib/Logic/Function/Basic.html">Mathlib/Logic/Function/Basic.lean</a></code> imported for this to succeed.</p><details id="instances-for-list-Lean.MVarId.obviousHfunext?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrImplies?'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L490-L496">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrImplies?'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrImplies?'"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrImplies?'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>A version of <code>Lean.MVarId.congrImplies?</code> that uses <code>implies_congr'</code>
instead of <code>implies_congr</code>.</p><details id="instances-for-list-Lean.MVarId.congrImplies?'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.subsingletonHelim?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L498-L519">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.subsingletonHelim?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.subsingletonHelim?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">subsingletonHelim?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Try to apply <code>Subsingleton.helim</code> if the goal is a <code>HEq</code>. Tries synthesizing a <code>Subsingleton</code>
instance for both the LHS and the RHS.</p><p>If successful, this reduces proving <code>@HEq Œ± x Œ≤ y</code> to proving <code>Œ± = Œ≤</code>.</p><details id="instances-for-list-Lean.MVarId.subsingletonHelim?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.beqInst?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L521-L526">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.beqInst?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.beqInst?"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">beqInst?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><p>Tries to apply <code><a href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton">lawful_beq_subsingleton</a></code> to prove that two <code>BEq</code> instances are equal
by synthesizing <code>LawfulBEq</code> instances for both.</p><details id="instances-for-list-Lean.MVarId.beqInst?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrPasses!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L528-L549">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrPasses!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrPasses!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrPasses!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">String</span> <span class="fn">√ó</span> <span class="fn">(<a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a> ‚Üí <span class="fn"><span class="fn">MVarId</span> ‚Üí <span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></span>)</span>)</span></span></div></div><p>A list of all the congruence strategies used by <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrCore!">Lean.MVarId.congrCore!</a></code>.</p><details id="instances-for-list-Lean.MVarId.congrPasses!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CongrState"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L551-L555">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#CongrState" class="verification-badge comp-datatype" title="Computational datatype">üî∂ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#CongrState"><span class="name">CongrState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="CongrState.mk"><li id="CongrState.goals" class="structure_field"><div class="structure_field_info">goals : <span class="fn"><span class="fn">Array</span> <span class="fn">Lean.MVarId</span></span></div><div class="structure_field_doc"><p>Accumulated goals that <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> could not handle.</p></div></li><li id="CongrState.patterns" class="structure_field"><div class="structure_field_info">patterns : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">Lean.TSyntax</span> <span class="fn">`rcasesPat</span>)</span></span></div><div class="structure_field_doc"><p>Patterns to use when doing intro.</p></div></li></ul><details id="instances-for-list-CongrState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CongrMetaM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L557-L557">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#CongrMetaM" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#CongrMetaM"><span class="name">CongrMetaM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Œ±</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><details id="instances-for-list-CongrMetaM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CongrMetaM.nextPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L559-L565">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#CongrMetaM.nextPattern" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#CongrMetaM.nextPattern"><span class="name">CongrMetaM</span>.<span class="name">nextPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/CongrExclamation.html#CongrMetaM">CongrMetaM</a> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">Lean.TSyntax</span> <span class="fn">`rcasesPat</span>)</span>)</span></span></div></div><p>Pop the next pattern from the current state.</p><details id="instances-for-list-CongrMetaM.nextPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.introsClean"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L577-L634">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.introsClean" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.introsClean"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">introsClean</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/CongrExclamation.html#CongrMetaM">CongrMetaM</a> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span></span></div></div><p>Does <code>Lean.MVarId.intros</code> but then cleans up the introduced hypotheses, removing anything
that is trivial. If there are any patterns in the current <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#CongrMetaM">CongrMetaM</a></code> state then instead
of <code>Lean.MVarId.intros</code> it does <code>Lean.Elab..Tactic.RCases.rintro</code>.</p><p>Cleaning up includes:</p><ul><li>deleting hypotheses of the form <code>x ‚âç x</code>, <code>x = x</code>, and <code>x ‚Üî x</code>.</li><li>deleting Prop hypotheses that are already in the local context.</li><li>converting <code>x ‚âç y</code> to <code>x = y</code> if possible.</li><li>converting <code>x = y</code> to <code>x ‚Üî y</code> if possible.</li></ul><details id="instances-for-list-Lean.MVarId.introsClean" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.preCongr!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L636-L654">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.preCongr!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.preCongr!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">preCongr!</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tryClose</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">MVarId</span>)</span></span></div></div><p>Convert a goal into an <code>Eq</code> goal if possible (since we have a better shot at those).
Also, if <code>tryClose := true</code>, then try to close the goal using an assumption, <code>Subsingleton.Elim</code>,
or definitional equality.</p><details id="instances-for-list-Lean.MVarId.preCongr!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrCore!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L656-L676">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrCore!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrCore!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrCore!</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span>)</span></span></div></div><details id="instances-for-list-Lean.MVarId.congrCore!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.postCongr!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L678-L691">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.postCongr!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.postCongr!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">postCongr!</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">Option</span> <span class="fn">MVarId</span>)</span></span></div></div><p>A pass to clean up after <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.preCongr!">Lean.MVarId.preCongr!</a></code> and <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrCore!">Lean.MVarId.congrCore!</a></code>.</p><details id="instances-for-list-Lean.MVarId.postCongr!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.congrN!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L693-L728">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Lean.MVarId.congrN!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Lean.MVarId.congrN!"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">congrN!</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">MVarId</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">depth?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">‚Ñï</span></span> := <span class="fn">none</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">config</span> : <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a> := <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk">{</a> <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config.mk">}</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">patterns</span> : <span class="fn"><span class="fn">List</span> <span class="fn">(<span class="fn">TSyntax</span> <span class="fn">`rcasesPat</span>)</span></span> := <span class="fn"><span class="fn">[</span><span class="fn">]</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">MetaM</span> <span class="fn">(<span class="fn">List</span> <span class="fn">MVarId</span>)</span></span></div></div><p>A more insistent version of <code>Lean.MVarId.congrN</code>.
See the documentation on the <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> syntax.</p><p>The <code>depth?</code> argument controls the depth of the recursion. If <code>none</code>, then it uses a reasonably
large bound that is linear in the expression depth.</p><details id="instances-for-list-Lean.MVarId.congrN!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.elabConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L732-L732">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.elabConfig" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.elabConfig"><span class="name">Congr!</span>.<span class="name">elabConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Syntax</span> ‚Üí <span class="fn"><span class="fn">Lean.Elab.Tactic.TacticM</span> <a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Config</a></span></span></div></div><details id="instances-for-list-Congr!.elabConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Congr!.congr!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/CongrExclamation.lean#L734-L755">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_CongrExclamation.html#Congr!.congr!" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!"><span class="name">Congr!</span>.<span class="name">congr!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tries to prove the main goal by repeatedly applying congruence rules. For example, on a
goal of the form <code>‚ä¢ f a1 a2 ... = f b1 b2 ...</code>, <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> will make new goals <code>‚ä¢ a1 = b1</code>,
<code>‚ä¢ a2 = b2</code>, ...</p><p><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> is a more powerful version of the <code>congr</code> tactic that uses congruence lemmas (tagged with
<code>@[congr]</code>), reflexivity rules (tagged with <code>@[refl]</code>) and proof discharging strategies. The full
list of congruence proof strategies is documented in the module <code><a href="../.././Mathlib/Tactic/CongrExclamation.html">Mathlib.Tactic.CongrExclamation</a></code>.
The <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a></code> tactic is used by the <code>convert</code> and <code>convert_to</code> tactics.</p><ul><li><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence is
applied. For example, if the main goal is <code>n + n + 1 = 2 * n + 1</code>, then <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> 1</code> results in one
goal, <code>‚ä¢ n + n = 2 * n</code>, and <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> 2</code> (or more) results in two (impossible) goals
<code>‚ä¢ HAdd.hAdd = HMul.hMul</code> and <code>‚ä¢ n = 2</code>.
By default, the depth is unlimited.</li><li><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">congr!</a> (config := cfg)</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="../.././Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul><details id="instances-for-list-Congr!.congr!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>