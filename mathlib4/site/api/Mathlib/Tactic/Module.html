<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Module</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Module";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/Ring.html">Mathlib.Tactic.Ring</a></li><li><a href="../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../.././Mathlib/Algebra/Algebra/Defs.html">Mathlib.Algebra.Algebra.Defs</a></li><li><a href="../.././Mathlib/Algebra/Algebra/Tower.html">Mathlib.Algebra.Algebra.Tower</a></li><li><a href="../.././Mathlib/Algebra/BigOperators/GroupWithZero/Action.html">Mathlib.Algebra.BigOperators.GroupWithZero.Action</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Module" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.¬´term_::·µ£_¬ª"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">¬´term_::·µ£_¬ª</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.atom_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">atom_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.zero_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÅ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÇ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÉ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÅ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÅ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÇ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÇ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÉ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÉ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.instNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_sub_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.neg_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">neg_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.instSMulOfMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instSMulOfMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.smul_apply"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.smul_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_cons_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_cons_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_const</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_const_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_const_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_of_eval_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">algebraMap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_algebraMap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.onScalar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">onScalar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.mkAddProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkAddProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.mkSubProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkSubProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.matchRings"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">matchRings</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.parse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.reduceCoefficientwise"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">reduceCoefficientwise</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.matchScalarsAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalarsAux</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.algebraMapThms"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">algebraMapThms</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.postprocess"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">postprocess</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.matchScalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalars</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.tacticMatch_scalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticMatch_scalars</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.tacticModule"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticModule</span></a></div></nav><main>
<div class="mod_doc"><h1 id="A-tactic-for-normalization-over-modules" class="markdown-heading">A tactic for normalization over modules <a class="hover-link" href="#A-tactic-for-normalization-over-modules">#</a></h1><p>This file provides the two tactics <code>match_scalars</code> and <code>module</code>.  Given a goal which is an equality
in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), the <code>match_scalars</code> tactic parses the LHS and RHS of
the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduces the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.  The <code>module</code> tactic does this and
then runs the <code>ring</code> tactic on each of these coefficient-wise equalities, failing if this does not
resolve them.</p><p>The scalar type <code>R</code> is not pre-determined: instead it starts as <code>‚Ñï</code> (when each atom is initially
given a scalar <code>(1:‚Ñï)</code>) and gets bumped up into bigger semirings when such semirings are
encountered.  However, to permit this, it is assumed that there is a &quot;linear order&quot; on all the
semirings which appear in the expression: for any two semirings <code>R</code> and <code>S</code> which occur, we have
either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>.</p></div><div class="mod_doc"><h3 id="Theory-of-lists-of-pairs-scalar-vector" class="markdown-heading">Theory of lists of pairs (scalar, vector) <a class="hover-link" href="#Theory-of-lists-of-pairs-scalar-vector">#</a></h3><p>This section contains the lemmas which are orchestrated by the <code>match_scalars</code> and <code>module</code> tactics
to prove goals in modules.  The basic object which these lemmas concern is <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> R M</code>, a type synonym
for a list of ordered pairs in <code>R √ó M</code>, where typically <code>M</code> is an <code>R</code>-module.</p></div><div class="decl" id="Mathlib.Tactic.Module.NF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L46-L52">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u_2 u_1)</div></div><p>Basic theoretical &quot;normal form&quot; object of the <code>match_scalars</code> and <code>module</code> tactics: a type
synonym for a list of ordered pairs in <code>R √ó M</code>, where typically <code>M</code> is an <code>R</code>-module.  This is the
form to which the tactics reduce module expressions.</p><p>(It is not a full &quot;normal form&quot; because the scalars, i.e. <code>R</code> components, are not themselves
ring-normalized. But this partial normal form is more convenient for our purposes.)</p><details id="instances-for-list-Mathlib.Tactic.Module.NF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.cons"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L57-L60">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.cons" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span></div></div><p>Augment a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R √ó M</code>, by prepending another
pair <code>p : R √ó M</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.NF.cons" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.¬´term_::·µ£_¬ª"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L62-L62">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.¬´term_::·µ£_¬ª" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.¬´term_::·µ£_¬ª"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">¬´term_::·µ£_¬ª</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.TrailingParserDescr</span></div></div><p>Augment a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R √ó M</code>, by prepending another
pair <code>p : R √ó M</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.NF.¬´term_::·µ£_¬ª" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L64-L67">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eval" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Add</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Zero</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span></div></div><p>Evaluate a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R √ó M</code>, to an element of <code>M</code>, by
forming the &quot;linear combination&quot; it specifies: scalar-multiply each <code>R</code> term to the corresponding
<code>M</code> term, then add them all up.</p><details id="instances-for-list-Mathlib.Tactic.Module.NF.eval" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L69-L71">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eval_cons" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span>.1</span> <span class="fn">‚Ä¢</span> <span class="fn"><span class="fn">p</span>.2</span></span> <span class="fn">+</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.atom_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L73-L73">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">atom_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a> <span class="fn"><span class="fn">[</span><span class="fn"><span class="fn">(</span><span class="fn">1</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span><span class="fn">]</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.zero_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L76-L76">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_eq_eval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <span class="fn">=</span> <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a> <span class="fn"><span class="fn">[</span><span class="fn">]</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÅ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L78-L81">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÅ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚ÇÅ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a‚ÇÇ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L83-L90">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÇ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÇ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r‚ÇÅ </span><span class="fn">r‚ÇÇ</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÅ</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÇ</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">r‚ÇÅ</span> <span class="fn">+</span> <span class="fn">r‚ÇÇ</span></span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L92-L99">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval‚ÇÉ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a‚ÇÅ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚ÇÇ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L101-L106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÅ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÇ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÅ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÇ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÇ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÅ</span> : <span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÇ</span> : <span class="fn"><span class="fn">x‚ÇÇ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">+</span> <span class="fn">x‚ÇÇ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÅ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L108-L111">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÅ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÅ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚ÇÅ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a‚ÇÇ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÇ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L113-L120">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÇ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÇ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÇ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r‚ÇÅ </span><span class="fn">r‚ÇÇ</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÅ</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÇ</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">r‚ÇÅ</span> <span class="fn">-</span> <span class="fn">r‚ÇÇ</span></span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÉ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L122-L127">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÉ" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval‚ÇÉ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval‚ÇÉ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a‚ÇÅ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a‚ÇÇ</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a‚ÇÅ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn">(<span class="fn">a‚ÇÇ</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<span class="fn"><span class="fn">(</span><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn"><span class="fn">a‚ÇÇ</span>.1</span><span class="fn">,</span> <span class="fn"><span class="fn">a‚ÇÇ</span>.2</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L129-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÅ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÇ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S‚ÇÅ</span> : <a href="../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S‚ÇÇ</span> : <a href="../.././foundational_types.html">Type</a> u_7}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÅ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÇ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S‚ÇÅ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S‚ÇÅ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S‚ÇÇ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S‚ÇÇ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÇ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ''</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S‚ÇÅ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÇ''</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S‚ÇÇ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÅ</span> : <span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÇ</span> : <span class="fn"><span class="fn">x‚ÇÇ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ'</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ'</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">-</span> <span class="fn">x‚ÇÇ</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.instNeg"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L138-L139">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.instNeg" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instNeg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Neg</span> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Neg</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span>)</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L141-L145">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eval_neg" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L147-L149">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_sub_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <span class="fn">-</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn">(<a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.neg_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L151-L154">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">neg_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÄ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÄ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÄ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">x</span> <span class="fn">=</span> <span class="fn">(<a href="../.././Mathlib/Algebra/Order/AddGroupWithTop.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.instSMulOfMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L156-L157">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[implicit_reducible]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instSMulOfMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Mul</span> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span>)</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.smul_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L159-L160">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.smul_apply" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Mul</span> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">‚Ä¢</span> <span class="fn">l</span></span> <span class="fn">=</span>   <span class="fn"><span class="fn">List.map</span>
    <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">R</span> <span class="fn">√ó</span> <span class="fn">M</span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <span class="fn"><span class="fn">(</span><span class="fn">a</span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span> =&gt; <span class="fn"><span class="fn">(</span><span class="fn"><span class="fn">r</span> <span class="fn">*</span> <span class="fn">a</span></span><span class="fn">,</span> <span class="fn">x</span><span class="fn">)</span></span></span>)</span>
    <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L162-L168">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eval_smul" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">r</span> <span class="fn">‚Ä¢</span> <span class="fn">l</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">r</span> <span class="fn">‚Ä¢</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.smul_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L170-L175">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÄ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÄ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÄ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÄ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÄ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">S</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn"><span class="fn">x</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÄ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÄ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">‚Ä¢</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">s</span> <span class="fn">‚Ä¢</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">‚Ä¢</span> <span class="fn">x</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">(<span class="fn">r</span> <span class="fn">‚Ä¢</span> <span class="fn">l</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_cons_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L177-L180">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r‚ÇÅ </span><span class="fn">r‚ÇÇ</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn"><span class="fn">r‚ÇÅ</span> <span class="fn">=</span> <span class="fn">r‚ÇÇ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÅ</span><span class="fn">,</span> <span class="fn">m</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÅ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r‚ÇÇ</span><span class="fn">,</span> <span class="fn">m</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l‚ÇÇ</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_cons_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L182-L185">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eq_cons_const" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn"><span class="fn">r</span> <span class="fn">=</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r</span><span class="fn">,</span> <span class="fn">m</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_const_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L187-L190">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eq_const_cons" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_const_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn"><span class="fn">0</span> <span class="fn">=</span> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn">n</span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">=</span> <span class="fn">(<span class="fn"><span class="fn">(</span><span class="fn">r</span><span class="fn">,</span> <span class="fn">m</span><span class="fn">)</span></span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::·µ£</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L192-L197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_of_eval_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÅ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÇ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÅ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R‚ÇÇ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÅ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l‚ÇÇ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚ÇÅ </span><span class="fn">x‚ÇÇ</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÅ</span> : <span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx‚ÇÇ</span> : <span class="fn"><span class="fn">x‚ÇÇ</span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÅ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h‚ÇÇ</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x‚ÇÅ</span> <span class="fn">=</span> <span class="fn">x‚ÇÇ</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.algebraMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L201-L205">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.algebraMap" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">algebraMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> <span class="fn">S</span> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span></div></div><p>Operate on a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> S M</code> object <code>l</code>, i.e. a list of pairs in <code>S √ó M</code>, where <code>S</code> is some
commutative semiring, by applying to each <code>S</code>-component the algebra-map from <code>S</code> into a specified
<code>S</code>-algebra <code>R</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.NF.algebraMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_algebraMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L207-L213">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_algebraMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> <span class="fn">S</span> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">SMul</span> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Action/Defs.html#MulAction">MulAction</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a> <span class="fn">S</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap">algebraMap</a> <span class="fn">R</span> <span class="fn">l</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span></div></div></div></div><div class="mod_doc"><h3 id="Lists-of-expressions-representing-scalars-and-vectors-and-operations-on-such-lists" class="markdown-heading">Lists of expressions representing scalars and vectors, and operations on such lists <a class="hover-link" href="#Lists-of-expressions-representing-scalars-and-vectors-and-operations-on-such-lists">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Module.qNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L223-L236">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Basic meta-code &quot;normal form&quot; object of the <code>match_scalars</code> and <code>module</code> tactics: a type synonym
for a list of ordered triples comprising expressions representing terms of two types <code>R</code> and <code>M</code>
(where typically <code>M</code> is an <code>R</code>-module), together with a natural number &quot;index&quot;.</p><p>The natural number represents the index of the <code>M</code> term in the <code>AtomM</code> monad: this is not enforced,
but is sometimes assumed in operations.  Thus when items <code>((a‚ÇÅ, x‚ÇÅ), k)</code> and <code>((a‚ÇÇ, x‚ÇÇ), k)</code>
appear in two different <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code> objects (i.e. with the same <code>‚Ñï</code>-index <code>k</code>), it is expected that
the expressions <code>x‚ÇÅ</code> and <code>x‚ÇÇ</code> are the same.  It is also expected that the items in a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code>
list are in strictly increasing order by natural-number index.</p><p>By forgetting the natural number indices, an expression representing a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Mathlib.Tactic.Module.NF</a></code>
object can be built from a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code> object; this construction is provided as
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">Mathlib.Tactic.Module.qNF.toNF</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.toNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L242-L248">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.toNF" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. a list of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s and a natural
number), build an <code>Expr</code> representing an object of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> R M</code> (i.e. <code>List (R √ó M)</code>) in the
in the obvious way: by forgetting the natural numbers and gluing together the <code>Expr</code>s.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.toNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.onScalar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L250-L255">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.onScalar" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">onScalar</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u‚ÇÅ </span><span class="fn">u‚ÇÇ</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÅ</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÇ</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u‚ÇÇ)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Q(<span class="fn"><span class="fn">¬´$R‚ÇÅ¬ª</span> ‚Üí <span class="fn">¬´$R‚ÇÇ¬ª</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R‚ÇÅ M</code>, i.e. a list of <code>(Q($R‚ÇÅ) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s and a natural
number), apply an expression representing a function with domain <code>R‚ÇÅ</code> to each of the <code>Q($R‚ÇÅ)</code>
components.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.onScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L257-L278">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.add" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R¬ª</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s
and a natural number), construct another such term <code>l</code>, which will have the property that in the
<code>$R</code>-module <code>$M</code>, the sum of the &quot;linear combinations&quot; represented by <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> is the linear
combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> are in strictly increasing order
by <code>‚Ñï</code>-component, and that if pairs <code>(a‚ÇÅ, x‚ÇÅ)</code> and <code>(a‚ÇÇ, x‚ÇÇ)</code> appear in <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> respectively with
the same <code>‚Ñï</code>-component <code>k</code>, then the expressions <code>x‚ÇÅ</code> and <code>x‚ÇÇ</code> are equal.</p><p>The construction is as follows: merge the two lists, except that if pairs <code>(a‚ÇÅ, x‚ÇÅ)</code> and <code>(a‚ÇÇ, x‚ÇÇ)</code>
appear in <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> respectively with the same <code>‚Ñï</code>-component <code>k</code>, then contribute a term
<code>(a‚ÇÅ + a‚ÇÇ, x‚ÇÅ)</code> to the output list with <code>‚Ñï</code>-component <code>k</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.add" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.mkAddProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L280-L299">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.mkAddProof" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkAddProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R¬ª</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">¬´$M¬ª</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">add</a> <span class="fn">iR</span> <span class="fn">l‚ÇÅ</span> <span class="fn">l‚ÇÇ</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">¬´$a_2¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">+</span> <span class="fn"><span class="fn">¬´$a_1¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span></span></div></div><p>Given two terms <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s
and a natural number), recursively construct a proof that in the <code>$R</code>-module <code>$M</code>, the sum of the
&quot;linear combinations&quot; represented by <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> is the linear combination represented by
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">Module.qNF.add</a> iR l‚ÇÅ l‚ÇÅ</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.mkAddProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.sub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L301-L323">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.sub" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">¬´$R¬ª</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> ‚Üí <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s
and a natural number), construct another such term <code>l</code>, which will have the property that in the
<code>$R</code>-module <code>$M</code>, the difference of the &quot;linear combinations&quot; represented by <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> is the
linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> are in strictly increasing order
by <code>‚Ñï</code>-component, and that if pairs <code>(a‚ÇÅ, x‚ÇÅ)</code> and <code>(a‚ÇÇ, x‚ÇÇ)</code> appear in <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> respectively with
the same <code>‚Ñï</code>-component <code>k</code>, then the expressions <code>x‚ÇÅ</code> and <code>x‚ÇÇ</code> are equal.</p><p>The construction is as follows: merge the first list and the negation of the second list, except
that if pairs <code>(a‚ÇÅ, x‚ÇÅ)</code> and <code>(a‚ÇÇ, x‚ÇÇ)</code> appear in <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> respectively with the same
<code>‚Ñï</code>-component <code>k</code>, then contribute a term <code>(a‚ÇÅ - a‚ÇÇ, x‚ÇÅ)</code> to the output list with <code>‚Ñï</code>-component <code>k</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.sub" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.mkSubProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L325-L344">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.mkSubProof" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkSubProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">¬´$R¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">sub</a> <span class="fn">iR</span> <span class="fn">l‚ÇÅ</span> <span class="fn">l‚ÇÇ</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">¬´$a_2¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">-</span> <span class="fn"><span class="fn">¬´$a_1¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span></span></div></div><p>Given two terms <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s
and a natural number), recursively construct a proof that in the <code>$R</code>-module <code>$M</code>, the difference
of the &quot;linear combinations&quot; represented by <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> is the linear combination represented by
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">Module.qNF.sub</a> iR l‚ÇÅ l‚ÇÅ</code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.mkSubProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.matchRings"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L350-L389">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.qNF.matchRings" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">matchRings</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">¬´$M¬ª</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u‚ÇÅ</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÅ</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u‚ÇÅ)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iR‚ÇÅ</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R‚ÇÅ¬ª</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM‚ÇÅ</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R‚ÇÅ¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u‚ÇÇ</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R‚ÇÇ</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u‚ÇÇ)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR‚ÇÇ</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R‚ÇÇ¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iRM‚ÇÇ</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R‚ÇÇ¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l‚ÇÅ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R‚ÇÅ</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R‚ÇÇ</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Q(<span class="fn">¬´$R‚ÇÇ¬ª</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">¬´$M¬ª</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">((<span class="fn">u</span> : <span class="fn">Lean.Level</span>) √ó
    <span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>) √ó
      <span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R¬ª</span></span>)</span>) √ó
        <span class="fn">(<span class="fn">x_1</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>) √ó
          <span class="fn"><span class="fn">((<span class="fn">l‚ÇÅ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) √ó
              <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
              <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l‚ÇÅ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
              <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">¬´$a_1¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span>)</span> <span class="fn">√ó</span>             <span class="fn"><span class="fn">((<span class="fn">l‚ÇÇ'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) √ó
                <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
                <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l‚ÇÇ'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
                <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">¬´$a_1¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span>)</span> <span class="fn">√ó</span>               <span class="fn">(<span class="fn">r'</span> : <span class="fn">Q(<span class="fn">¬´$R¬ª</span>)</span>) √ó <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">¬´$r'¬ª</span> <span class="fn">‚Ä¢</span> <span class="fn">¬´$x¬ª</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$r¬ª</span> <span class="fn">‚Ä¢</span> <span class="fn">¬´$x¬ª</span></span></span>)</span></span></span></span></span></span></span>)</span></span></div></div><p>Given an expression <code>M</code> representing a type which is an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code> and a module over <em>two</em>
semirings <code>R‚ÇÅ</code> and <code>R‚ÇÇ</code>, find the &quot;bigger&quot; of the two semirings.  That is, we assume that it will
turn out to be the case that either (1) <code>R‚ÇÅ</code> is an <code>R‚ÇÇ</code>-algebra and the <code>R‚ÇÇ</code> scalar action on <code>M</code> is
induced from <code>R‚ÇÅ</code>'s scalar action on <code>M</code>, or (2) vice versa; we return the semiring <code>R‚ÇÅ</code> in the
first case and <code>R‚ÇÇ</code> in the second case.</p><p>Moreover, given expressions representing particular scalar multiplications of <code>R‚ÇÅ</code> and/or <code>R‚ÇÇ</code> on
<code>M</code> (a <code>List (R‚ÇÅ √ó M)</code>, a <code>List (R‚ÇÇ √ó M)</code>, a pair <code>(r, x) : R‚ÇÇ √ó M</code>), bump these up to the &quot;big&quot;
ring by applying the algebra-map where needed.</p><details id="instances-for-list-Mathlib.Tactic.Module.qNF.matchRings" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Core-of-the-module-tactic" class="markdown-heading">Core of the <code>module</code> tactic <a class="hover-link" href="#Core-of-the-module-tactic">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Module.parse"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L397-L473">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.parse" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">parse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">¬´$M¬ª</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a>
  <span class="fn">((<span class="fn">u</span> : <span class="fn">Lean.Level</span>) √ó
    <span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>) √ó
      <span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R¬ª</span></span>)</span>) √ó
        <span class="fn">(<span class="fn">x_1</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>) √ó
          <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) √ó
            <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
            <span class="fn">Q(<span class="fn"><span class="fn">¬´$x¬ª</span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span></span></span></span>)</span></span></div></div><p>The main algorithm behind the <code>match_scalars</code> and <code>module</code> tactics: partially-normalizing an
expression in an additive commutative monoid <code>M</code> into the form c1 ‚Ä¢ x1 + c2 ‚Ä¢ x2 + ... c_k ‚Ä¢ x_k,
where x1, x2, ... are distinct atoms in <code>M</code>, and c1, c2, ... are scalars. The scalar type of the
expression is not pre-determined: instead it starts as <code>‚Ñï</code> (when each atom is initially given a
scalar <code>(1:‚Ñï)</code>) and gets bumped up into bigger semirings when such semirings are encountered.</p><p>It is assumed that there is a &quot;linear order&quot; on all the semirings which appear in the expression:
for any two semirings <code>R</code> and <code>S</code> which occur, we have either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>.</p><p>TODO: implement a variant in which a semiring <code>R</code> is provided by the user, and the assumption is
instead that for any semiring <code>S</code> which occurs, we have <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>. The PR <a href="https://github.com/leanprover-community/mathlib4/pull/16984">https://github.com/leanprover-community/mathlib4/pull/16984</a> provides a
proof-of-concept implementation of this variant, but it would need some polishing before joining
Mathlib.</p><p>Possible TODO, if poor performance on large problems is witnessed: switch the implementation from
<code>AtomM</code> to <code>CanonM</code>, per the discussion
<a href="https://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191">https://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191</a></p></div></div><div class="decl" id="Mathlib.Tactic.Module.reduceCoefficientwise"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L475-L515">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.reduceCoefficientwise" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">reduceCoefficientwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <span class="fn">Lean.Level</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚úù</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">¬´$M¬ª</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚úù¬π</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">¬´$R¬ª</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">¬´$R¬ª</span> <span class="fn">¬´$M¬ª</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l‚ÇÅ </span><span class="fn">l‚ÇÇ</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span>
  <span class="fn">(<span class="fn"><span class="fn">List</span> <span class="fn">Lean.MVarId</span></span> <span class="fn">√ó</span>     <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l‚ÇÇ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l‚ÇÅ</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn">¬´$a_1¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <span class="fn">=</span> <span class="fn"><span class="fn">¬´$a¬ª</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></span>)</span></span></span>)</span></span></div></div><p>Given expressions <code>R</code> and <code>M</code> representing types such that <code>M</code>'s is a module over <code>R</code>'s, and
given two terms <code>l‚ÇÅ</code>, <code>l‚ÇÇ</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) √ó Q($M)) √ó ‚Ñï</code>s (two <code>Expr</code>s
and a natural number), construct a list of new goals: that the <code>R</code>-coefficient of an <code>M</code>-atom which
appears in only one list is zero, and that the <code>R</code>-coefficients of an <code>M</code>-atom which appears in both
lists are equal.  Also construct (dependent on these new goals) a proof that the &quot;linear
combinations&quot; represented by <code>l‚ÇÅ</code> and <code>l‚ÇÇ</code> are equal in <code>M</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.Module.matchScalarsAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L517-L560">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.matchScalarsAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalarsAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Lean.MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<span class="fn">List</span> <span class="fn">Lean.MVarId</span>)</span></span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>This is an auxiliary function which produces slightly awkward goals in <code>R</code>; they are later cleaned
up by the function <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess">Mathlib.Tactic.Module.postprocess</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Module.matchScalarsAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.algebraMapThms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L562-L565">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.algebraMapThms" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">algebraMapThms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Array</span> <span class="fn">Lean.Name</span></span></div></div><p>Lemmas used to post-process the result of the <code>match_scalars</code> and <code>module</code> tactics by converting
the <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code> operations which (which proliferate in the constructed scalar goals) to more
familiar forms: <code>‚Ñï</code>, <code>‚Ñ§</code> and <code>‚Ñö</code> casts.</p><details id="instances-for-list-Mathlib.Tactic.Module.algebraMapThms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.postprocess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L567-L583">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.postprocess" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">postprocess</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <span class="fn">Lean.MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.MVarId</span></span></div></div><p>Postprocessing for the scalar goals constructed in the <code>match_scalars</code> and <code>module</code> tactics.
These goals feature a proliferation of <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code> operations (because the scalars start in <code>‚Ñï</code> and
get successively bumped up by <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code>s as new semirings are encountered), so we reinterpret the
most commonly occurring <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code>s (those out of <code>‚Ñï</code>, <code>‚Ñ§</code> and <code>‚Ñö</code>) into their standard forms
(<code>‚Ñï</code>, <code>‚Ñ§</code> and <code>‚Ñö</code> casts) and then try to disperse the casts using the various <code>push_cast</code> lemmas.</p><details id="instances-for-list-Mathlib.Tactic.Module.postprocess" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.matchScalars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L585-L590">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.matchScalars" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalars</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">Lean.MVarId</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">List</span> <span class="fn">Lean.MVarId</span>)</span></span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><details id="instances-for-list-Mathlib.Tactic.Module.matchScalars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.tacticMatch_scalars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L592-L624">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.tacticMatch_scalars" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticMatch_scalars</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>For example, this produces the goal <code>‚ä¢ a * 1 + b * 1 = (b + a) * 1</code>:</p><pre><code>example [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  match_scalars
</code></pre><p>This produces the two goals <code>‚ä¢ a * (a * 1) + b * (b * 1) = 1</code> (from the <code>x</code> atom) and
<code>‚ä¢ a * -(b * 1) + b * (a * 1) = 0</code> (from the <code>y</code> atom):</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ (a ‚Ä¢ x - b ‚Ä¢ y) + (b ‚Ä¢ a ‚Ä¢ y + b ‚Ä¢ b ‚Ä¢ x) = x := by
  match_scalars
</code></pre><p>This produces the goal <code>‚ä¢ -2 * (a * 1) = a * (-2 * 1)</code>:</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :
    -(2:R) ‚Ä¢ a ‚Ä¢ x = a ‚Ä¢ (-2:‚Ñ§) ‚Ä¢ x  := by
  match_scalars
</code></pre><p>The scalar type for the goals produced by the <code>match_scalars</code> tactic is the largest scalar type
encountered; for example, if <code>‚Ñï</code>, <code>‚Ñö</code> and a characteristic-zero field <code>K</code> all occur as scalars, then
the goals produced are equalities in <code>K</code>.  A variant of <code>push_cast</code> is used internally in
<code>match_scalars</code> to interpret scalars from the other types in this largest type.</p><p>If the set of scalar types encountered is not totally ordered (in the sense that for all rings <code>R</code>,
<code>S</code> encountered, it holds that either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>), then the <code>match_scalars</code>
tactic fails.</p><details id="instances-for-list-Mathlib.Tactic.Module.tacticMatch_scalars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.tacticModule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/Module.lean#L626-L656">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_Module.html#Mathlib.Tactic.Module.tacticModule" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">üî∏ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticModule</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some commutative semiring <code>R</code>, and prove
the goal by checking that the LHS- and RHS-coefficients of each atom are the same up to
ring-normalization in <code>R</code>.</p><p>(If the proofs of coefficient-wise equality will require more reasoning than just
ring-normalization, use the tactic <code>match_scalars</code> instead, and then prove coefficient-wise equality
by hand.)</p><p>Example uses of the <code>module</code> tactic:</p><pre><code>example [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  module

example [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :
    (2:K)‚Åª¬π ‚Ä¢ x + (3:K)‚Åª¬π ‚Ä¢ x + (6:K)‚Åª¬π ‚Ä¢ x = x := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :
    (1 + a ^ 2) ‚Ä¢ (v + w) - a ‚Ä¢ (a ‚Ä¢ v - w) = v + (1 + a + a ^ 2) ‚Ä¢ w := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a b Œº ŒΩ : R) (x y : M) :
    (Œº - ŒΩ) ‚Ä¢ a ‚Ä¢ x = (a ‚Ä¢ Œº ‚Ä¢ x + b ‚Ä¢ ŒΩ ‚Ä¢ y) - ŒΩ ‚Ä¢ (a ‚Ä¢ x + b ‚Ä¢ y) := by
  module
</code></pre><details id="instances-for-list-Mathlib.Tactic.Module.tacticModule" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>