<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.TFAE</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.TFAE";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Qq.html">Qq</a></li><li><a href="../.././Mathlib/Tactic/ExtendDoc.html">Mathlib.Tactic.ExtendDoc</a></li><li><a href="../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../.././Mathlib/Data/List/TFAE.html">Mathlib.Data.List.TFAE</a></li><li><a href="../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.TFAE" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.tfaeHave"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeHave</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.tfaeFinish"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeFinish</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.getTFAEList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">getTFAEList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.dfs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">dfs</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.proveImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.proveChain"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveChain</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.proveGetLastDImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveGetLastDImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.proveTFAE"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveTFAE</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.mkTFAEId"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">mkTFAEId</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.elabIndex"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">elabIndex</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.elabTFAEType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">elabTFAEType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.useDeprecated"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">useDeprecated</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TFAE.tfaeHave'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeHave'</span></a></div></nav><main>
<div class="mod_doc"><h1 id="The-Following-Are-Equivalent-TFAE" class="markdown-heading">The Following Are Equivalent (TFAE) <a class="hover-link" href="#The-Following-Are-Equivalent-TFAE">#</a></h1><p>This file provides the tactics <code>tfae_have</code> and <code>tfae_finish</code> for proving goals of the form
<code>TFAE [Pâ‚, Pâ‚‚, ...]</code>.</p></div><div class="mod_doc"><h3 id="Parsing-and-syntax" class="markdown-heading">Parsing and syntax <a class="hover-link" href="#Parsing-and-syntax">#</a></h3><p>We implement <code>tfae_have</code> in terms of a syntactic <code>have</code>. To support as much of the same syntax as
possible, we recreate the parsers for <code>have</code>, except with the changes necessary for <code>tfae_have</code>.</p></div><div class="mod_doc"><p>The following parsers are similar to those for <code>have</code> in <code>Lean.Parser.Term</code>, but
instead of <code>optType</code>, we use <code>tfaeType := num &gt;&gt; impArrow &gt;&gt; num</code> (as a <code>tfae_have</code> invocation must
always include this specification). Also, we disallow including extra binders, as that makes no
sense in this context; we also include <code>&quot; : &quot;</code> after the binder to avoid breaking <code>tfae_have 1 â†’ 2</code>
syntax (which, unlike <code>have</code>, omits <code>&quot; : &quot;</code>).</p></div><div class="decl" id="Mathlib.Tactic.TFAE.tfaeHave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L83-L142">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.tfaeHave" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeHave</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>tfae_have i â†’ j := t</code>, where the goal is <code>TFAE [Pâ‚, Pâ‚‚, ...]</code> introduces a hypothesis
<code>tfae_i_to_j : Páµ¢ â†’ Pâ±¼</code> and proof <code>t</code> to the local context. Note that <code>i</code> and <code>j</code> are
natural number literals (beginning at 1) used as indices to specify the propositions
<code>Pâ‚, Pâ‚‚, ...</code> that appear in the goal.</p><p>Once sufficient hypotheses have been introduced by <code>tfae_have</code>, <code>tfae_finish</code> can be used to close
the goal.</p><p>All features of <code>have</code> are supported by <code>tfae_have</code>, including naming, matching,
destructuring, and goal creation.</p><ul><li><code>tfae_have i â† j := t</code> adds a hypothesis in the reverse direction, of type <code>Pâ±¼ â†’ Páµ¢</code>.</li><li><code>tfae_have i â†” j := t</code> adds a hypothesis in the both directions, of type <code>Páµ¢ â†” Pâ±¼</code>.</li><li><code>tfae_have hij : i â†’ j := t</code> names the introduced hypothesis <code>hij</code> instead of <code>tfae_i_to_j</code>.</li><li><code>tfae_have i j | pâ‚ =&gt; tâ‚ | ...</code> matches on the assumption <code>p : Páµ¢</code>.</li><li><code>tfae_have âŸ¨hij, hjiâŸ© : i â†” j := t</code> destructures the bi-implication into <code>hij : Páµ¢ â†’ Pâ±¼</code>
and <code>hji : Pâ±¼ â†’ Pâ±¼</code>.</li><li><code>tfae_have i â†’ j := t ?a</code> creates a new goal for <code>?a</code>.</li></ul><p>Examples:</p><pre><code class="language-lean4">example (h : P â†’ R) : TFAE [P, Q, R] := by
  tfae_have 1 â†’ 3 := h
  -- The resulting context now includes `tfae_1_to_3 : P â†’ R`.
  sorry
</code></pre><pre><code class="language-lean4">-- An example of `tfae_have` and `tfae_finish`:
example : TFAE [P, Q, R] := by
  tfae_have 1 â†’ 2 := sorry /- proof of P â†’ Q -/
  tfae_have 2 â†’ 1 := sorry /- proof of Q â†’ P -/
  tfae_have 2 â†” 3 := sorry /- proof of Q â†” R -/
  tfae_finish
</code></pre><pre><code class="language-lean4">-- All features of `have` are supported by `tfae_have`:
example : TFAE [P, Q] := by
  -- assert `tfae_1_to_2 : P â†’ Q`:
  tfae_have 1 â†’ 2 := sorry

  -- assert `hpq : P â†’ Q`:
  tfae_have hpq : 1 â†’ 2 := sorry

  -- match on `p : P` and prove `Q` via `f p`:
  tfae_have 1 â†’ 2
  | p =&gt; f p

  -- assert `pq : P â†’ Q`, `qp : Q â†’ P`:
  tfae_have âŸ¨pq, qpâŸ© : 1 â†” 2 := sorry

  -- assert `h : P â†’ Q`; `?a` is a new goal:
  tfae_have h : 1 â†’ 2 := f ?a

  sorry
</code></pre><details id="instances-for-list-Mathlib.Tactic.TFAE.tfaeHave" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TFAE.tfaeFinish"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L144-L159">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeFinish</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>tfae_finish</code> closes goals of the form <code>TFAE [Pâ‚, Pâ‚‚, ...]</code> once a sufficient collection
of hypotheses of the form <code>Páµ¢ â†’ Pâ±¼</code> or <code>Páµ¢ â†” Pâ±¼</code> have been introduced to the local context.</p><p><code>tfae_have</code> can be used to conveniently introduce these hypotheses; see <code>tfae_have</code>.</p><p>Example:</p><pre><code class="language-lean4">example : TFAE [P, Q, R] := by
  tfae_have 1 â†’ 2 := sorry /- proof of P â†’ Q -/
  tfae_have 2 â†’ 1 := sorry /- proof of Q â†’ P -/
  tfae_have 2 â†” 3 := sorry /- proof of Q â†” R -/
  tfae_finish
</code></pre><details id="instances-for-list-Mathlib.Tactic.TFAE.tfaeFinish" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Setup" class="markdown-heading">Setup <a class="hover-link" href="#Setup">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TFAE.getTFAEList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L166-L180">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.getTFAEList" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">getTFAEList</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Q(<span class="fn"><span class="fn">List</span> <a href="../.././foundational_types.html">Prop</a></span>)</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">List</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span></div></div><p>Extract a list of <code>Prop</code> expressions from an expression of the form <code>TFAE [Pâ‚, Pâ‚‚, ...]</code> as
long as <code>[Pâ‚, Pâ‚‚, ...]</code> is an explicit list.</p><details id="instances-for-list-Mathlib.Tactic.TFAE.getTFAEList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Proof-construction" class="markdown-heading">Proof construction <a class="hover-link" href="#Proof-construction">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TFAE.dfs"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L186-L197">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.dfs" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.dfs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">dfs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">atoms</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i </span><span class="fn">j</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">P'</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn">Q(<span class="fn">Â«$PÂ»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">StateT</span> <span class="fn">(<span class="fn">Std.HashSet</span> <span class="fn">â„•</span>)</span> <span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn">Â«$P'Â»</span>)</span></span></div></div><p>Uses depth-first search to find a path from <code>P</code> to <code>P'</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.TFAE.proveImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L199-L205">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.proveImpl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveImpl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">atoms</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i </span><span class="fn">j</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">P'</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn"><span class="fn">Â«$PÂ»</span> â†’ <span class="fn">Â«$P'Â»</span></span>)</span></span></div></div><p>Prove an implication via depth-first traversal.</p><details id="instances-for-list-Mathlib.Tactic.TFAE.proveImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TFAE.proveChain"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L207-L218">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.proveChain" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveChain"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveChain</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">atoms</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">is</span> : <span class="fn"><span class="fn">List</span> <span class="fn">â„•</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">Q(<span class="fn"><span class="fn">List</span> <a href="../.././foundational_types.html">Prop</a></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn"><span class="fn">List.IsChain</span> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn"><span class="fn">x1</span> â†’ <span class="fn">x2</span></span>)</span> <span class="fn">(<span class="fn">Â«$PÂ»</span> <span class="fn">::</span> <span class="fn">Â«$lÂ»</span>)</span></span>)</span></span></div></div><p>Generate a proof of <code>Chain (Â· â†’ Â·) P l</code>. We assume <code>P : Prop</code> and <code>l : List Prop</code>, and that <code>l</code>
is an explicit list.</p></div></div><div class="decl" id="Mathlib.Tactic.TFAE.proveGetLastDImpl"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L220-L228">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.proveGetLastDImpl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveGetLastDImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveGetLastDImpl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">atoms</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i </span><span class="fn">i'</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">is</span> : <span class="fn"><span class="fn">List</span> <span class="fn">â„•</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">P'</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">Q(<span class="fn"><span class="fn">List</span> <a href="../.././foundational_types.html">Prop</a></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">Â«$lÂ»</span>.<span class="fn">getLastD</span></span> <span class="fn">Â«$P'Â»</span></span> â†’ <span class="fn">Â«$PÂ»</span></span>)</span></span></div></div><p>Attempt to prove <code>getLastD l P' â†’ P</code> given an explicit list <code>l</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.TFAE.proveTFAE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L230-L240">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.proveTFAE" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveTFAE"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">proveTFAE</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">(<span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">â„•</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">atoms</span> : <span class="fn"><span class="fn">Array</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">is</span> : <span class="fn"><span class="fn">List</span> <span class="fn">â„•</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn">Q(<span class="fn"><span class="fn">List</span> <a href="../.././foundational_types.html">Prop</a></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Q(<span class="fn"><span class="fn">Â«$lÂ»</span>.<a href="../.././Mathlib/Data/List/TFAE.html#List.TFAE">TFAE</a></span>)</span></span></div></div><p>Attempt to prove a statement of the form <code>TFAE [Pâ‚, Pâ‚‚, ...]</code>.</p><details id="instances-for-list-Mathlib.Tactic.TFAE.proveTFAE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="tfae-have-components" class="markdown-heading"><code>tfae_have</code> components <a class="hover-link" href="#tfae-have-components">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TFAE.mkTFAEId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L244-L253">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.mkTFAEId" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkTFAEId"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">mkTFAEId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Lean.TSyntax</span> <span class="fn">`_private.Mathlib.Tactic.TFAE.0.Mathlib.Tactic.TFAE.Parser.tfaeType</span></span> â†’ <span class="fn"><span class="fn">Lean.MacroM</span> <span class="fn">Lean.Name</span></span></span></div></div><p>Construct a name for a hypothesis introduced by <code>tfae_have</code>.</p><details id="instances-for-list-Mathlib.Tactic.TFAE.mkTFAEId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TFAE.elabIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L255-L261">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.elabIndex" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.elabIndex"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">elabIndex</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">Lean.TSyntax</span> <span class="fn">`num</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">maxIndex</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">â„•</span></span></div></div><p>Turn syntax for a given index into a natural number, as long as it lies between <code>1</code> and
<code>maxIndex</code>.</p><details id="instances-for-list-Mathlib.Tactic.TFAE.elabIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Tactic-implementation" class="markdown-heading">Tactic implementation <a class="hover-link" href="#Tactic-implementation">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TFAE.elabTFAEType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L265-L284">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.elabTFAEType" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.elabTFAEType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">elabTFAEType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">tfaeList</span> : <span class="fn"><span class="fn">List</span> <span class="fn">Q(<a href="../.././foundational_types.html">Prop</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">Lean.TSyntax</span> <span class="fn">`_private.Mathlib.Tactic.TFAE.0.Mathlib.Tactic.TFAE.Parser.tfaeType</span></span> â†’ <span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Expr</span></span></span></div></div><p>Accesses the propositions at indices <code>i</code> and <code>j</code> of <code>tfaeList</code>, and constructs the expression
<code>Pi &lt;arr&gt; Pj</code>, which will be the type of our <code>tfae_have</code> hypothesis</p><details id="instances-for-list-Mathlib.Tactic.TFAE.elabTFAEType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Deprecated-Goal-style-tfae-have" class="markdown-heading">Deprecated &quot;Goal-style&quot; <code>tfae_have</code> <a class="hover-link" href="#Deprecated-Goal-style-tfae-have">#</a></h3><p>This syntax and its implementation, which behaves like &quot;Mathlib <code>have</code>&quot; is deprecated; we preserve
it here to provide graceful deprecation behavior.</p></div><div class="decl" id="Mathlib.Tactic.TFAE.useDeprecated"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L347-L351">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.useDeprecated" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.useDeprecated"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">useDeprecated</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Option</span> <span class="fn">Bool</span></span></div></div><p>Re-enables &quot;goal-style&quot; syntax for <code>tfae_have</code> when <code>true</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.TFAE.tfaeHave'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TFAE.lean#L357-L358">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TFAE.html#Mathlib.Tactic.TFAE.tfaeHave'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ğŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TFAE</span>.<span class="name">tfaeHave'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>tfae_have i â†’ j := t</code>, where the goal is <code>TFAE [Pâ‚, Pâ‚‚, ...]</code> introduces a hypothesis
<code>tfae_i_to_j : Páµ¢ â†’ Pâ±¼</code> and proof <code>t</code> to the local context. Note that <code>i</code> and <code>j</code> are
natural number literals (beginning at 1) used as indices to specify the propositions
<code>Pâ‚, Pâ‚‚, ...</code> that appear in the goal.</p><p>Once sufficient hypotheses have been introduced by <code>tfae_have</code>, <code>tfae_finish</code> can be used to close
the goal.</p><p>All features of <code>have</code> are supported by <code>tfae_have</code>, including naming, matching,
destructuring, and goal creation.</p><ul><li><code>tfae_have i â† j := t</code> adds a hypothesis in the reverse direction, of type <code>Pâ±¼ â†’ Páµ¢</code>.</li><li><code>tfae_have i â†” j := t</code> adds a hypothesis in the both directions, of type <code>Páµ¢ â†” Pâ±¼</code>.</li><li><code>tfae_have hij : i â†’ j := t</code> names the introduced hypothesis <code>hij</code> instead of <code>tfae_i_to_j</code>.</li><li><code>tfae_have i j | pâ‚ =&gt; tâ‚ | ...</code> matches on the assumption <code>p : Páµ¢</code>.</li><li><code>tfae_have âŸ¨hij, hjiâŸ© : i â†” j := t</code> destructures the bi-implication into <code>hij : Páµ¢ â†’ Pâ±¼</code>
and <code>hji : Pâ±¼ â†’ Pâ±¼</code>.</li><li><code>tfae_have i â†’ j := t ?a</code> creates a new goal for <code>?a</code>.</li></ul><p>Examples:</p><pre><code class="language-lean4">example (h : P â†’ R) : TFAE [P, Q, R] := by
  tfae_have 1 â†’ 3 := h
  -- The resulting context now includes `tfae_1_to_3 : P â†’ R`.
  sorry
</code></pre><pre><code class="language-lean4">-- An example of `tfae_have` and `tfae_finish`:
example : TFAE [P, Q, R] := by
  tfae_have 1 â†’ 2 := sorry /- proof of P â†’ Q -/
  tfae_have 2 â†’ 1 := sorry /- proof of Q â†’ P -/
  tfae_have 2 â†” 3 := sorry /- proof of Q â†” R -/
  tfae_finish
</code></pre><pre><code class="language-lean4">-- All features of `have` are supported by `tfae_have`:
example : TFAE [P, Q] := by
  -- assert `tfae_1_to_2 : P â†’ Q`:
  tfae_have 1 â†’ 2 := sorry

  -- assert `hpq : P â†’ Q`:
  tfae_have hpq : 1 â†’ 2 := sorry

  -- match on `p : P` and prove `Q` via `f p`:
  tfae_have 1 â†’ 2
  | p =&gt; f p

  -- assert `pq : P â†’ Q`, `qp : Q â†’ P`:
  tfae_have âŸ¨pq, qpâŸ© : 1 â†” 2 := sorry

  -- assert `h : P â†’ Q`; `?a` is a new goal:
  tfae_have h : 1 â†’ 2 := f ?a

  sorry
</code></pre><details id="instances-for-list-Mathlib.Tactic.TFAE.tfaeHave'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>