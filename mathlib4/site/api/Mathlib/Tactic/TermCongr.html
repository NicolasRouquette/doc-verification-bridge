<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.TermCongr</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.TermCongr";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Logic/Basic.html">Mathlib.Logic.Basic</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../.././Mathlib/Lean/Expr/Basic.html">Mathlib.Lean.Expr.Basic</a></li><li><a href="../.././Mathlib/Lean/Meta/CongrTheorems.html">Mathlib.Lean.Meta.CongrTheorems</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.TermCongr" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.termCongr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">termCongr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.cHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHole</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.unexpandCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">unexpandCHole</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCHole</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.cHole?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHole?</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.hasCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">hasCHole</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.removeCHoles"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">removeCHoles</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.elabCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabCHole</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.cHoleExpand"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHoleExpand</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.elabCHoleExpand"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabCHoleExpand</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.processAntiquot"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">processAntiquot</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.elaboratePattern"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elaboratePattern</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkEqForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkEqForExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkHEqForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkHEqForExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkIffForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkIffForExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.ensureIff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">ensureIff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.isRfl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">isRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.heq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">heq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.iff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.trans"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.mk'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.defeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">defeq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.mkDefault"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mkDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mkDefault'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.throwCongrEx"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">throwCongrEx</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkCongrOfCHole?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfCHole?</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkCongrOfAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfAux</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkCongrOfApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfApp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.mkCongrOf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.TermCongr.elabTermCongr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabTermCongr</span></a></div></nav><main>
<div class="mod_doc"><h1 id="congr-congruence-quotations" class="markdown-heading"><code>congr(...)</code> congruence quotations <a class="hover-link" href="#congr-congruence-quotations">#</a></h1><p>This module defines a term elaborator for generating congruence lemmas
from patterns written using quotation syntax.
One can write <code>congr($hf $hx)</code> with <code>hf : f = f'</code> and <code>hx : x = x'</code> to get <code>f x = f' x'</code>.
While in simple cases it might be possible to use <code>congr_arg</code> or <code>congr_fun</code>,
congruence quotations are more general,
since for example <code>f</code> could have implicit arguments, complicated dependent types,
and subsingleton instance arguments such as <code>Decidable</code> or <code><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a></code>.</p><p>The implementation strategy is the following:</p><ol><li>The pattern is elaborated twice, once with each hole replaced by the LHS
and again with each hole replaced by the RHS. We do not force the hole to
have any particular type while elaborating, but if the hole has a type
with an obvious LHS or RHS, then we propagate this information outward.
We use <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole">Mathlib.Tactic.TermCongr.cHole</a></code> with metadata for these replacements
to hold onto the hole itself.</li><li>Once the pattern has been elaborated twice,
we unify them against the respective LHS and RHS of the target type
if the target has a type with an obvious LHS and RHS.
This can fill in some metavariables and help typeclass inference make progress.</li><li>Then we simultaneously walk along the elaborated LHS and RHS expressions
to generate a congruence.
When we reach <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole">cHole</a></code>s, we make sure they elaborated in a compatible way.
Each <code>Expr</code> type has some logic to come up with a suitable congruence.
For applications we use a version of <code>Lean.Meta.mkHCongrWithArity</code> that tries
to fill in some of the equality proofs using subsingleton lemmas.</li></ol><p>The point of elaborating the expression twice is that we let the elaborator handle
activities like synthesizing instances, etc., specialized to LHS or RHS, without trying
to derive one side from the other.</p><p>During development there was a version using <code>simp</code> transformations, but there was
no way to inform <code>simp</code> about the expected RHS, which could cause <code>simp</code> to fail because
it eagerly wants to solve for instance arguments. The current version is able to use the
expected LHS and RHS to fill in arguments before solving for instance arguments.</p></div><div class="decl" id="Mathlib.Tactic.TermCongr.termCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L61-L83">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.termCongr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.termCongr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">termCongr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p><code>congr(expr)</code> generates a congruence from an expression containing
congruence holes of the form <code>$h</code> or <code>$(h)</code>.
In these congruence holes, <code>h : a = b</code> indicates that, in the generated congruence,
on the left-hand side <code>a</code> is substituted for <code>$h</code>
and on the right-hand side <code>b</code> is substituted for <code>$h</code>.</p><p>For example, if <code>h : a = b</code> then <code>congr(1 + $h) : 1 + a = 1 + b</code>.</p><p>This is able to make use of the expected type, for example <code>(congr(_ + $h) : 1 + _ = _)</code>
with <code>h : x = y</code> gives <code>1 + x = 1 + y</code>.
The expected type can be an <code>Iff</code>, <code>Eq</code>, or <code>HEq</code>.
If there is no expected type, then it generates an equality.</p><p>Note: the process of generating a congruence lemma involves elaborating the pattern
using terms with attached metadata and a reducible wrapper.
We try to avoid doing so, but these terms can leak into the local context through unification.
This can potentially break tactics that are sensitive to metadata or reducible functions.
Please report anything that goes wrong with <code>congr(...)</code> lemmas on Zulip.</p><p>For debugging, you can set <code>set_option trace.Elab.congr true</code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.termCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Congruence-holes" class="markdown-heading">Congruence holes <a class="hover-link" href="#Congruence-holes">#</a></h3><p>This section sets up the way congruence holes are elaborated for <code>congr(...)</code> quotations.
The basic problem is that if we have <code>$h</code> with <code>h : x = y</code>, we need to elaborate it once
as <code>x</code> and once as <code>y</code>, and in both cases the term needs to remember that it's associated
to <code>h</code>.</p></div><div class="decl" id="Mathlib.Tactic.TermCongr.cHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L102-L113">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.cHole" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHole</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">val</span> : <span class="fn">Î±</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">_pf</span> : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Î±</span></div></div><p>For holding onto the hole's value along with the value of either the LHS or RHS of the hole.
These occur wrapped in metadata so that they always appear as function application
with exactly four arguments.</p><p>Note that there is no relation between <code>val</code> and the proof.
We need to decouple these to support letting the proof's elaboration be deferred until
we know whether we want an iff, eq, or heq, while also allowing it to choose
to elaborate as an iff, eq, or heq.
Later, the congruence generator handles any discrepancies.
See <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code> below.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.cHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.unexpandCHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L115-L119">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.unexpandCHole" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.unexpandCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">unexpandCHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.PrettyPrinter.Unexpander</span></div></div><p>For error reporting purposes, make the hole pretty print as its value.
We can still see that it is a hole in the info view on mouseover.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.unexpandCHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkCHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L121-L131">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkCHole" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCHole</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">forLhs</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">val </span><span class="fn">pf</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Create the congruence hole. Used by <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHole">elabCHole</a></code>.</p><p>Saves the current mvarCounter as a proxy for age. We use this to avoid
reprocessing old congruence holes that happened to leak into the local context.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkCHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.cHole?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L133-L144">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.cHole?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHole?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mvarCounterSaved?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">â„•</span></span> := <span class="fn">none</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Option</span> <span class="fn">(<span class="fn">Bool</span> <span class="fn">Ã—</span> <span class="fn"><span class="fn">Lean.Expr</span> <span class="fn">Ã—</span> <span class="fn">Lean.Expr</span></span>)</span></span></div></div><p>If the expression is a congruence hole, returns <code>(forLhs, sideVal, pf)</code>.
If <code>mvarCounterSaved?</code> is not none, then only returns the hole if it is at least as recent.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.cHole?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.hasCHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L146-L148">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.hasCHole" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.hasCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">hasCHole</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span></div></div><p>Returns any subexpression that is a recent congruence hole.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.hasCHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.removeCHoles"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L150-L152">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.removeCHoles" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.removeCHoles"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">removeCHoles</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Expr</span></div></div><p>Eliminate all congruence holes from an expression by replacing them with their values.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.removeCHoles" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.elabCHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L154-L171">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.elabCHole" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHole"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabCHole</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Lean.Syntax</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">forLhs</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">expectedType?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Elaborates a congruence hole and returns either the left-hand side or the right-hand side,
annotated with information necessary to generate a congruence lemma.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.elabCHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.cHoleExpand"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L173-L176">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.cHoleExpand" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHoleExpand"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">cHoleExpand</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.ParserDescr</span></div></div><p>(Internal for <code>congr(...)</code>)
Elaborates to an expression satisfying <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole?">cHole?</a></code> that equals the LHS or RHS of <code>h</code>,
if the LHS or RHS is available after elaborating <code>h</code>. Uses the expected type as a hint.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.cHoleExpand" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.elabCHoleExpand"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L178-L183">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.elabCHoleExpand" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabCHoleExpand"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabCHoleExpand</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Term.TermElab</span></div></div><p>(Internal for <code>congr(...)</code>)
Elaborates to an expression satisfying <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.cHole?">cHole?</a></code> that equals the LHS or RHS of <code>h</code>,
if the LHS or RHS is available after elaborating <code>h</code>. Uses the expected type as a hint.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.elabCHoleExpand" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.processAntiquot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L185-L196">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.processAntiquot" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.processAntiquot"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">processAntiquot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn">Lean.Term</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">expand</span> : <span class="fn"><span class="fn">Lean.Term</span> â†’ <span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Term</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Term</span></span></div></div><p>Replace all <code>term</code> antiquotations in a term using the given <code>expand</code> function.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.processAntiquot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.elaboratePattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L198-L205">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.elaboratePattern" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elaboratePattern"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elaboratePattern</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn">Lean.Term</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">expectedType?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">forLhs</span> : <span class="fn">Bool</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.Elab.TermElabM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Given the pattern <code>t</code> in <code>congr(t)</code>, elaborate it for the given side
by replacing antiquotations with <code>cHole%</code> terms, and ensure the elaborated term
is of the expected type.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.elaboratePattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Congruence-generation" class="markdown-heading">Congruence generation <a class="hover-link" href="#Congruence-generation">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkEqForExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L209-L218">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkEqForExpectedType" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkEqForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkEqForExpectedType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">expectedType?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Ensures the expected type is an equality. Returns the equality.
The returned expression satisfies <code>Lean.Expr.eq?</code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkEqForExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkHEqForExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L220-L230">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkHEqForExpectedType" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkHEqForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkHEqForExpectedType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">expectedType?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Ensures the expected type is a HEq. Returns the HEq.
This expression satisfies <code>Lean.Expr.heq?</code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkHEqForExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkIffForExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L232-L241">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkIffForExpectedType" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkIffForExpectedType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkIffForExpectedType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">expectedType?</span> : <span class="fn"><span class="fn">Option</span> <span class="fn">Lean.Expr</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Ensures the expected type is an iff. Returns the iff.
This expression satisfies <code>Lean.Expr.iff?</code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkIffForExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.ensureIff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L243-L246">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.ensureIff" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.ensureIff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">ensureIff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pf</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Make sure that the expected type of <code>pf</code> is an iff by unification.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.ensureIff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrType"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L248-L250">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrType" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A request for a type of congruence lemma from a <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.TermCongr.CongrType.eq">eq : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType">CongrType</a></li><li class="constructor" id="Mathlib.Tactic.TermCongr.CongrType.heq">heq : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType">CongrType</a></li></ul><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L252-L278">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult" class="verification-badge comp-datatype" title="Computational datatype">ðŸ”¶ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A congruence lemma between two expressions. The proof is generated dynamically, depending on
whether the resulting lemma should be an <code>Eq</code> or a <code>HEq</code>.
If generating a proof impossible, then the generator can throw an error.
This can be due to either an <code>Eq</code> proof being impossible
or due to the lhs/rhs not being defeq to the lhs/rhs of the generated proof,
which can happen for user-supplied congruence holes.</p><p>This complexity is to support two features:</p><ol><li>The user is free to supply Iff, Eq, and HEq lemmas in congruence holes,
and we're able to transform them into whatever is appropriate for a
given congruence lemma.</li><li>If the congruence hole is a metavariable, then we can specialize that
hole to an Iff, Eq, or HEq depending on what's necessary at that site.</li></ol><ul class="structure_fields" id="Mathlib.Tactic.TermCongr.CongrResult.mk"><li id="Mathlib.Tactic.TermCongr.CongrResult.lhs" class="structure_field"><div class="structure_field_info">lhs : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The left-hand side of the congruence result.</p></div></li><li id="Mathlib.Tactic.TermCongr.CongrResult.rhs" class="structure_field"><div class="structure_field_info">rhs : <span class="fn">Lean.Expr</span></div><div class="structure_field_doc"><p>The right-hand side of the congruence result.</p></div></li><li id="Mathlib.Tactic.TermCongr.CongrResult.pf?" class="structure_field"><div class="structure_field_info">pf? : <span class="fn"><span class="fn">Option</span> <span class="fn">(<a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrType">CongrType</a> â†’ <span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span>)</span></span></div><div class="structure_field_doc"><p>A generator for an <code>Eq <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> or <code>HEq <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> proof.
If such a proof is impossible, the generator can throw an error.
The inferred type of the generated proof needs only be defeq to <code>Eq <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> or <code>HEq <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>.
This function can assign metavariables when constructing the proof.</p><p>If <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?">pf?</a> = none</code>, then <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> are defeq, and the proof is by reflexivity.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.isRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L280-L282">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.isRfl" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.isRfl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">isRfl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Bool</span></div></div><p>Returns whether the proof is by reflexivity.
Such congruence proofs are trivial.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.isRfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L284-L293">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.eq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">eq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Returns the proof that <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> = <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>. Fails if the <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code> is inapplicable.
Throws an error if the <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> have non-defeq types.
If <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?">pf?</a> = none</code>, this returns the <code>rfl</code> proof.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.heq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L295-L300">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.heq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.heq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">heq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Returns the proof that <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> â‰ <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>. Fails if the <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code> is inapplicable.
If <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?">pf?</a> = none</code>, this returns the <code>rfl</code> proof.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.heq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.iff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L302-L306">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.iff" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.iff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Lean.Expr</span></span></div></div><p>Returns a proof of <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a> â†” <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>. Uses <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.eq">CongrResult.eq</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.iff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.trans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L308-L322">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.trans" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.trans"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">trans</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res1 </span><span class="fn">res2</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></div></div><p>Combine two congruence proofs using transitivity.
Does not check that <code>res1.<a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> is defeq to <code>res2.<a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code>.
If both <code>res1</code> and <code>res2</code> are trivial then the result is trivial.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.trans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L324-L385">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mk'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mk'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">pf</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></div></div><p>Make a <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code> from an LHS, an RHS, and a proof of an Iff, Eq, or HEq.
The proof is allowed to have a metavariable for its type.
Validates the inputs and throws errors in the <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?">pf?</a></code> function.</p><p>The <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.pf?">pf?</a></code> function is responsible for finally unifying the type of <code>pf</code> with <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.mk'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.defeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L387-L398">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.defeq" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.defeq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">defeq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">res</span> : <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Force the lhs and rhs to be defeq. For when <code>dsimp</code>-like congruence is necessary.
Clears the proof.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.defeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.mkDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L400-L416">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mkDefault</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Tries to make a congruence between <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> automatically.</p><ol><li>If they are defeq, returns a trivial congruence.</li><li>Tries using <code>Subsingleton.elim</code>.</li><li>Tries <code>proof_irrel_heq</code> as another effort to avoid doing congruence on proofs.</li><li>Otherwise throws an error.</li></ol><p>Note: <code>mkAppM</code> uses <code>withNewMCtxDepth</code>, which prevents typeclass inference
from accidentally specializing <code>Sort _</code> to <code>Prop</code>, which could otherwise happen
because there is a <code>Subsingleton Prop</code> instance.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.mkDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.CongrResult.mkDefault'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L418-L424">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">CongrResult</span>.<span class="name">mkDefault'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Does <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault">CongrResult.mkDefault</a></code> but makes sure there are no lingering congruence holes.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.CongrResult.mkDefault'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.throwCongrEx"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L426-L429">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.throwCongrEx" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.throwCongrEx"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">throwCongrEx</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <span class="fn">Lean.MessageData</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">Î±</span></span></div></div><p>Throw an internal error.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.throwCongrEx" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkCongrOfCHole?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L431-L457">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfCHole?" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfCHole?"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfCHole?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <span class="fn">(<span class="fn">Option</span> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a>)</span></span></div></div><p>If <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> or <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> is a congruence hole, then process it.
Only process ones that are at least as new as <code>mvarCounterSaved</code>
since nothing prevents congruence holes from leaking into the local context.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkCongrOfCHole?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L471-L472">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.M" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">Î±</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Monad for <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfAux">mkCongrOfAux</a></code>, for caching <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></code>s.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkCongrOfAux"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L476-L567">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfAux" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">depth </span><span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.M">M</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Implementation of <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOf">mkCongrOf</a></code>, with caching.</p></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkCongrOfApp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L569-L687">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfApp" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOfApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOfApp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">depth </span><span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.M">M</a> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Generate congruence for applications <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code>.
Key detail: functions might be <em>overapplied</em> due to the values of their arguments.
For example, <code>id id 2</code> is overapplied.
To handle these, we need to segment the applications into their natural arities,
since <code>mkHCongrWithArity'</code> does not know how to generate congruence lemmas for the overapplied case.</p></div></div><div class="decl" id="Mathlib.Tactic.TermCongr.mkCongrOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L691-L700">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOf" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.mkCongrOf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">mkCongrOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">depth </span><span class="fn">mvarCounterSaved</span> : <span class="fn">â„•</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <span class="fn">Lean.Expr</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Lean.MetaM</span> <a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult">CongrResult</a></span></div></div><p>Walks along both <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.lhs">lhs</a></code> and <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.rhs">rhs</a></code> simultaneously to create a congruence lemma between them.</p><p>Where they are desynchronized, we fall back to the base case (using <code><a href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.CongrResult.mkDefault'">CongrResult.mkDefault'</a></code>)
since it's likely due to unification with the expected type,
from <code>_</code> placeholders or implicit arguments being filled in.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.mkCongrOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 id="Elaborating-congruence-quotations" class="markdown-heading">Elaborating congruence quotations <a class="hover-link" href="#Elaborating-congruence-quotations">#</a></h3></div><div class="decl" id="Mathlib.Tactic.TermCongr.elabTermCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Tactic/TermCongr.lean#L704-L738">source</a></div><div class="verification_link">
<a href="../../../modules/Mathlib_Tactic_TermCongr.html#Mathlib.Tactic.TermCongr.elabTermCongr" class="verification-badge comp-operation" title="Computational operation (Bool/decidable)">ðŸ”¸ coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/TermCongr.html#Mathlib.Tactic.TermCongr.elabTermCongr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">TermCongr</span>.<span class="name">elabTermCongr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Lean.Elab.Term.TermElab</span></div></div><p><code>congr(expr)</code> generates a congruence from an expression containing
congruence holes of the form <code>$h</code> or <code>$(h)</code>.
In these congruence holes, <code>h : a = b</code> indicates that, in the generated congruence,
on the left-hand side <code>a</code> is substituted for <code>$h</code>
and on the right-hand side <code>b</code> is substituted for <code>$h</code>.</p><p>For example, if <code>h : a = b</code> then <code>congr(1 + $h) : 1 + a = 1 + b</code>.</p><p>This is able to make use of the expected type, for example <code>(congr(_ + $h) : 1 + _ = _)</code>
with <code>h : x = y</code> gives <code>1 + x = 1 + y</code>.
The expected type can be an <code>Iff</code>, <code>Eq</code>, or <code>HEq</code>.
If there is no expected type, then it generates an equality.</p><p>Note: the process of generating a congruence lemma involves elaborating the pattern
using terms with attached metadata and a reducible wrapper.
We try to avoid doing so, but these terms can leak into the local context through unification.
This can potentially break tactics that are sensitive to metadata or reducible functions.
Please report anything that goes wrong with <code>congr(...)</code> lemmas on Zulip.</p><p>For debugging, you can set <code>set_option trace.Elab.congr true</code>.</p><details id="instances-for-list-Mathlib.Tactic.TermCongr.elabTermCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>