<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.Category.LightProfinite.Injective</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.Category.LightProfinite.Injective";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">Category</span>.<span class="name">LightProfinite</span>.<span class="name">Injective</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/CategoryTheory/EpiMono.html">Mathlib.CategoryTheory.EpiMono</a></li><li><a href="../../../.././Mathlib/Order/RelClasses.html">Mathlib.Order.RelClasses</a></li><li><a href="../../../.././Mathlib/CategoryTheory/Functor/OfSequence.html">Mathlib.CategoryTheory.Functor.OfSequence</a></li><li><a href="../../../.././Mathlib/CategoryTheory/Preadditive/Injective/Basic.html">Mathlib.CategoryTheory.Preadditive.Injective.Basic</a></li><li><a href="../../../.././Mathlib/Topology/Category/CompHausLike/Limits.html">Mathlib.Topology.Category.CompHausLike.Limits</a></li><li><a href="../../../.././Mathlib/Topology/Category/LightProfinite/AsLimit.html">Mathlib.Topology.Category.LightProfinite.AsLimit</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.Category.LightProfinite.Injective" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Profinite.exists_lift_of_finite_of_injective_of_surjective"><span class="name">Profinite</span>.<span class="name">exists_lift_of_finite_of_injective_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Profinite.exists_lift_of_finite_of_mono_of_epi"><span class="name">Profinite</span>.<span class="name">exists_lift_of_finite_of_mono_of_epi</span></a></div><div class="nav_link"><a class="break_within" href="#Profinite.injective_of_finite"><span class="name">Profinite</span>.<span class="name">injective_of_finite</span></a></div><div class="nav_link"><a class="break_within" href="#Profinite.injective_of_light"><span class="name">Profinite</span>.<span class="name">injective_of_light</span></a></div><div class="nav_link"><a class="break_within" href="#LightProfinite.injective"><span class="name">LightProfinite</span>.<span class="name">injective</span></a></div></nav><main>
<div class="mod_doc"><h1 id="Injectivity-of-light-profinite-spaces" class="markdown-heading">Injectivity of light profinite spaces <a class="hover-link" href="#Injectivity-of-light-profinite-spaces">#</a></h1><p>This file establishes that non-empty light profinite sets are injective in the
category of profinite sets, and thus also in the category of light profinite sets.
This is used in the proof that the null sequence module is internally projective in light
condensed abelian groups.</p><h2 id="Main-results" class="markdown-heading">Main results <a class="hover-link" href="#Main-results">#</a></h2><p>The main result is <code><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.injective_of_light">Profinite.injective_of_light</a></code>, which provides an instance of
<code>Injective (lightToProfinite.obj S)</code> for a non-empty light profinite set <code>S</code>. We deduce the
instance <code><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#LightProfinite.injective">LightProfinite.injective</a></code> that every light profinite set is an injective object in the
category <code><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite">LightProfinite</a></code>. The proof uses an inductive extension argument along a presentation of
<code>S</code> as sequential limit of finite discrete spaces. The key lemma is
<code><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.exists_lift_of_finite_of_mono_of_epi">exists_lift_of_finite_of_mono_of_epi</a></code>.</p><h2 id="References" class="markdown-heading">References <a class="hover-link" href="#References">#</a></h2><ul><li><a href="https://kskedlaya.org/condensed/sec_profinite_set.html#sec_profinite_set-5">https://kskedlaya.org/condensed/sec_profinite_set.html#sec_profinite_set-5</a></li><li><a href="https://www.youtube.com/watch?v=_4G582SIo28&amp;t=3187s">https://www.youtube.com/watch?v=_4G582SIo28&amp;t=3187s</a></li></ul></div><div class="decl" id="Profinite.exists_lift_of_finite_of_injective_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean#L48-L116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.exists_lift_of_finite_of_injective_of_surjective"><span class="name">Profinite</span>.<span class="name">exists_lift_of_finite_of_injective_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">T</span> : <a href="../../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Connected/TotallyDisconnected.html#TotallyDisconnectedSpace">TotallyDisconnectedSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f_inj</span> : <span class="fn"><span class="fn">Function.Injective</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn"><span class="fn">S</span> ‚Üí <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'_surj</span> : <span class="fn"><span class="fn">Function.Surjective</span> <span class="fn">f'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn"><span class="fn">Y</span> ‚Üí <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg'</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">g'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_comm</span> : <span class="fn"><span class="fn"><span class="fn">g'</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn"><span class="fn">f'</span> <span class="fn">‚àò</span> <span class="fn">g</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn"><span class="fn">Y</span> ‚Üí <span class="fn">S</span></span>), <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">k</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f'</span> <span class="fn">‚àò</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn">g'</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><span class="fn">k</span> <span class="fn">‚àò</span> <span class="fn">f</span></span> <span class="fn">=</span> <span class="fn">g</span></span></span></span></span></div></div><p>This is the key statement for the inductive proof of injectivity of light profinite spaces.
Given a commutative square</p><pre><code>X &gt;-f-&gt;  Y
|g       |g'
v        v
S -f'-&gt;&gt; T
</code></pre><p>where <code>Y</code> is profinite, <code>S</code> is finite, <code>f</code> is injective and <code>f'</code> is surjective,
there exists a diagonal map <code>k : Y ‚Üí S</code> making the diagram commute.</p></div></div><div class="decl" id="Profinite.exists_lift_of_finite_of_mono_of_epi"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean#L118-L128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.exists_lift_of_finite_of_mono_of_epi"><span class="name">Profinite</span>.<span class="name">exists_lift_of_finite_of_mono_of_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y </span><span class="fn">S </span><span class="fn">T</span> : <a href="../../../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">‚Üë<span class="fn"><span class="fn">S</span>.<a href="../../../.././Mathlib/Topology/Category/CompHausLike/Basic.html#CompHausLike.toTop">toTop</a></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">f</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">S</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">f'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_comm</span> : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span> <span class="fn">=</span> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">k</span> : <span class="fn">Y</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">‚ü∂</a> <span class="fn">S</span>), <span class="fn"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">k</span> <span class="fn">f'</span></span> <span class="fn">=</span> <span class="fn">g'</span></span> <span class="fn">‚àß</span> <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">k</span></span> <span class="fn">=</span> <span class="fn">g</span></span></span></span></div></div><p>A categorically stated version of <code><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.exists_lift_of_finite_of_injective_of_surjective">exists_lift_of_finite_of_injective_of_surjective</a></code> in the
category <code><a href="../../../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code>.</p></div></div><div class="decl" id="Profinite.injective_of_finite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean#L130-L139">source</a></div><div class="verification_link">
<a href="../../../../../modules/Mathlib_Topology_Category_LightProfinite_Injective.html#Profinite.injective_of_finite" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.injective_of_finite"><span class="name">Profinite</span>.<span class="name">injective_of_finite</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <a href="../../../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">‚Üë<span class="fn"><span class="fn">S</span>.<a href="../../../.././Mathlib/Topology/Category/CompHausLike/Basic.html#CompHausLike.toTop">toTop</a></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">‚Üë<span class="fn"><span class="fn">S</span>.<a href="../../../.././Mathlib/Topology/Category/CompHausLike/Basic.html#CompHausLike.toTop">toTop</a></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Preadditive/Injective/Basic.html#CategoryTheory.Injective">CategoryTheory.Injective</a> <span class="fn">S</span></span></div></div><p>Finite sets are injective objects in <code><a href="../../../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code>.</p></div></div><div class="decl" id="Profinite.injective_of_light"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean#L142-L201">source</a></div><div class="verification_link">
<a href="../../../../../modules/Mathlib_Topology_Category_LightProfinite_Injective.html#Profinite.injective_of_light" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#Profinite.injective_of_light"><span class="name">Profinite</span>.<span class="name">injective_of_light</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <a href="../../../.././Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite">LightProfinite</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">‚Üë<span class="fn"><span class="fn">S</span>.<a href="../../../.././Mathlib/Topology/Category/CompHausLike/Basic.html#CompHausLike.toTop">toTop</a></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Preadditive/Injective/Basic.html#CategoryTheory.Injective">CategoryTheory.Injective</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Category/LightProfinite/Basic.html#lightToProfinite">lightToProfinite</a>.<a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">S</span>)</span></span></div></div><p>A nonempty light profinite space is injective in <code><a href="../../../.././Mathlib/Topology/Category/Profinite/Basic.html#Profinite">Profinite</a></code>.</p></div></div><div class="decl" id="LightProfinite.injective"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/338973d7437af2cf5a6769391b1b4e5b1f8db099/Mathlib/Topology/Category/LightProfinite/Injective.lean#L205-L210">source</a></div><div class="verification_link">
<a href="../../../../../modules/Mathlib_Topology_Category_LightProfinite_Injective.html#LightProfinite.injective" class="verification-badge mathematical" title="Mathematical property (specification layer)">üìê coverage</a>
</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Category/LightProfinite/Injective.html#LightProfinite.injective"><span class="name">LightProfinite</span>.<span class="name">injective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <a href="../../../.././Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite">LightProfinite</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">Nonempty</span> <span class="fn">‚Üë<span class="fn"><span class="fn">S</span>.<a href="../../../.././Mathlib/Topology/Category/CompHausLike/Basic.html#CompHausLike.toTop">toTop</a></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Preadditive/Injective/Basic.html#CategoryTheory.Injective">CategoryTheory.Injective</a> <span class="fn">S</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>