<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_RingTheory_Lasker - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_RingTheory_Lasker
      </nav>
      <h1>Lasker</h1>
<p>üìÅ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean">Mathlib/RingTheory/Lasker.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#Ideal-IsMinimalPrimaryDecomposition"><code>IsMinimalPrimaryDecomposition</code></a>, <a href="#IsLasker"><code>IsLasker</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition"><code>IsMinimalPrimaryDecomposition</code></a></details></td><td>3</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#Ideal-IsLasker-exists_isMinimalPrimaryDecomposition"><code>exists_isMinimalPrimaryDecomposition</code></a>, <a href="#Ideal-IsLasker-minimal"><code>minimal</code></a>, <a href="#Ideal-IsMinimalPrimaryDecomposition-minimalPrimes_subset_image_radical"><code>minimalPrimes_subset_image_radical</code></a>, <a href="#Ideal-decomposition_erase_inf"><code>decomposition_erase_inf</code></a>, <a href="#Ideal-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a>, <a href="#Ideal-isLasker"><code>isLasker</code></a>, <a href="#Ideal-isPrimary_decomposition_pairwise_ne_radical"><code>isPrimary_decomposition_pairwise_ne_radical</code></a>, <a href="#InfIrred-isPrimary"><code>isPrimary</code></a>, <a href="#Submodule-IsLasker-exists_isMinimalPrimaryDecomposition"><code>exists_isMinimalPrimaryDecomposition</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-distinct"><code>distinct</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-image_radical_eq_associated_primes"><code>image_radical_eq_associated_primes</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-inf_eq"><code>inf_eq</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-mem_image_radical_colon_iff"><code>mem_image_radical_colon_iff</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-minimal"><code>minimal</code></a>, <a href="#Submodule-IsMinimalPrimaryDecomposition-primary"><code>primary</code></a>, <a href="#Submodule-decomposition_erase_inf"><code>decomposition_erase_inf</code></a>, <a href="#Submodule-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a>, <a href="#Submodule-isLasker"><code>isLasker</code></a>, <a href="#Submodule-isPrimary_decomposition_pairwise_ne_radical"><code>isPrimary_decomposition_pairwise_ne_radical</code></a></details></td><td>19</td></tr>
<tr><td><strong>Total</strong></td><td><strong>22</strong></td></tr>
</table>
<h2>Ideal</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L175" id="Ideal-IsMinimalPrimaryDecomposition"><code>IsMinimalPrimaryDecomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.IsMinimalPrimaryDecomposition" title="API Documentation">üìñ</a></td><td>MathDef</td><td>‚Äî</td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L164" id="Ideal-decomposition_erase_inf"><code>decomposition_erase_inf</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.decomposition_erase_inf" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>Submodule.instOrderTop</code></a></td><td><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instHasSubset"><code>Finset.instHasSubset</code></a><br><a href="#Preorder-toLE"><code>Preorder.toLE</code></a><br><a href="#PartialOrder-toPreorder"><code>PartialOrder.toPreorder</code></a><br><a href="#Submodule-instPartialOrder"><code>Submodule.instPartialOrder</code></a><br><a href="#Finset-erase"><code>Finset.erase</code></a><br><a href="#Submodule-decidableEq"><code>Submodule.decidableEq</code></a></td><td>‚Äî</td><td><a href="#Submodule-decomposition_erase_inf"><code>Submodule.decomposition_erase_inf</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L171" id="Ideal-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>Submodule.instOrderTop</code></a><br><a href="#Submodule-IsPrimary"><code>Submodule.IsPrimary</code></a></td><td><a href="#Set-Pairwise"><code>Set.Pairwise</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Function-onFun"><code>Function.onFun</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>radical</code></a><br><a href="#Submodule-colon"><code>Submodule.colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a><br><a href="#Preorder-toLE"><code>Preorder.toLE</code></a><br><a href="#PartialOrder-toPreorder"><code>PartialOrder.toPreorder</code></a><br><a href="#Submodule-instPartialOrder"><code>Submodule.instPartialOrder</code></a><br><a href="#Finset-erase"><code>Finset.erase</code></a><br><a href="#Submodule-decidableEq"><code>Submodule.decidableEq</code></a></td><td>‚Äî</td><td><a href="#Submodule-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>Submodule.exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L232" id="Ideal-isLasker"><code>isLasker</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.isLasker" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#IsLasker"><code>IsLasker</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#AddCommGroup-toAddCommMonoid"><code>AddCommGroup.toAddCommMonoid</code></a></td><td>‚Äî</td><td><a href="#Submodule-isLasker"><code>Submodule.isLasker</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L167" id="Ideal-isPrimary_decomposition_pairwise_ne_radical"><code>isPrimary_decomposition_pairwise_ne_radical</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.isPrimary_decomposition_pairwise_ne_radical" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>Submodule.instOrderTop</code></a><br><a href="#Submodule-IsPrimary"><code>Submodule.IsPrimary</code></a></td><td><a href="#Set-Pairwise"><code>Set.Pairwise</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Function-onFun"><code>Function.onFun</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>radical</code></a><br><a href="#Submodule-colon"><code>Submodule.colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a></td><td>‚Äî</td><td><a href="#Submodule-isPrimary_decomposition_pairwise_ne_radical"><code>Submodule.isPrimary_decomposition_pairwise_ne_radical</code></a></td></tr>
</table>
<h2>Ideal.IsLasker</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L178" id="Ideal-IsLasker-exists_isMinimalPrimaryDecomposition"><code>exists_isMinimalPrimaryDecomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.IsLasker.exists_isMinimalPrimaryDecomposition" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#IsLasker"><code>IsLasker</code></a></td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td>‚Äî</td><td><a href="#Submodule-IsLasker-exists_isMinimalPrimaryDecomposition"><code>Submodule.IsLasker.exists_isMinimalPrimaryDecomposition</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L182" id="Ideal-IsLasker-minimal"><code>minimal</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.IsLasker.minimal" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#IsLasker"><code>IsLasker</code></a></td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td>‚Äî</td><td><a href="#Submodule-IsLasker-exists_isMinimalPrimaryDecomposition"><code>Submodule.IsLasker.exists_isMinimalPrimaryDecomposition</code></a></td></tr>
</table>
<h2>Ideal.IsMinimalPrimaryDecomposition</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L150" id="Ideal-IsMinimalPrimaryDecomposition-minimalPrimes_subset_image_radical"><code>minimalPrimes_subset_image_radical</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Ideal.IsMinimalPrimaryDecomposition.minimalPrimes_subset_image_radical" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a><br><a href="#NonUnitalNonAssocSemiring-toAddCommMonoid"><code>NonUnitalNonAssocSemiring.toAddCommMonoid</code></a><br><a href="#NonAssocSemiring-toNonUnitalNonAssocSemiring"><code>NonAssocSemiring.toNonUnitalNonAssocSemiring</code></a><br><a href="#Semiring-toNonAssocSemiring"><code>Semiring.toNonAssocSemiring</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Semiring-toModule"><code>Semiring.toModule</code></a></td><td><a href="#Set"><code>Set</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Set-instHasSubset"><code>Set.instHasSubset</code></a><br><a href="#Ideal-minimalPrimes"><code>Ideal.minimalPrimes</code></a><br><a href="#Set-image"><code>Set.image</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a></td><td>‚Äî</td><td><a href="#Ideal-IsPrime-radical"><code>Ideal.IsPrime.radical</code></a><br><a href="#le_trans"><code>le_trans</code></a><br><a href="#Submodule-IsMinimalPrimaryDecomposition-inf_eq"><code>Submodule.IsMinimalPrimaryDecomposition.inf_eq</code></a><br><a href="#Ideal-radicalInfTopHom_apply"><code>Ideal.radicalInfTopHom_apply</code></a><br><a href="#map_finset_inf"><code>map_finset_inf</code></a><br><a href="#InfTopHom-instInfTopHomClass"><code>InfTopHom.instInfTopHomClass</code></a><br><a href="#le_refl"><code>le_refl</code></a><br><a href="#Ideal-radical_mono"><code>Ideal.radical_mono</code></a><br><a href="#Ideal-IsPrime-inf_le'"><code>Ideal.IsPrime.inf_le'</code></a><br><a href="#le_antisymm"><code>le_antisymm</code></a><br><a href="#Ideal-isPrime_radical"><code>Ideal.isPrime_radical</code></a><br><a href="#Submodule-IsMinimalPrimaryDecomposition-primary"><code>Submodule.IsMinimalPrimaryDecomposition.primary</code></a><br><a href="#Eq-trans_le"><code>Eq.trans_le</code></a><br><a href="#LE-le-trans"><code>LE.le.trans</code></a><br><a href="#Finset-inf_le"><code>Finset.inf_le</code></a><br><a href="#Ideal-le_radical"><code>Ideal.le_radical</code></a></td></tr>
</table>
<h2>InfIrred</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L194" id="InfIrred-isPrimary"><code>isPrimary</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#InfIrred.isPrimary" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#InfIrred"><code>InfIrred</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#AddCommGroup-toAddCommMonoid"><code>AddCommGroup.toAddCommMonoid</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a></td><td><a href="#Submodule-IsPrimary"><code>Submodule.IsPrimary</code></a></td><td>‚Äî</td><td><a href="#Submodule-IsPrimary-eq_1"><code>Submodule.IsPrimary.eq_1</code></a><br><a href="#InfIrred-ne_top"><code>ne_top</code></a><br><a href="#smul_add"><code>smul_add</code></a><br><a href="#Submodule-add_mem"><code>Submodule.add_mem</code></a><br><a href="#smul_zero"><code>smul_zero</code></a><br><a href="#AddSubmonoidClass-toZeroMemClass"><code>AddSubmonoidClass.toZeroMemClass</code></a><br><a href="#Submodule-addSubmonoidClass"><code>Submodule.addSubmonoidClass</code></a><br><a href="#SMulCommClass-smul_comm"><code>SMulCommClass.smul_comm</code></a><br><a href="#smulCommClass_self"><code>smulCommClass_self</code></a><br><a href="#Submodule-smul_mem"><code>Submodule.smul_mem</code></a><br><a href="#smul_smul"><code>smul_smul</code></a><br><a href="#monotone_stabilizes_iff_noetherian"><code>monotone_stabilizes_iff_noetherian</code></a><br><a href="#pow_succ"><code>pow_succ</code></a><br><a href="#SemigroupAction-mul_smul"><code>SemigroupAction.mul_smul</code></a><br><a href="#sup_eq_left"><code>sup_eq_left</code></a><br><a href="#Submodule-add_eq_sup"><code>Submodule.add_eq_sup</code></a><br><a href="#le_antisymm"><code>le_antisymm</code></a><br><a href="#le_add_self"><code>le_add_self</code></a><br><a href="#Nat-instCanonicallyOrderedAdd"><code>Nat.instCanonicallyOrderedAdd</code></a><br><a href="#Submodule-add_mem_iff_right"><code>Submodule.add_mem_iff_right</code></a><br><a href="#pow_add"><code>pow_add</code></a><br><a href="#le_inf"><code>le_inf</code></a></td></tr>
</table>
<h2>Submodule</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L103" id="Submodule-IsMinimalPrimaryDecomposition"><code>IsMinimalPrimaryDecomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition" title="API Documentation">üìñ</a></td><td>CompData</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#Ideal-IsLasker-minimal"><code>Ideal.IsLasker.minimal</code></a>, <a href="#Ideal-IsLasker-exists_isMinimalPrimaryDecomposition"><code>Ideal.IsLasker.exists_isMinimalPrimaryDecomposition</code></a>, <a href="#Submodule-IsLasker-exists_isMinimalPrimaryDecomposition"><code>IsLasker.exists_isMinimalPrimaryDecomposition</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L45" id="Submodule-decomposition_erase_inf"><code>decomposition_erase_inf</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.decomposition_erase_inf" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>instOrderTop</code></a></td><td><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instHasSubset"><code>Finset.instHasSubset</code></a><br><a href="#Preorder-toLE"><code>Preorder.toLE</code></a><br><a href="#PartialOrder-toPreorder"><code>PartialOrder.toPreorder</code></a><br><a href="#Submodule-instPartialOrder"><code>instPartialOrder</code></a><br><a href="#Finset-erase"><code>Finset.erase</code></a><br><a href="#Submodule-decidableEq"><code>decidableEq</code></a></td><td>‚Äî</td><td><a href="#Finset-eraseInduction"><code>Finset.eraseInduction</code></a><br><a href="#Finset-Subset-rfl"><code>Finset.Subset.rfl</code></a><br><a href="#Mathlib-Tactic-Push-not_forall_eq"><code>Mathlib.Tactic.Push.not_forall_eq</code></a><br><a href="#HasSubset-Subset-trans"><code>HasSubset.Subset.trans</code></a><br><a href="#Finset-instIsTransSubset"><code>Finset.instIsTransSubset</code></a><br><a href="#Finset-erase_subset"><code>Finset.erase_subset</code></a><br><a href="#Finset-insert_erase"><code>Finset.insert_erase</code></a><br><a href="#Finset-inf_insert"><code>Finset.inf_insert</code></a><br><a href="#inf_of_le_right"><code>inf_of_le_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L91" id="Submodule-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>instOrderTop</code></a><br><a href="#Submodule-IsPrimary"><code>IsPrimary</code></a></td><td><a href="#Set-Pairwise"><code>Set.Pairwise</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Function-onFun"><code>Function.onFun</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#Submodule-colon"><code>colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a><br><a href="#Preorder-toLE"><code>Preorder.toLE</code></a><br><a href="#PartialOrder-toPreorder"><code>PartialOrder.toPreorder</code></a><br><a href="#Submodule-instPartialOrder"><code>instPartialOrder</code></a><br><a href="#Finset-erase"><code>Finset.erase</code></a><br><a href="#Submodule-decidableEq"><code>decidableEq</code></a></td><td>‚Äî</td><td><a href="#Submodule-isPrimary_decomposition_pairwise_ne_radical"><code>isPrimary_decomposition_pairwise_ne_radical</code></a><br><a href="#Submodule-decomposition_erase_inf"><code>decomposition_erase_inf</code></a><br><a href="#Set-Pairwise-mono"><code>Set.Pairwise.mono</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L224" id="Submodule-isLasker"><code>isLasker</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.isLasker" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#IsLasker"><code>IsLasker</code></a><br><a href="#CommRing-toCommSemiring"><code>CommRing.toCommSemiring</code></a><br><a href="#AddCommGroup-toAddCommMonoid"><code>AddCommGroup.toAddCommMonoid</code></a></td><td>‚Äî</td><td><a href="#InfIrred-isPrimary"><code>InfIrred.isPrimary</code></a><br><a href="#exists_infIrred_decomposition"><code>exists_infIrred_decomposition</code></a><br><a href="#wellFoundedGT"><code>wellFoundedGT</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L61" id="Submodule-isPrimary_decomposition_pairwise_ne_radical"><code>isPrimary_decomposition_pairwise_ne_radical</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.isPrimary_decomposition_pairwise_ne_radical" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>instOrderTop</code></a><br><a href="#Submodule-IsPrimary"><code>IsPrimary</code></a></td><td><a href="#Set-Pairwise"><code>Set.Pairwise</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Function-onFun"><code>Function.onFun</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#Submodule-colon"><code>colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a></td><td>‚Äî</td><td><a href="#Submodule-ext"><code>ext</code></a><br><a href="#Submodule-isPrimary_finsetInf"><code>isPrimary_finsetInf</code></a><br><a href="#Finset-coe_image"><code>Finset.coe_image</code></a><br><a href="#Mathlib-Tactic-Contrapose-contrapose‚ÇÑ"><code>Mathlib.Tactic.Contrapose.contrapose‚ÇÑ</code></a><br><a href="#Ideal-radical_finset_inf"><code>Ideal.radical_finset_inf</code></a><br><a href="#Submodule-colon_finsetInf"><code>colon_finsetInf</code></a></td></tr>
</table>
<h2>Submodule.IsLasker</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L110" id="Submodule-IsLasker-exists_isMinimalPrimaryDecomposition"><code>exists_isMinimalPrimaryDecomposition</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsLasker.exists_isMinimalPrimaryDecomposition" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#IsLasker"><code>IsLasker</code></a></td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td>‚Äî</td><td><a href="#Submodule-exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition"><code>Submodule.exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition</code></a></td></tr>
</table>
<h2>Submodule.IsMinimalPrimaryDecomposition</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L107" id="Submodule-IsMinimalPrimaryDecomposition-distinct"><code>distinct</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.distinct" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td><a href="#Set-Pairwise"><code>Set.Pairwise</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Function-onFun"><code>Function.onFun</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#Submodule-colon"><code>Submodule.colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L121" id="Submodule-IsMinimalPrimaryDecomposition-image_radical_eq_associated_primes"><code>image_radical_eq_associated_primes</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.image_radical_eq_associated_primes" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td><a href="#Set-image"><code>Set.image</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#Submodule-colon"><code>Submodule.colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Submodule-associatedPrimes"><code>Submodule.associatedPrimes</code></a></td><td>‚Äî</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition-inf_eq"><code>inf_eq</code></a><br><a href="#Submodule-colon_finsetInf"><code>Submodule.colon_finsetInf</code></a><br><a href="#map_finset_inf"><code>map_finset_inf</code></a><br><a href="#InfTopHom-instInfTopHomClass"><code>InfTopHom.instInfTopHomClass</code></a><br><a href="#Finset-inf_congr"><code>Finset.inf_congr</code></a><br><a href="#Submodule-IsPrimary-radical_colon_singleton_eq_ite"><code>Submodule.IsPrimary.radical_colon_singleton_eq_ite</code></a><br><a href="#Submodule-IsMinimalPrimaryDecomposition-primary"><code>primary</code></a><br><a href="#Finset-inf_ite"><code>Finset.inf_ite</code></a><br><a href="#Finset-inf_top"><code>Finset.inf_top</code></a><br><a href="#top_inf_eq"><code>top_inf_eq</code></a><br><a href="#Set-ext"><code>Set.ext</code></a><br><a href="#SetLike-not_le_iff_exists"><code>SetLike.not_le_iff_exists</code></a><br><a href="#instIsConcreteLE"><code>instIsConcreteLE</code></a><br><a href="#Submodule-IsMinimalPrimaryDecomposition-minimal"><code>minimal</code></a><br><a href="#Submodule-IsPrimary-isPrime_radical_colon"><code>Submodule.IsPrimary.isPrime_radical_colon</code></a><br><a href="#Finset-insert_erase"><code>Finset.insert_erase</code></a><br><a href="#Finset-mem_filter"><code>Finset.mem_filter</code></a><br><a href="#Finset-inf_insert"><code>Finset.inf_insert</code></a><br><a href="#inf_eq_left"><code>inf_eq_left</code></a><br><a href="#Finset-le_inf_iff"><code>Finset.le_inf_iff</code></a><br><a href="#Ideal-eq_inf_of_isPrime_inf"><code>Ideal.eq_inf_of_isPrime_inf</code></a><br><a href="#Finset-mem_of_mem_filter"><code>Finset.mem_of_mem_filter</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L105" id="Submodule-IsMinimalPrimaryDecomposition-inf_eq"><code>inf_eq</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.inf_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>Submodule.instOrderTop</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L145" id="Submodule-IsMinimalPrimaryDecomposition-mem_image_radical_colon_iff"><code>mem_image_radical_colon_iff</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.mem_image_radical_colon_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a></td><td><a href="#Set-image"><code>Set.image</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Ideal"><code>Ideal</code></a><br><a href="#Ideal-radical"><code>Ideal.radical</code></a><br><a href="#Submodule-colon"><code>Submodule.colon</code></a><br><a href="#Set-univ"><code>Set.univ</code></a><br><a href="#SetLike-coe"><code>SetLike.coe</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a><br><a href="#Submodule-associatedPrimes"><code>Submodule.associatedPrimes</code></a></td><td>‚Äî</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition-image_radical_eq_associated_primes"><code>image_radical_eq_associated_primes</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L108" id="Submodule-IsMinimalPrimaryDecomposition-minimal"><code>minimal</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.minimal" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#SetLike-instMembership"><code>SetLike.instMembership</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a></td><td><a href="#Preorder-toLE"><code>Preorder.toLE</code></a><br><a href="#PartialOrder-toPreorder"><code>PartialOrder.toPreorder</code></a><br><a href="#Submodule-instPartialOrder"><code>Submodule.instPartialOrder</code></a><br><a href="#Finset-inf"><code>Finset.inf</code></a><br><a href="#Lattice-toSemilatticeInf"><code>Lattice.toSemilatticeInf</code></a><br><a href="#ConditionallyCompleteLattice-toLattice"><code>ConditionallyCompleteLattice.toLattice</code></a><br><a href="#CompleteLattice-toConditionallyCompleteLattice"><code>CompleteLattice.toConditionallyCompleteLattice</code></a><br><a href="#Submodule-completeLattice"><code>Submodule.completeLattice</code></a><br><a href="#Submodule-instOrderTop"><code>Submodule.instOrderTop</code></a><br><a href="#Finset-erase"><code>Finset.erase</code></a><br><a href="#Submodule-decidableEq"><code>Submodule.decidableEq</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L106" id="Submodule-IsMinimalPrimaryDecomposition-primary"><code>primary</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#Submodule.IsMinimalPrimaryDecomposition.primary" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Submodule-IsMinimalPrimaryDecomposition"><code>Submodule.IsMinimalPrimaryDecomposition</code></a><br><a href="#Submodule"><code>Submodule</code></a><br><a href="#CommSemiring-toSemiring"><code>CommSemiring.toSemiring</code></a><br><a href="#Finset"><code>Finset</code></a><br><a href="#SetLike-instMembership"><code>SetLike.instMembership</code></a><br><a href="#Finset-instSetLike"><code>Finset.instSetLike</code></a></td><td><a href="#Submodule-IsPrimary"><code>Submodule.IsPrimary</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>(root)</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/RingTheory/Lasker.lean#L38" id="IsLasker"><code>IsLasker</code></a> <a href="../api/Mathlib/RingTheory/Lasker.html#IsLasker" title="API Documentation">üìñ</a></td><td>MathDef</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#Ideal-isLasker"><code>Ideal.isLasker</code></a>, <a href="#Submodule-isLasker"><code>Submodule.isLasker</code></a><br></details></td></tr>
</table>
<p>---</p>
<p><a href="index.html">‚Üê Back to Index</a></p>
    </div>
  </main>
</body>
</html>