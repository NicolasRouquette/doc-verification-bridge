<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_CategoryTheory_Localization_StructuredArrow - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_CategoryTheory_Localization_StructuredArrow
      </nav>
      <h1>StructuredArrow</h1>
<p>üìÅ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean">Mathlib/CategoryTheory/Localization/StructuredArrow.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#CategoryTheory-Localization-structuredArrowEquiv"><code>structuredArrowEquiv</code></a>, <a href="#CategoryTheory-StructuredArrow"><code>StructuredArrow</code></a></details></td><td>2</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#CategoryTheory-Localization-induction_costructuredArrow"><code>induction_costructuredArrow</code></a>, <a href="#CategoryTheory-Localization-induction_structuredArrow"><code>induction_structuredArrow</code></a>, <a href="#CategoryTheory-Localization-structuredArrowEquiv_apply"><code>structuredArrowEquiv_apply</code></a>, <a href="#CategoryTheory-Localization-structuredArrowEquiv_symm_apply"><code>structuredArrowEquiv_symm_apply</code></a></details></td><td>4</td></tr>
<tr><td><strong>Total</strong></td><td><strong>6</strong></td></tr>
</table>
<h2>CategoryTheory</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L40" id="CategoryTheory-StructuredArrow"><code>StructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.StructuredArrow" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>321 math</summary><strong>math:</strong> <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_hom_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_hom_right</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_map"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map</code></a>, <a href="#CategoryTheory-TwoSquare-instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact"><code>TwoSquare.instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_pt"><code>Limits.Cone.toUnder_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-final_pre"><code>StructuredArrow.final_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-projectSubobject_mk"><code>StructuredArrow.projectSubobject_mk</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>StructuredArrow.instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_right"><code>StructuredArrow.map_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_inv_right"><code>StructuredArrow.isoMk_inv_right</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact"><code>TwoSquare.instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-StructuredArrow-map_comp"><code>StructuredArrow.map_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_obj"><code>Functor.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-Limits-limit-toStructuredArrow_obj"><code>Limits.limit.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_right"><code>StructuredArrow.map_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_left"><code>StructuredArrow.mapIso_functor_obj_left</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromStructuredArrow_map"><code>CategoryOfElements.fromStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_map"><code>StructuredArrow.commaMapEquivalenceInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>StructuredArrow.ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_hom"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_hom</code></a>, <a href="#Profinite-Extend-functorOp_map"><code>Profinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_comp"><code>StructuredArrow.homMk'_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>StructuredArrow.ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map"><code>StructuredArrow.final_map</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_functor"><code>CategoryOfElements.structuredArrowEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimit"><code>StructuredArrow.hasLimit</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_inverse"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_hom"><code>StructuredArrow.mapIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>StructuredArrow.toUnder_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-IsUniversal-uniq"><code>StructuredArrow.IsUniversal.uniq</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_lift_app"><code>Functor.pointwiseRightKanExtension_lift_app</code></a>, <a href="#CondensedMod-isDiscrete_tfae"><code>CondensedMod.isDiscrete_tfae</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_right"><code>StructuredArrow.map‚ÇÇ_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_left_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_hom_app_left_right</code></a>, <a href="#Profinite-Extend-cone_œÄ_app"><code>Profinite.Extend.cone_œÄ_app</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_map"><code>TwoSquare.EquivalenceJ.inverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_right"><code>StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_pt"><code>Functor.RightExtension.coneAt_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_right"><code>StructuredArrow.map‚ÇÇ_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_right_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_hom"><code>StructuredArrow.preEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-TwoSquare-instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact"><code>TwoSquare.instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_faithful"><code>StructuredArrow.proj_faithful</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAt_œÄ_app"><code>Functor.RightExtension.coneAt_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_right"><code>StructuredArrow.mapNatIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_hom_right"><code>StructuredArrow.eta_hom_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_right</code></a>, <a href="#CategoryTheory-Limits-limit-toStructuredArrow_map"><code>Limits.limit.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_unitIso"><code>TwoSquare.equivalenceJ_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_reflectsIsomorphisms"><code>StructuredArrow.proj_reflectsIsomorphisms</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_map"><code>StructuredArrow.prodInverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-eta_inv_right"><code>StructuredArrow.eta_inv_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_inv_app"><code>Limits.Cone.toStructuredArrowCompProj_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>StructuredArrow.instEssSurjCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_right</code></a>, <a href="#CategoryTheory-CategoryOfElements-to_comma_map_right"><code>CategoryOfElements.to_comma_map_right</code></a>, <a href="#CategoryTheory-Functor-Final-instNonemptyStructuredArrow"><code>Functor.Final.instNonemptyStructuredArrow</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjObjCompPostOfFull"><code>StructuredArrow.instEssSurjObjCompPostOfFull</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_initial"><code>TwoSquare.guitartExact_iff_initial</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_œÄ_app"><code>Limits.Cone.fromStructuredArrow_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-id_right"><code>StructuredArrow.id_right</code></a>, <a href="#CategoryTheory-StructuredArrow-final_map‚ÇÇ_id"><code>StructuredArrow.final_map‚ÇÇ_id</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_left_as"><code>StructuredArrow.preEquivalenceFunctor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_left"><code>StructuredArrow.map‚ÇÇ_obj_left</code></a>, <a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_unitIso"><code>StructuredArrow.preEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_counitIso"><code>CategoryOfElements.structuredArrowEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-functor_map"><code>StructuredArrow.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>StructuredArrow.ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_map_left"><code>StructuredArrow.map‚ÇÇ_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>StructuredArrow.ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_pre"><code>StructuredArrow.isEquivalence_pre</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_map"><code>StructuredArrow.prodFunctor_map</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-final_post"><code>StructuredArrow.final_post</code></a>, <a href="#CategoryTheory-Functor-Final-out"><code>Functor.Final.out</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_functor"><code>StructuredArrow.prodEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_hom"><code>StructuredArrow.mapNatIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_right"><code>StructuredArrow.mapIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_right"><code>StructuredArrow.mapNatIso_inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_unitIso"><code>StructuredArrow.prodEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-full_map‚ÇÇ"><code>StructuredArrow.full_map‚ÇÇ</code></a>, <a href="#CategoryTheory-isFiltered_structuredArrow_of_isFiltered_of_exists"><code>isFiltered_structuredArrow_of_isFiltered_of_exists</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_right"><code>StructuredArrow.mapNatIso_functor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_left"><code>StructuredArrow.mapNatIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_counitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CategoryOfElements-toStructuredArrow_obj"><code>CategoryOfElements.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_inverse"><code>StructuredArrow.preEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_functor"><code>StructuredArrow.preEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_obj"><code>CostructuredArrow.toStructuredArrow'_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-fromStructuredArrow_pt"><code>Limits.Cone.fromStructuredArrow_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_comp"><code>StructuredArrow.homMk'_mk_comp</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_counitIso"><code>TwoSquare.equivalenceJ_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_hom_app_right"><code>StructuredArrow.mapNatIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>StructuredArrow.eqToHom_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_obj"><code>Functor.RightExtension.coneAtFunctor_obj</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_map"><code>Functor.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulObjCompPost"><code>StructuredArrow.instFaithfulObjCompPost</code></a>, <a href="#CategoryTheory-StructuredArrow-small_inverseImage_proj_of_locallySmall"><code>StructuredArrow.small_inverseImage_proj_of_locallySmall</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_œÄ_app"><code>Limits.Cone.toStructuredArrowCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_iff_mono_right"><code>StructuredArrow.mono_iff_mono_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-toStructuredArrow_obj"><code>Limits.Cocone.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_homMk"><code>StructuredArrow.epi_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>StructuredArrow.isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-instFinalStructuredArrowCompPreOfRepresentablyFlat"><code>instFinalStructuredArrowCompPreOfRepresentablyFlat</code></a>, <a href="#LightProfinite-Extend-functor_map"><code>LightProfinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_inv_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_inv_hom</code></a>, <a href="#CategoryTheory-CategoryOfElements-fromStructuredArrow_obj"><code>CategoryOfElements.fromStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_unitIso"><code>Limits.Cocone.equivStructuredArrow_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_comp"><code>StructuredArrow.mkPostcomp_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-isoMk_hom_right"><code>StructuredArrow.isoMk_hom_right</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_obj"><code>TwoSquare.costructuredArrowDownwardsPrecomp_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_map"><code>StructuredArrow.toCostructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimitsOfShape"><code>StructuredArrow.hasLimitsOfShape</code></a>, <a href="#CategoryTheory-Functor-final_iff_isFiltered_structuredArrow"><code>Functor.final_iff_isFiltered_structuredArrow</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>StructuredArrow.toUnder_map_right</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_inverse"><code>TwoSquare.equivalenceJ_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalenceMap‚ÇÇ"><code>StructuredArrow.isEquivalenceMap‚ÇÇ</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_obj_pt"><code>Limits.Cocone.fromStructuredArrow_obj_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_post"><code>StructuredArrow.isEquivalence_post</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ_assoc"><code>Functor.ranObjObjIsoLimit_inv_œÄ_assoc</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_inverse"><code>CategoryOfElements.structuredArrowEquivalence_inverse</code></a>, <a href="#Profinite-Extend-functor_obj"><code>Profinite.Extend.functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow'_map"><code>CostructuredArrow.toStructuredArrow'_map</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsStructuredArrowStructuredArrowObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsStructuredArrowStructuredArrowObjOfRespectsIso</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceInverse_obj"><code>StructuredArrow.commaMapEquivalenceInverse_obj</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÇ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_id"><code>StructuredArrow.homMk'_id</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_right"><code>StructuredArrow.preEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_right_left_as"><code>StructuredArrow.preEquivalenceInverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-hasLimitsOfSize"><code>StructuredArrow.hasLimitsOfSize</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_hom"><code>StructuredArrow.mapNatIso_inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_left"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-post_map"><code>StructuredArrow.post_map</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_left"><code>StructuredArrow.commaMapEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>StructuredArrow.instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-ObjectProperty-IsCoseparating-mono_productTo"><code>ObjectProperty.IsCoseparating.mono_productTo</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ_assoc"><code>Functor.ranObjObjIsoLimit_hom_œÄ_assoc</code></a>, <a href="#CategoryTheory-isRightAdjoint_iff_hasInitial_structuredArrow"><code>isRightAdjoint_iff_hasInitial_structuredArrow</code></a>, <a href="#CategoryTheory-StructuredArrow-faithful_map‚ÇÇ"><code>StructuredArrow.faithful_map‚ÇÇ</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_left"><code>StructuredArrow.pre_map_left</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÉ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÉ</code></a>, <a href="#CategoryTheory-StructuredArrow-map_map_left"><code>StructuredArrow.map_map_left</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_map_left_right"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_map_left_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_right"><code>StructuredArrow.mapIso_functor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_inv_app_right"><code>StructuredArrow.mapIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-prodFunctor_obj"><code>StructuredArrow.prodFunctor_obj</code></a>, <a href="#LightProfinite-Extend-functorOp_map"><code>LightProfinite.Extend.functorOp_map</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_map"><code>StructuredArrow.proj_map</code></a>, <a href="#Alexandrov-lowerCone_œÄ_app"><code>Alexandrov.lowerCone_œÄ_app</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_left"><code>StructuredArrow.mapIso_functor_map_left</code></a>, <a href="#TopCat-Presheaf-SheafCondition-instNonemptyStructuredArrowPairwiseOpensLeCoverPairwiseToOpensLeCover"><code>TopCat.Presheaf.SheafCondition.instNonemptyStructuredArrowPairwiseOpensLeCoverPairwiseToOpensLeCover</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_unitIso"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-comp_right"><code>StructuredArrow.comp_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_map_right"><code>StructuredArrow.commaMapEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-essentiallySmall"><code>StructuredArrow.essentiallySmall</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompProj_hom_app"><code>Limits.Cone.toStructuredArrowCompProj_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_left"><code>StructuredArrow.map_obj_left</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtensionCounit_app"><code>Functor.pointwiseRightKanExtensionCounit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_obj"><code>CostructuredArrow.toStructuredArrow_obj</code></a>, <a href="#CondensedSet-isDiscrete_tfae"><code>CondensedSet.isDiscrete_tfae</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_map_hom"><code>Limits.Cocone.fromStructuredArrow_map_hom</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_obj"><code>Functor.pointwiseRightKanExtension_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_hom_app_right"><code>StructuredArrow.mapNatIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-TwoSquare-costructuredArrowDownwardsPrecomp_map"><code>TwoSquare.costructuredArrowDownwardsPrecomp_map</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-isConnected"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.isConnected</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>StructuredArrow.toUnder_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_hom_app_right_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-map_mk"><code>StructuredArrow.map_mk</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_obj"><code>Limits.Cone.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_homMk"><code>StructuredArrow.mono_homMk</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_map_right_right"><code>StructuredArrow.preEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-Functor-Final-zigzag_of_eqvGen_colimitTypeRel"><code>Functor.Final.zigzag_of_eqvGen_colimitTypeRel</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_obj"><code>TwoSquare.EquivalenceJ.functor_obj</code></a>, <a href="#CategoryTheory-TwoSquare-isConnected_rightwards_iff_downwards"><code>TwoSquare.isConnected_rightwards_iff_downwards</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_unitIso_hom_app_right"><code>StructuredArrow.mapIso_unitIso_hom_app_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_inv_œÄ_assoc"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_right"><code>StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_inverse"><code>Limits.Cocone.equivStructuredArrow_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_map_right"><code>StructuredArrow.pre_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_obj_hom"><code>StructuredArrow.mapIso_functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_unitIso_inv_app_right"><code>StructuredArrow.mapNatIso_unitIso_inv_app_right</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_hom_œÄ"><code>Functor.ranObjObjIsoLimit_hom_œÄ</code></a>, <a href="#Alexandrov-projSup_obj"><code>Alexandrov.projSup_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>StructuredArrow.instFaithfulCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-functor_obj"><code>StructuredArrow.functor_obj</code></a>, <a href="#CategoryTheory-Functor-pointwiseRightKanExtension_map"><code>Functor.pointwiseRightKanExtension_map</code></a>, <a href="#CategoryTheory-StructuredArrow-mono_of_mono_right"><code>StructuredArrow.mono_of_mono_right</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtFunctor_map_hom"><code>Functor.RightExtension.coneAtFunctor_map_hom</code></a>, <a href="#Alexandrov-lowerCone_pt"><code>Alexandrov.lowerCone_pt</code></a>, <a href="#CategoryTheory-Limits-WalkingParallelPair-instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair"><code>Limits.WalkingParallelPair.instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair</code></a>, <a href="#CategoryTheory-Functor-RightExtension-coneAtWhiskerRightIso_hom_hom"><code>Functor.RightExtension.coneAtWhiskerRightIso_hom_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_right"><code>StructuredArrow.mapIso_inverse_map_right</code></a>, <a href="#Profinite-Extend-cone_pt"><code>Profinite.Extend.cone_pt</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_map"><code>TwoSquare.structuredArrowDownwards_map</code></a>, <a href="#CategoryTheory-Localization-structuredArrowEquiv_symm_apply"><code>Localization.structuredArrowEquiv_symm_apply</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CategoryOfElements-structuredArrowEquivalence_unitIso"><code>CategoryOfElements.structuredArrowEquivalence_unitIso</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowDownwards_obj"><code>TwoSquare.structuredArrowDownwards_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_inverse"><code>StructuredArrow.prodEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_obj_left"><code>StructuredArrow.mapNatIso_functor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_hom_app_right_left"><code>StructuredArrow.commaMapEquivalenceUnitIso_hom_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_map_right"><code>StructuredArrow.preEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_proj"><code>Limits.Cone.toStructuredArrow_comp_proj</code></a>, <a href="#SSet-StrictSegal-isPointwiseRightKanExtensionAt-fac_aux‚ÇÅ"><code>SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÅ</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_hom_right"><code>StructuredArrow.preEquivalenceInverse_obj_hom_right</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#LightProfinite-Extend-functor_initial"><code>LightProfinite.Extend.functor_initial</code></a>, <a href="#CategoryTheory-Functor-ranObjObjIsoLimit_inv_œÄ"><code>Functor.ranObjObjIsoLimit_inv_œÄ</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-functor_map"><code>TwoSquare.EquivalenceJ.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_obj_left"><code>StructuredArrow.mapIso_inverse_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceUnitIso_inv_app_right_left"><code>StructuredArrow.commaMapEquivalenceUnitIso_inv_app_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_functor_map_right"><code>StructuredArrow.mapIso_functor_map_right</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_pt"><code>Functor.structuredArrowMapCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>StructuredArrow.ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_hom"><code>StructuredArrow.pre_obj_hom</code></a>, <a href="#CategoryTheory-Limits-Cocone-toStructuredArrow_map"><code>Limits.Cocone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-TwoSquare-equivalenceJ_functor"><code>TwoSquare.equivalenceJ_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>StructuredArrow.toUnder_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-prodInverse_obj"><code>StructuredArrow.prodInverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_map"><code>Limits.Cone.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalence_counitIso"><code>StructuredArrow.preEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceInverse_obj_left_as"><code>StructuredArrow.preEquivalenceInverse_obj_left_as</code></a>, <a href="#LightProfinite-Extend-functor_obj"><code>LightProfinite.Extend.functor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_right"><code>StructuredArrow.preEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-proj_obj"><code>StructuredArrow.proj_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-essSurj_map‚ÇÇ"><code>StructuredArrow.essSurj_map‚ÇÇ</code></a>, <a href="#CategoryTheory-TwoSquare-EquivalenceJ-inverse_obj"><code>TwoSquare.EquivalenceJ.inverse_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_proj_preimage"><code>StructuredArrow.isCoseparating_proj_preimage</code></a>, <a href="#CategoryTheory-StructuredArrow-map_obj_hom"><code>StructuredArrow.map_obj_hom</code></a>, <a href="#CategoryTheory-ObjectProperty-LimitOfShape-toStructuredArrow_obj"><code>ObjectProperty.LimitOfShape.toStructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-prodEquivalence_counitIso"><code>StructuredArrow.prodEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_inverse_map_left"><code>StructuredArrow.mapIso_inverse_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>StructuredArrow.instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-LocalizerMorphism-IsRightDerivabilityStructure-Constructor-fromRightResolution_obj"><code>LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-map_id"><code>StructuredArrow.map_id</code></a>, <a href="#CategoryTheory-ObjectProperty-LimitOfShape-toStructuredArrow_map"><code>ObjectProperty.LimitOfShape.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-locallySmall"><code>StructuredArrow.locallySmall</code></a>, <a href="#CategoryTheory-Limits-WalkingParallelPair-instNonemptyStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair"><code>Limits.WalkingParallelPair.instNonemptyStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair</code></a>, <a href="#CategoryTheory-StructuredArrow-instSmallOfLocallySmall"><code>StructuredArrow.instSmallOfLocallySmall</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullCompPre"><code>StructuredArrow.instFullCompPre</code></a>, <a href="#CategoryTheory-StructuredArrow-wellPowered_structuredArrow"><code>StructuredArrow.wellPowered_structuredArrow</code></a>, <a href="#CategoryTheory-TwoSquare-guitartExact_iff_isConnected_downwards"><code>TwoSquare.guitartExact_iff_isConnected_downwards</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_map"><code>StructuredArrow.toCostructuredArrow'_map</code></a>, <a href="#CategoryTheory-StructuredArrow-post_obj"><code>StructuredArrow.post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow'_obj"><code>StructuredArrow.toCostructuredArrow'_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence_functor"><code>TwoSquare.structuredArrowRightwardsOpEquivalence_functor</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_functor"><code>Limits.Cocone.equivStructuredArrow_functor</code></a>, <a href="#CategoryTheory-instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty"><code>instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_map_left"><code>StructuredArrow.mapNatIso_inverse_map_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-fromStructuredArrow_obj_Œπ"><code>Limits.Cocone.fromStructuredArrow_obj_Œπ</code></a>, <a href="#Profinite-Extend-functor_initial"><code>Profinite.Extend.functor_initial</code></a>, <a href="#CategoryTheory-Limits-Cocone-equivStructuredArrow_counitIso"><code>Limits.Cocone.equivStructuredArrow_counitIso</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCone_pt"><code>Limits.Cone.toStructuredArrowCone_pt</code></a>, <a href="#CategoryTheory-Functor-RightExtension-IsPointwiseRightKanExtensionAt-isoLimit_hom_œÄ_assoc"><code>Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullObjCompPostOfFaithful"><code>StructuredArrow.instFullObjCompPostOfFaithful</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_left_as</code></a>, <a href="#Profinite-Extend-functor_map"><code>Profinite.Extend.functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>StructuredArrow.toUnder_obj_right</code></a>, <a href="#CategoryTheory-Functor-toStructuredArrow_comp_proj"><code>Functor.toStructuredArrow_comp_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_left_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_inv_app_left_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_functor_map_left"><code>StructuredArrow.mapNatIso_functor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-map‚ÇÇ_obj_hom"><code>StructuredArrow.map‚ÇÇ_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_counitIso_inv_app_right"><code>StructuredArrow.mapNatIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_right"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-isCoseparating_inverseImage_proj"><code>StructuredArrow.isCoseparating_inverseImage_proj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toStructuredArrow_map"><code>CostructuredArrow.toStructuredArrow_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-homMk'_mk_id"><code>StructuredArrow.homMk'_mk_id</code></a>, <a href="#Alexandrov-projSup_map"><code>Alexandrov.projSup_map</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_left"><code>StructuredArrow.pre_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-epi_of_epi_right"><code>StructuredArrow.epi_of_epi_right</code></a>, <a href="#CategoryTheory-TwoSquare-structuredArrowRightwardsOpEquivalence-functor_obj_left_left_as"><code>TwoSquare.structuredArrowRightwardsOpEquivalence.functor_obj_left_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-mkPostcomp_id"><code>StructuredArrow.mkPostcomp_id</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceCounitIso_inv_app_right_right"><code>StructuredArrow.commaMapEquivalenceCounitIso_inv_app_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_hom_app_right"><code>StructuredArrow.mapIso_counitIso_hom_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toCostructuredArrow_obj"><code>StructuredArrow.toCostructuredArrow_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-final_proj_of_isFiltered"><code>StructuredArrow.final_proj_of_isFiltered</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapNatIso_inverse_obj_right"><code>StructuredArrow.mapNatIso_inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-preEquivalenceFunctor_obj_hom"><code>StructuredArrow.preEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-mapIso_counitIso_inv_app_right"><code>StructuredArrow.mapIso_counitIso_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-commaMapEquivalenceFunctor_obj_hom"><code>StructuredArrow.commaMapEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-pre_obj_right"><code>StructuredArrow.pre_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-small_proj_preimage_of_locallySmall"><code>StructuredArrow.small_proj_preimage_of_locallySmall</code></a>, <a href="#CategoryTheory-Functor-structuredArrowMapCone_œÄ_app"><code>Functor.structuredArrowMapCone_œÄ_app</code></a>, <a href="#CategoryTheory-Localization-structuredArrowEquiv_apply"><code>Localization.structuredArrowEquiv_apply</code></a><br></details></td></tr>
</table>
<h2>CategoryTheory.Localization</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L46" id="CategoryTheory-Localization-structuredArrowEquiv"><code>structuredArrowEquiv</code></a> <a href="../api/Mathlib/CategoryTheory/Localization/StructuredArrow.html#CategoryTheory.Localization.structuredArrowEquiv" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Localization-structuredArrowEquiv_symm_apply"><code>structuredArrowEquiv_symm_apply</code></a>, <a href="#CategoryTheory-Localization-structuredArrowEquiv_apply"><code>structuredArrowEquiv_apply</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L126" id="CategoryTheory-Localization-induction_costructuredArrow"><code>induction_costructuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Localization/StructuredArrow.html#CategoryTheory.Localization.induction_costructuredArrow" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Localization-isoOfHom"><code>isoOfHom</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Localization-induction_structuredArrow"><code>induction_structuredArrow</code></a><br><a href="#CategoryTheory-Functor-IsLocalization-op"><code>CategoryTheory.Functor.IsLocalization.op</code></a><br><a href="#CategoryTheory-Localization-isoOfHom_op_inv"><code>isoOfHom_op_inv</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L98" id="CategoryTheory-Localization-induction_structuredArrow"><code>induction_structuredArrow</code></a> <a href="../api/Mathlib/CategoryTheory/Localization/StructuredArrow.html#CategoryTheory.Localization.induction_structuredArrow" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Localization-isoOfHom"><code>isoOfHom</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-q_isLocalization"><code>CategoryTheory.Functor.q_isLocalization</code></a><br><a href="#Equiv-apply_symm_apply"><code>Equiv.apply_symm_apply</code></a><br><a href="#CategoryTheory-Localization-homEquiv_id"><code>homEquiv_id</code></a><br><a href="#CategoryTheory-Localization-homEquiv_comp"><code>homEquiv_comp</code></a><br><a href="#CategoryTheory-Localization-homEquiv_map"><code>homEquiv_map</code></a><br><a href="#CategoryTheory-Localization-homEquiv_isoOfHom_inv"><code>homEquiv_isoOfHom_inv</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L45" id="CategoryTheory-Localization-structuredArrowEquiv_apply"><code>structuredArrowEquiv_apply</code></a> <a href="../api/Mathlib/CategoryTheory/Localization/StructuredArrow.html#CategoryTheory.Localization.structuredArrowEquiv_apply" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#Equiv"><code>Equiv</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#EquivLike-toFunLike"><code>EquivLike.toFunLike</code></a><br><a href="#Equiv-instEquivLike"><code>Equiv.instEquivLike</code></a><br><a href="#CategoryTheory-Localization-structuredArrowEquiv"><code>structuredArrowEquiv</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Localization-homEquiv"><code>homEquiv</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Localization/StructuredArrow.lean#L45" id="CategoryTheory-Localization-structuredArrowEquiv_symm_apply"><code>structuredArrowEquiv_symm_apply</code></a> <a href="../api/Mathlib/CategoryTheory/Localization/StructuredArrow.html#CategoryTheory.Localization.structuredArrowEquiv_symm_apply" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#DFunLike-coe"><code>DFunLike.coe</code></a><br><a href="#Equiv"><code>Equiv</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#EquivLike-toFunLike"><code>EquivLike.toFunLike</code></a><br><a href="#Equiv-instEquivLike"><code>Equiv.instEquivLike</code></a><br><a href="#Equiv-symm"><code>Equiv.symm</code></a><br><a href="#CategoryTheory-Localization-structuredArrowEquiv"><code>structuredArrowEquiv</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Localization-homEquiv"><code>homEquiv</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<p>---</p>
<p><a href="index.html">‚Üê Back to Index</a></p>
    </div>
  </main>
</body>
</html>