<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_CategoryTheory_Functor_Flat - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_CategoryTheory_Functor_Flat
      </nav>
      <h1>Flat</h1>
<p>ğŸ“ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean">Mathlib/CategoryTheory/Functor/Flat.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a>, <a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a>, <a href="#CategoryTheory-lanEvaluationIsoColim"><code>lanEvaluationIsoColim</code></a></details></td><td>3</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#CategoryTheory-PreservesFiniteLimitsOfFlat-fac"><code>fac</code></a>, <a href="#CategoryTheory-PreservesFiniteLimitsOfFlat-uniq"><code>uniq</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-comp"><code>comp</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>filtered</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-id"><code>id</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-of_isLeftAdjoint"><code>of_isLeftAdjoint</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-of_iso"><code>of_iso</code></a>, <a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>cofiltered</code></a>, <a href="#CategoryTheory-RepresentablyFlat-comp"><code>comp</code></a>, <a href="#CategoryTheory-RepresentablyFlat-id"><code>id</code></a>, <a href="#CategoryTheory-RepresentablyFlat-of_isRightAdjoint"><code>of_isRightAdjoint</code></a>, <a href="#CategoryTheory-RepresentablyFlat-of_iso"><code>of_iso</code></a>, <a href="#CategoryTheory-coflat_of_preservesFiniteColimits"><code>coflat_of_preservesFiniteColimits</code></a>, <a href="#CategoryTheory-final_of_representablyFlat"><code>final_of_representablyFlat</code></a>, <a href="#CategoryTheory-flat_iff_lan_flat"><code>flat_iff_lan_flat</code></a>, <a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-initial_of_representablyCoflat"><code>initial_of_representablyCoflat</code></a>, <a href="#CategoryTheory-instFinalStructuredArrowCompPreOfRepresentablyFlat"><code>instFinalStructuredArrowCompPreOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowCompPreOfRepresentablyCoflat"><code>instInitialCostructuredArrowCompPreOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-instIsCofilteredElementsCompOfRepresentablyFlat"><code>instIsCofilteredElementsCompOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-instIsFilteredCostructuredArrowCompOfRepresentablyCoflat"><code>instIsFilteredCostructuredArrowCompOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-instRepresentablyCoflatOppositeOpOfRepresentablyFlat"><code>instRepresentablyCoflatOppositeOpOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-lan_flat_of_flat"><code>lan_flat_of_flat</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>lan_preservesFiniteLimits_of_flat</code></a>, <a href="#CategoryTheory-lan_preservesFiniteLimits_of_preservesFiniteLimits"><code>lan_preservesFiniteLimits_of_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-preservesFiniteColimits_iff_coflat"><code>preservesFiniteColimits_iff_coflat</code></a>, <a href="#CategoryTheory-preservesFiniteColimits_of_coflat"><code>preservesFiniteColimits_of_coflat</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_iff_flat"><code>preservesFiniteLimits_iff_flat</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_iff_lan_preservesFiniteLimits"><code>preservesFiniteLimits_iff_lan_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_of_flat"><code>preservesFiniteLimits_of_flat</code></a>, <a href="#CategoryTheory-representablyCoflat_op_iff"><code>representablyCoflat_op_iff</code></a>, <a href="#CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a></details></td><td>34</td></tr>
<tr><td><strong>Total</strong></td><td><strong>37</strong></td></tr>
</table>
<h2>CategoryTheory</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L75" id="CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat" title="API Documentation">ğŸ“–</a></td><td>CompData</td><td><details><summary>10 math</summary><strong>math:</strong> <a href="#CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-of_isLeftAdjoint"><code>RepresentablyCoflat.of_isLeftAdjoint</code></a>, <a href="#CategoryTheory-instRepresentablyCoflatOppositeOpOfRepresentablyFlat"><code>instRepresentablyCoflatOppositeOpOfRepresentablyFlat</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-comp"><code>RepresentablyCoflat.comp</code></a>, <a href="#CategoryTheory-preservesFiniteColimits_iff_coflat"><code>preservesFiniteColimits_iff_coflat</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-id"><code>RepresentablyCoflat.id</code></a>, <a href="#CategoryTheory-RepresentablyCoflat-of_iso"><code>RepresentablyCoflat.of_iso</code></a>, <a href="#CategoryTheory-coflat_of_preservesFiniteColimits"><code>coflat_of_preservesFiniteColimits</code></a>, <a href="#CategoryTheory-instRepresentablyCoflatIndYoneda"><code>instRepresentablyCoflatIndYoneda</code></a>, <a href="#CategoryTheory-representablyCoflat_op_iff"><code>representablyCoflat_op_iff</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L70" id="CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat" title="API Documentation">ğŸ“–</a></td><td>CompData</td><td><details><summary>12 math</summary><strong>math:</strong> <a href="#CategoryTheory-RepresentablyFlat-comp"><code>RepresentablyFlat.comp</code></a>, <a href="#CategoryTheory-RepresentablyFlat-of_isRightAdjoint"><code>RepresentablyFlat.of_isRightAdjoint</code></a>, <a href="#CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a>, <a href="#CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a>, <a href="#CategoryTheory-RepresentablyFlat-of_iso"><code>RepresentablyFlat.of_iso</code></a>, <a href="#CategoryTheory-flat_iff_lan_flat"><code>flat_iff_lan_flat</code></a>, <a href="#CategoryTheory-lan_flat_of_flat"><code>lan_flat_of_flat</code></a>, <a href="#CategoryTheory-RepresentablyFlat-id"><code>RepresentablyFlat.id</code></a>, <a href="#CategoryTheory-preservesFiniteLimits_iff_flat"><code>preservesFiniteLimits_iff_flat</code></a>, <a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a>, <a href="#CategoryTheory-representablyCoflat_op_iff"><code>representablyCoflat_op_iff</code></a>, <a href="#instRepresentablyFlatOpensCarrierMap"><code>instRepresentablyFlatOpensCarrierMap</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L298" id="CategoryTheory-lanEvaluationIsoColim"><code>lanEvaluationIsoColim</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lanEvaluationIsoColim" title="API Documentation">ğŸ“–</a></td><td>CompOp</td><td>â€”</td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L170" id="CategoryTheory-coflat_of_preservesFiniteColimits"><code>coflat_of_preservesFiniteColimits</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.coflat_of_preservesFiniteColimits" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Limits-preservesFiniteLimits_op"><code>Limits.preservesFiniteLimits_op</code></a><br><a href="#CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a><br><a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-hasFiniteLimits_opposite"><code>Limits.hasFiniteLimits_opposite</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L150" id="CategoryTheory-final_of_representablyFlat"><code>final_of_representablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.final_of_representablyFlat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Functor-Final"><code>Functor.Final</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-isConnected"><code>IsCofiltered.isConnected</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L347" id="CategoryTheory-flat_iff_lan_flat"><code>flat_iff_lan_flat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.flat_iff_lan_flat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a><br><a href="#CategoryTheory-Functor"><code>Functor</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-types"><code>types</code></a><br><a href="#CategoryTheory-Functor-category"><code>Functor.category</code></a><br><a href="#CategoryTheory-Functor-lan"><code>Functor.lan</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimit"><code>Limits.Types.hasColimit</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#UnivLE-small"><code>UnivLE.small</code></a><br><a href="#UnivLE-self"><code>UnivLE.self</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CostructuredArrow.proj</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimit"><code>Limits.Types.hasColimit</code></a><br><a href="#UnivLE-small"><code>UnivLE.small</code></a><br><a href="#UnivLE-self"><code>UnivLE.self</code></a><br><a href="#CategoryTheory-lan_flat_of_flat"><code>lan_flat_of_flat</code></a><br><a href="#CategoryTheory-Limits-Types-hasLimitsOfSize"><code>Limits.Types.hasLimitsOfSize</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimitsOfSize"><code>Limits.Types.hasColimitsOfSize</code></a><br><a href="#CategoryTheory-Types-instReflectsLimitsOfSizeForgetTypeHom"><code>Types.instReflectsLimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-Limits-PreservesColimits-preservesFilteredColimits"><code>Limits.PreservesColimits.preservesFilteredColimits</code></a><br><a href="#CategoryTheory-Types-instPreservesColimitsOfSizeForgetTypeHom"><code>Types.instPreservesColimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-Types-instPreservesLimitsOfSizeForgetTypeHom"><code>Types.instPreservesLimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-preservesFiniteLimits_of_preservesFiniteLimitsOfSize"><code>Limits.preservesFiniteLimits_of_preservesFiniteLimitsOfSize</code></a><br><a href="#CategoryTheory-preservesLimit_of_lan_preservesLimit"><code>preservesLimit_of_lan_preservesLimit</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShapeOfPreservesFiniteLimits"><code>Limits.preservesLimitsOfShapeOfPreservesFiniteLimits</code></a><br><a href="#CategoryTheory-preservesFiniteLimits_of_flat"><code>preservesFiniteLimits_of_flat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L162" id="CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.flat_of_preservesFiniteLimits" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_hasFiniteLimits"><code>IsCofiltered.of_hasFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-hasFiniteLimits_of_hasFiniteLimits_of_size"><code>Limits.hasFiniteLimits_of_hasFiniteLimits_of_size</code></a><br><a href="#CategoryTheory-StructuredArrow-hasLimit"><code>StructuredArrow.hasLimit</code></a><br><a href="#CategoryTheory-Limits-hasLimitOfHasLimitsOfShape"><code>Limits.hasLimitOfHasLimitsOfShape</code></a><br><a href="#CategoryTheory-Limits-hasLimitsOfShape_of_hasFiniteLimits"><code>Limits.hasLimitsOfShape_of_hasFiniteLimits</code></a><br><a href="#CategoryTheory-preservesLimit_comp_of_createsLimit"><code>preservesLimit_comp_of_createsLimit</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShapeOfPreservesFiniteLimits"><code>Limits.preservesLimitsOfShapeOfPreservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-PreservesLimitsOfShape-preservesLimit"><code>Limits.PreservesLimitsOfShape.preservesLimit</code></a><br><a href="#CategoryTheory-Limits-comp_preservesLimitsOfShape"><code>Limits.comp_preservesLimitsOfShape</code></a><br><a href="#CategoryTheory-preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape"><code>preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L153" id="CategoryTheory-initial_of_representablyCoflat"><code>initial_of_representablyCoflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.initial_of_representablyCoflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Functor-Initial"><code>Functor.Initial</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered-isConnected"><code>IsFiltered.isConnected</code></a><br><a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>RepresentablyCoflat.filtered</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L373" id="CategoryTheory-instFinalStructuredArrowCompPreOfRepresentablyFlat"><code>instFinalStructuredArrowCompPreOfRepresentablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instFinalStructuredArrowCompPreOfRepresentablyFlat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Functor-Final"><code>Functor.Final</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-pre"><code>StructuredArrow.pre</code></a></td><td>â€”</td><td><a href="#CategoryTheory-isConnected_of_equivalent"><code>isConnected_of_equivalent</code></a><br><a href="#CategoryTheory-IsCofiltered-isConnected"><code>IsCofiltered.isConnected</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L376" id="CategoryTheory-instInitialCostructuredArrowCompPreOfRepresentablyCoflat"><code>instInitialCostructuredArrowCompPreOfRepresentablyCoflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instInitialCostructuredArrowCompPreOfRepresentablyCoflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Functor-Initial"><code>Functor.Initial</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-pre"><code>CostructuredArrow.pre</code></a></td><td>â€”</td><td><a href="#CategoryTheory-isConnected_of_equivalent"><code>isConnected_of_equivalent</code></a><br><a href="#CategoryTheory-IsFiltered-isConnected"><code>IsFiltered.isConnected</code></a><br><a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>RepresentablyCoflat.filtered</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L414" id="CategoryTheory-instIsCofilteredElementsCompOfRepresentablyFlat"><code>instIsCofilteredElementsCompOfRepresentablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instIsCofilteredElementsCompOfRepresentablyFlat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered"><code>IsCofiltered</code></a><br><a href="#CategoryTheory-Functor-Elements"><code>Functor.Elements</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-types"><code>types</code></a><br><a href="#CategoryTheory-categoryOfElements"><code>categoryOfElements</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_equivalence"><code>IsCofiltered.of_equivalence</code></a><br><a href="#CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L380" id="CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instIsCofilteredStructuredArrowCompOfRepresentablyFlat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered"><code>IsCofiltered</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>StructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>instCategoryStructuredArrow</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-nonempty"><code>IsCofiltered.nonempty</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a><br><a href="#CategoryTheory-IsCofiltered-toIsCofilteredOrEmpty"><code>IsCofiltered.toIsCofilteredOrEmpty</code></a><br><a href="#CategoryTheory-Category-assoc"><code>Category.assoc</code></a><br><a href="#CategoryTheory-StructuredArrow-w"><code>StructuredArrow.w</code></a><br><a href="#CategoryTheory-IsCofiltered-eq_condition"><code>IsCofiltered.eq_condition</code></a><br><a href="#CategoryTheory-StructuredArrow-hom_ext"><code>StructuredArrow.hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L408" id="CategoryTheory-instIsFilteredCostructuredArrowCompOfRepresentablyCoflat"><code>instIsFilteredCostructuredArrowCompOfRepresentablyCoflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instIsFilteredCostructuredArrowCompOfRepresentablyCoflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered"><code>IsFiltered</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a></td><td>â€”</td><td><a href="#CategoryTheory-isCofiltered_op_iff_isFiltered"><code>isCofiltered_op_iff_isFiltered</code></a><br><a href="#CategoryTheory-IsCofiltered-iff_of_equivalence"><code>IsCofiltered.iff_of_equivalence</code></a><br><a href="#CategoryTheory-instIsCofilteredStructuredArrowCompOfRepresentablyFlat"><code>instIsCofilteredStructuredArrowCompOfRepresentablyFlat</code></a><br><a href="#CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L140" id="CategoryTheory-instRepresentablyCoflatOppositeOpOfRepresentablyFlat"><code>instRepresentablyCoflatOppositeOpOfRepresentablyFlat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instRepresentablyCoflatOppositeOpOfRepresentablyFlat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a></td><td>â€”</td><td><a href="#CategoryTheory-representablyCoflat_op_iff"><code>representablyCoflat_op_iff</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L143" id="CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.instRepresentablyFlatOppositeOpOfRepresentablyCoflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a></td><td>â€”</td><td><a href="#CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L336" id="CategoryTheory-lan_flat_of_flat"><code>lan_flat_of_flat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lan_flat_of_flat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a><br><a href="#CategoryTheory-Functor"><code>Functor</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-category"><code>Functor.category</code></a><br><a href="#CategoryTheory-Functor-lan"><code>Functor.lan</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CostructuredArrow.proj</code></a></td><td>â€”</td><td><a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-hasFiniteLimits_of_hasLimits"><code>Limits.hasFiniteLimits_of_hasLimits</code></a><br><a href="#CategoryTheory-Limits-functorCategoryHasLimitsOfSize"><code>Limits.functorCategoryHasLimitsOfSize</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>lan_preservesFiniteLimits_of_flat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L326" id="CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>lan_preservesFiniteLimits_of_flat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lan_preservesFiniteLimits_of_flat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Limits-PreservesFiniteLimits"><code>Limits.PreservesFiniteLimits</code></a><br><a href="#CategoryTheory-Functor"><code>Functor</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-category"><code>Functor.category</code></a><br><a href="#CategoryTheory-Functor-lan"><code>Functor.lan</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CostructuredArrow.proj</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Limits-preservesFiniteLimits_of_preservesFiniteLimitsOfSize"><code>Limits.preservesFiniteLimits_of_preservesFiniteLimitsOfSize</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShape_of_evaluation"><code>Limits.preservesLimitsOfShape_of_evaluation</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShape_of_natIso"><code>Limits.preservesLimitsOfShape_of_natIso</code></a><br><a href="#CategoryTheory-Limits-comp_preservesLimitsOfShape"><code>Limits.comp_preservesLimitsOfShape</code></a><br><a href="#CategoryTheory-whiskeringLeft_preservesLimitsOfShape"><code>whiskeringLeft_preservesLimitsOfShape</code></a><br><a href="#CategoryTheory-Limits-hasLimitsOfShape_of_hasFiniteLimits"><code>Limits.hasLimitsOfShape_of_hasFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-hasFiniteLimits_of_hasLimits"><code>Limits.hasFiniteLimits_of_hasLimits</code></a><br><a href="#CategoryTheory-Limits-filtered_colim_preservesFiniteLimits"><code>Limits.filtered_colim_preservesFiniteLimits</code></a><br><a href="#UnivLE-small"><code>UnivLE.small</code></a><br><a href="#UnivLE-self"><code>UnivLE.self</code></a><br><a href="#CategoryTheory-IsFiltered-of_equivalence"><code>IsFiltered.of_equivalence</code></a><br><a href="#CategoryTheory-isFiltered_op_of_isCofiltered"><code>isFiltered_op_of_isCofiltered</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a><br><a href="#CategoryTheory-Limits-reflectsLimitsOfShape_of_reflectsLimits"><code>Limits.reflectsLimitsOfShape_of_reflectsLimits</code></a><br><a href="#CategoryTheory-Limits-PreservesFilteredColimitsOfSize-preserves_filtered_colimits"><code>Limits.PreservesFilteredColimitsOfSize.preserves_filtered_colimits</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShapeOfPreservesFiniteLimits"><code>Limits.preservesLimitsOfShapeOfPreservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-PreservesLimits-preservesFiniteLimits"><code>Limits.PreservesLimits.preservesFiniteLimits</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L342" id="CategoryTheory-lan_preservesFiniteLimits_of_preservesFiniteLimits"><code>lan_preservesFiniteLimits_of_preservesFiniteLimits</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.lan_preservesFiniteLimits_of_preservesFiniteLimits" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Limits-PreservesFiniteLimits"><code>Limits.PreservesFiniteLimits</code></a><br><a href="#CategoryTheory-Functor"><code>Functor</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-category"><code>Functor.category</code></a><br><a href="#CategoryTheory-Functor-lan"><code>Functor.lan</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CostructuredArrow.proj</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-hasColimitOfHasColimitsOfShape"><code>Limits.hasColimitOfHasColimitsOfShape</code></a><br><a href="#CategoryTheory-Limits-hasColimitsOfShapeOfHasColimitsOfSize"><code>Limits.hasColimitsOfShapeOfHasColimitsOfSize</code></a><br><a href="#CategoryTheory-lan_preservesFiniteLimits_of_flat"><code>lan_preservesFiniteLimits_of_flat</code></a><br><a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L283" id="CategoryTheory-preservesFiniteColimits_iff_coflat"><code>preservesFiniteColimits_iff_coflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteColimits_iff_coflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a><br><a href="#CategoryTheory-Limits-PreservesFiniteColimits"><code>Limits.PreservesFiniteColimits</code></a></td><td>â€”</td><td><a href="#CategoryTheory-preservesFiniteColimits_of_coflat"><code>preservesFiniteColimits_of_coflat</code></a><br><a href="#CategoryTheory-coflat_of_preservesFiniteColimits"><code>coflat_of_preservesFiniteColimits</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L269" id="CategoryTheory-preservesFiniteColimits_of_coflat"><code>preservesFiniteColimits_of_coflat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteColimits_of_coflat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Limits-PreservesFiniteColimits"><code>Limits.PreservesFiniteColimits</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Limits-preservesFiniteColimits_of_op"><code>Limits.preservesFiniteColimits_of_op</code></a><br><a href="#CategoryTheory-preservesFiniteLimits_of_flat"><code>preservesFiniteLimits_of_flat</code></a><br><a href="#CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L277" id="CategoryTheory-preservesFiniteLimits_iff_flat"><code>preservesFiniteLimits_iff_flat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimits_iff_flat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a><br><a href="#CategoryTheory-Limits-PreservesFiniteLimits"><code>Limits.PreservesFiniteLimits</code></a></td><td>â€”</td><td><a href="#CategoryTheory-preservesFiniteLimits_of_flat"><code>preservesFiniteLimits_of_flat</code></a><br><a href="#CategoryTheory-flat_of_preservesFiniteLimits"><code>flat_of_preservesFiniteLimits</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L359" id="CategoryTheory-preservesFiniteLimits_iff_lan_preservesFiniteLimits"><code>preservesFiniteLimits_iff_lan_preservesFiniteLimits</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimits_iff_lan_preservesFiniteLimits" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Limits-PreservesFiniteLimits"><code>Limits.PreservesFiniteLimits</code></a><br><a href="#CategoryTheory-Functor"><code>Functor</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-types"><code>types</code></a><br><a href="#CategoryTheory-Functor-category"><code>Functor.category</code></a><br><a href="#CategoryTheory-Functor-lan"><code>Functor.lan</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimit"><code>Limits.Types.hasColimit</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>instCategoryCostructuredArrow</code></a><br><a href="#UnivLE-small"><code>UnivLE.small</code></a><br><a href="#UnivLE-self"><code>UnivLE.self</code></a><br><a href="#CategoryTheory-Functor-comp"><code>Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CostructuredArrow.proj</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Functor-instHasLeftKanExtension"><code>Functor.instHasLeftKanExtension</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimit"><code>Limits.Types.hasColimit</code></a><br><a href="#UnivLE-small"><code>UnivLE.small</code></a><br><a href="#UnivLE-self"><code>UnivLE.self</code></a><br><a href="#CategoryTheory-lan_preservesFiniteLimits_of_preservesFiniteLimits"><code>lan_preservesFiniteLimits_of_preservesFiniteLimits</code></a><br><a href="#CategoryTheory-Limits-Types-hasLimitsOfSize"><code>Limits.Types.hasLimitsOfSize</code></a><br><a href="#CategoryTheory-Limits-Types-hasColimitsOfSize"><code>Limits.Types.hasColimitsOfSize</code></a><br><a href="#CategoryTheory-Types-instReflectsLimitsOfSizeForgetTypeHom"><code>Types.instReflectsLimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-Limits-PreservesColimits-preservesFilteredColimits"><code>Limits.PreservesColimits.preservesFilteredColimits</code></a><br><a href="#CategoryTheory-Types-instPreservesColimitsOfSizeForgetTypeHom"><code>Types.instPreservesColimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-Types-instPreservesLimitsOfSizeForgetTypeHom"><code>Types.instPreservesLimitsOfSizeForgetTypeHom</code></a><br><a href="#CategoryTheory-Limits-preservesFiniteLimits_of_preservesFiniteLimitsOfSize"><code>Limits.preservesFiniteLimits_of_preservesFiniteLimitsOfSize</code></a><br><a href="#CategoryTheory-preservesLimit_of_lan_preservesLimit"><code>preservesLimit_of_lan_preservesLimit</code></a><br><a href="#CategoryTheory-Limits-preservesLimitsOfShapeOfPreservesFiniteLimits"><code>Limits.preservesLimitsOfShapeOfPreservesFiniteLimits</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L253" id="CategoryTheory-preservesFiniteLimits_of_flat"><code>preservesFiniteLimits_of_flat</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.preservesFiniteLimits_of_flat" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-Limits-PreservesFiniteLimits"><code>Limits.PreservesFiniteLimits</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Limits-preservesFiniteLimits_of_preservesFiniteLimitsOfSize"><code>Limits.preservesFiniteLimits_of_preservesFiniteLimitsOfSize</code></a><br><a href="#CategoryTheory-PreservesFiniteLimitsOfFlat-fac"><code>PreservesFiniteLimitsOfFlat.fac</code></a><br><a href="#CategoryTheory-PreservesFiniteLimitsOfFlat-uniq"><code>PreservesFiniteLimitsOfFlat.uniq</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L122" id="CategoryTheory-representablyCoflat_op_iff"><code>representablyCoflat_op_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.representablyCoflat_op_iff" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered-of_equivalence"><code>IsFiltered.of_equivalence</code></a><br><a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>RepresentablyCoflat.filtered</code></a><br><a href="#CategoryTheory-isCofiltered_of_isFiltered_op"><code>isCofiltered_of_isFiltered_op</code></a><br><a href="#CategoryTheory-IsCofiltered-of_equivalence"><code>IsCofiltered.of_equivalence</code></a><br><a href="#CategoryTheory-isCofiltered_op_of_isFiltered"><code>isCofiltered_op_of_isFiltered</code></a><br><a href="#CategoryTheory-isFiltered_op_of_isCofiltered"><code>isFiltered_op_of_isCofiltered</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a><br><a href="#CategoryTheory-isFiltered_of_isCofiltered_op"><code>isFiltered_of_isCofiltered_op</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L131" id="CategoryTheory-representablyFlat_op_iff"><code>representablyFlat_op_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.representablyFlat_op_iff" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>RepresentablyFlat</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>Category.opposite</code></a><br><a href="#CategoryTheory-Functor-op"><code>Functor.op</code></a><br><a href="#CategoryTheory-RepresentablyCoflat"><code>RepresentablyCoflat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_equivalence"><code>IsCofiltered.of_equivalence</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>RepresentablyFlat.cofiltered</code></a><br><a href="#CategoryTheory-isFiltered_of_isCofiltered_op"><code>isFiltered_of_isCofiltered_op</code></a><br><a href="#CategoryTheory-IsFiltered-of_equivalence"><code>IsFiltered.of_equivalence</code></a><br><a href="#CategoryTheory-isFiltered_op_of_isCofiltered"><code>isFiltered_op_of_isCofiltered</code></a><br><a href="#CategoryTheory-isCofiltered_op_of_isFiltered"><code>isCofiltered_op_of_isFiltered</code></a><br><a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>RepresentablyCoflat.filtered</code></a><br><a href="#CategoryTheory-isCofiltered_of_isFiltered_op"><code>isCofiltered_of_isFiltered_op</code></a></td></tr>
</table>
<h2>CategoryTheory.PreservesFiniteLimitsOfFlat</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L197" id="CategoryTheory-PreservesFiniteLimitsOfFlat-fac"><code>fac</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.PreservesFiniteLimitsOfFlat.fac" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Limits-Cone-pt"><code>CategoryTheory.Limits.Cone.pt</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-PreservesFiniteLimitsOfFlat-lift"><code>lift</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-mapCone"><code>CategoryTheory.Functor.mapCone</code></a><br><a href="#CategoryTheory-Limits-Cone-Ï€"><code>CategoryTheory.Limits.Cone.Ï€</code></a></td><td>â€”</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Limits-IsLimit-fac"><code>CategoryTheory.Limits.IsLimit.fac</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-StructuredArrow-w"><code>CategoryTheory.StructuredArrow.w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L201" id="CategoryTheory-PreservesFiniteLimitsOfFlat-uniq"><code>uniq</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.PreservesFiniteLimitsOfFlat.uniq" title="API Documentation">ğŸ“–</a></td><td>â€”</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Limits-Cone-pt"><code>CategoryTheory.Limits.Cone.pt</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Functor-mapCone"><code>CategoryTheory.Functor.mapCone</code></a><br><a href="#CategoryTheory-Limits-Cone-Ï€"><code>CategoryTheory.Limits.Cone.Ï€</code></a></td><td>â€”</td><td>â€”</td><td><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>CategoryTheory.StructuredArrow.eqToHom_right</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>CategoryTheory.RepresentablyFlat.cofiltered</code></a><br><a href="#CategoryTheory-NatTrans-naturality"><code>CategoryTheory.NatTrans.naturality</code></a><br><a href="#CategoryTheory-Limits-Cone-w"><code>CategoryTheory.Limits.Cone.w</code></a><br><a href="#CategoryTheory-NatTrans-ext'"><code>CategoryTheory.NatTrans.ext'</code></a><br><a href="#CategoryTheory-Limits-IsLimit-uniq"><code>CategoryTheory.Limits.IsLimit.uniq</code></a><br><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a></td></tr>
</table>
<h2>CategoryTheory.RepresentablyCoflat</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L146" id="CategoryTheory-RepresentablyCoflat-comp"><code>comp</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat.comp" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>CategoryTheory.RepresentablyCoflat</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>â€”</td><td><a href="#CategoryTheory-representablyFlat_op_iff"><code>CategoryTheory.representablyFlat_op_iff</code></a><br><a href="#CategoryTheory-RepresentablyFlat-comp"><code>CategoryTheory.RepresentablyFlat.comp</code></a><br><a href="#CategoryTheory-instRepresentablyFlatOppositeOpOfRepresentablyCoflat"><code>CategoryTheory.instRepresentablyFlatOppositeOpOfRepresentablyCoflat</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L76" id="CategoryTheory-RepresentablyCoflat-filtered"><code>filtered</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat.filtered" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered"><code>CategoryTheory.IsFiltered</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a></td><td>â€”</td><td>â€”</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L90" id="CategoryTheory-RepresentablyCoflat-id"><code>id</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat.id" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>CategoryTheory.RepresentablyCoflat</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat-of_isLeftAdjoint"><code>of_isLeftAdjoint</code></a><br><a href="#CategoryTheory-Functor-isLeftAdjoint_of_isEquivalence"><code>CategoryTheory.Functor.isLeftAdjoint_of_isEquivalence</code></a><br><a href="#CategoryTheory-Functor-isEquivalence_refl"><code>CategoryTheory.Functor.isEquivalence_refl</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L85" id="CategoryTheory-RepresentablyCoflat-of_isLeftAdjoint"><code>of_isLeftAdjoint</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat.of_isLeftAdjoint" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>CategoryTheory.RepresentablyCoflat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered-of_isTerminal"><code>CategoryTheory.IsFiltered.of_isTerminal</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L116" id="CategoryTheory-RepresentablyCoflat-of_iso"><code>of_iso</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyCoflat.of_iso" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyCoflat"><code>CategoryTheory.RepresentablyCoflat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsFiltered-of_equivalence"><code>CategoryTheory.IsFiltered.of_equivalence</code></a><br><a href="#CategoryTheory-RepresentablyCoflat-filtered"><code>filtered</code></a></td></tr>
</table>
<h2>CategoryTheory.RepresentablyFlat</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L71" id="CategoryTheory-RepresentablyFlat-cofiltered"><code>cofiltered</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.cofiltered" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered"><code>CategoryTheory.IsCofiltered</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a></td><td>â€”</td><td>â€”</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L93" id="CategoryTheory-RepresentablyFlat-comp"><code>comp</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.comp" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>CategoryTheory.RepresentablyFlat</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_cone_nonempty"><code>CategoryTheory.IsCofiltered.of_cone_nonempty</code></a><br><a href="#CategoryTheory-IsCofiltered-cone_nonempty"><code>CategoryTheory.IsCofiltered.cone_nonempty</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>cofiltered</code></a><br><a href="#CategoryTheory-Limits-Cone-w"><code>CategoryTheory.Limits.Cone.w</code></a><br><a href="#CategoryTheory-Functor-map_id"><code>CategoryTheory.Functor.map_id</code></a><br><a href="#CategoryTheory-StructuredArrow-homMk-congr_simp"><code>CategoryTheory.StructuredArrow.homMk.congr_simp</code></a><br><a href="#CategoryTheory-Functor-map_comp"><code>CategoryTheory.Functor.map_comp</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-StructuredArrow-w"><code>CategoryTheory.StructuredArrow.w</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L88" id="CategoryTheory-RepresentablyFlat-id"><code>id</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.id" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>CategoryTheory.RepresentablyFlat</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat-of_isRightAdjoint"><code>of_isRightAdjoint</code></a><br><a href="#CategoryTheory-Functor-isRightAdjoint_of_isEquivalence"><code>CategoryTheory.Functor.isRightAdjoint_of_isEquivalence</code></a><br><a href="#CategoryTheory-Functor-isEquivalence_refl"><code>CategoryTheory.Functor.isEquivalence_refl</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L82" id="CategoryTheory-RepresentablyFlat-of_isRightAdjoint"><code>of_isRightAdjoint</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.of_isRightAdjoint" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>CategoryTheory.RepresentablyFlat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_isInitial"><code>CategoryTheory.IsCofiltered.of_isInitial</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Functor/Flat.lean#L112" id="CategoryTheory-RepresentablyFlat-of_iso"><code>of_iso</code></a> <a href="../api/Mathlib/CategoryTheory/Functor/Flat.html#CategoryTheory.RepresentablyFlat.of_iso" title="API Documentation">ğŸ“–</a></td><td>mathematical</td><td>â€”</td><td><a href="#CategoryTheory-RepresentablyFlat"><code>CategoryTheory.RepresentablyFlat</code></a></td><td>â€”</td><td><a href="#CategoryTheory-IsCofiltered-of_equivalence"><code>CategoryTheory.IsCofiltered.of_equivalence</code></a><br><a href="#CategoryTheory-RepresentablyFlat-cofiltered"><code>cofiltered</code></a></td></tr>
</table>
<p>---</p>
<p><a href="index.html">â† Back to Index</a></p>
    </div>
  </main>
</body>
</html>