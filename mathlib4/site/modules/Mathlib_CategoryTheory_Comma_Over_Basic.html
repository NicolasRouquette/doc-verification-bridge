<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mathlib_CategoryTheory_Comma_Over_Basic - Documentation Verification</title>
  <link rel="stylesheet" href="../style.css">
  <script defer src="../verification.js"></script>
</head>
<body>
  <header>
    <h1>Documentation Verification Report</h1>
    <nav>
      <a href="../index.html">Overview</a>
      <a href="index.html">Modules</a>
      <a href="../search.html">Search</a>
      <a href="../api/index.html">API Docs</a>
    </nav>
  </header>
  <main>
    <div class="container">
      <nav class="breadcrumbs">
        <a href="../index.html">Verification</a> /
        <a href="index.html">Modules</a> /
        Mathlib_CategoryTheory_Comma_Over_Basic
      </nav>
      <h1>Basic</h1>
<p>üìÅ <strong>Source:</strong> <a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean">Mathlib/CategoryTheory/Comma/Over/Basic.lean</a></p>
<h2>Statistics</h2>
<table class="verification-table">
<tr><th>Metric</th><th>Count</th></tr>
<tr><td><details><summary>Definitions</summary><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence"><code>costructuredArrowToOverEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence"><code>ofCostructuredArrowProjEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence"><code>ofDiagEquivalence</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence'"><code>ofDiagEquivalence'</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a>, <a href="#CategoryTheory-Functor-FullyFaithful-over"><code>over</code></a>, <a href="#CategoryTheory-Functor-FullyFaithful-under"><code>under</code></a>, <a href="#CategoryTheory-Functor-toOver"><code>toOver</code></a>, <a href="#CategoryTheory-Functor-toOverCompForget"><code>toOverCompForget</code></a>, <a href="#CategoryTheory-Functor-toUnder"><code>toUnder</code></a>, <a href="#CategoryTheory-Functor-toUnderCompForget"><code>toUnderCompForget</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost"><code>underPost</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost"><code>overPost</code></a>, <a href="#CategoryTheory-Over-coeFromHom"><code>coeFromHom</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a>, <a href="#CategoryTheory-Over-forget"><code>forget</code></a>, <a href="#CategoryTheory-Over-forgetCocone"><code>forgetCocone</code></a>, <a href="#CategoryTheory-Over-homMk"><code>homMk</code></a>, <a href="#CategoryTheory-Over-inhabited"><code>inhabited</code></a>, <a href="#CategoryTheory-Over-isLimitLiftCone"><code>isLimitLiftCone</code></a>, <a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso"><code>iteratedSliceEquivOverMapIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost"><code>iteratedSliceForwardIsoPost</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso"><code>iteratedSliceForwardNaturalityIso</code></a>, <a href="#CategoryTheory-Over-liftCone"><code>liftCone</code></a>, <a href="#CategoryTheory-Over-map"><code>map</code></a>, <a href="#CategoryTheory-Over-mapComp"><code>mapComp</code></a>, <a href="#CategoryTheory-Over-mapCongr"><code>mapCongr</code></a>, <a href="#CategoryTheory-Over-mapForget"><code>mapForget</code></a>, <a href="#CategoryTheory-Over-mapFunctor"><code>mapFunctor</code></a>, <a href="#CategoryTheory-Over-mapId"><code>mapId</code></a>, <a href="#CategoryTheory-Over-mapIso"><code>mapIso</code></a>, <a href="#CategoryTheory-Over-mk"><code>mk</code></a>, <a href="#CategoryTheory-Over-mkIdTerminal"><code>mkIdTerminal</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a>, <a href="#CategoryTheory-Over-post"><code>post</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight"><code>postAdjunctionRight</code></a>, <a href="#CategoryTheory-Over-postComp"><code>postComp</code></a>, <a href="#CategoryTheory-Over-postCongr"><code>postCongr</code></a>, <a href="#CategoryTheory-Over-postEquiv"><code>postEquiv</code></a>, <a href="#CategoryTheory-Over-postMap"><code>postMap</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence"><code>ofDiagEquivalence</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence'"><code>ofDiagEquivalence'</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence"><code>ofStructuredArrowProjEquivalence</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a>, <a href="#CategoryTheory-Under"><code>Under</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a>, <a href="#CategoryTheory-Under-forget"><code>forget</code></a>, <a href="#CategoryTheory-Under-forgetCone"><code>forgetCone</code></a>, <a href="#CategoryTheory-Under-homMk"><code>homMk</code></a>, <a href="#CategoryTheory-Under-inhabited"><code>inhabited</code></a>, <a href="#CategoryTheory-Under-isColimitLiftCocone"><code>isColimitLiftCocone</code></a>, <a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a>, <a href="#CategoryTheory-Under-liftCocone"><code>liftCocone</code></a>, <a href="#CategoryTheory-Under-map"><code>map</code></a>, <a href="#CategoryTheory-Under-mapComp"><code>mapComp</code></a>, <a href="#CategoryTheory-Under-mapCongr"><code>mapCongr</code></a>, <a href="#CategoryTheory-Under-mapForget"><code>mapForget</code></a>, <a href="#CategoryTheory-Under-mapFunctor"><code>mapFunctor</code></a>, <a href="#CategoryTheory-Under-mapId"><code>mapId</code></a>, <a href="#CategoryTheory-Under-mapIso"><code>mapIso</code></a>, <a href="#CategoryTheory-Under-mk"><code>mk</code></a>, <a href="#CategoryTheory-Under-mkIdInitial"><code>mkIdInitial</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a>, <a href="#CategoryTheory-Under-post"><code>post</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft"><code>postAdjunctionLeft</code></a>, <a href="#CategoryTheory-Under-postComp"><code>postComp</code></a>, <a href="#CategoryTheory-Under-postCongr"><code>postCongr</code></a>, <a href="#CategoryTheory-Under-postEquiv"><code>postEquiv</code></a>, <a href="#CategoryTheory-Under-postMap"><code>postMap</code></a>, <a href="#CategoryTheory-instCategoryOver"><code>instCategoryOver</code></a>, <a href="#CategoryTheory-instCategoryUnder"><code>instCategoryUnder</code></a></details></td><td>91</td></tr>
<tr><td><details><summary>Theorems</summary><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>functor_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>inverse_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>inverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjOverToOver"><code>instEssSurjOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulOverToOver"><code>instFaithfulOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullOverToOver"><code>instFullOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_toOver"><code>isEquivalence_toOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>ofCommaFstEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>ofCommaFstEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>ofCommaFstEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>ofCommaFstEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>ofCommaFstEquivalenceInverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>ofCommaFstEquivalenceInverse_map_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>ofCommaFstEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>ofCommaFstEquivalenceInverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>ofCommaFstEquivalenceInverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>ofCommaFstEquivalenceInverse_obj_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>ofCommaFstEquivalenceInverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>ofCommaFstEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>ofCommaFstEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>inverse_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_left"><code>toOver_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_right"><code>toOver_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_hom"><code>toOver_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_left"><code>toOver_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_right"><code>toOver_obj_right</code></a>, <a href="#CategoryTheory-Functor-essImage-of_overPost"><code>of_overPost</code></a>, <a href="#CategoryTheory-Functor-essImage-of_underPost"><code>of_underPost</code></a>, <a href="#CategoryTheory-Functor-essImage_overPost"><code>essImage_overPost</code></a>, <a href="#CategoryTheory-Functor-essImage_underPost"><code>essImage_underPost</code></a>, <a href="#CategoryTheory-Functor-toOver_comp_forget"><code>toOver_comp_forget</code></a>, <a href="#CategoryTheory-Functor-toOver_map_left"><code>toOver_map_left</code></a>, <a href="#CategoryTheory-Functor-toOver_obj_left"><code>toOver_obj_left</code></a>, <a href="#CategoryTheory-Functor-toUnder_comp_forget"><code>toUnder_comp_forget</code></a>, <a href="#CategoryTheory-Functor-toUnder_map_right"><code>toUnder_map_right</code></a>, <a href="#CategoryTheory-Functor-toUnder_obj_right"><code>toUnder_obj_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_pt"><code>underPost_pt</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>underPost_Œπ_app</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_pt"><code>overPost_pt</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>overPost_œÄ_app</code></a>, <a href="#CategoryTheory-Over-OverMorphism-ext"><code>ext</code></a>, <a href="#CategoryTheory-Over-OverMorphism-ext_iff"><code>ext_iff</code></a>, <a href="#CategoryTheory-Over-coe_hom"><code>coe_hom</code></a>, <a href="#CategoryTheory-Over-comp_left"><code>comp_left</code></a>, <a href="#CategoryTheory-Over-comp_left_assoc"><code>comp_left_assoc</code></a>, <a href="#CategoryTheory-Over-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-Over-epi_of_epi_left"><code>epi_of_epi_left</code></a>, <a href="#CategoryTheory-Over-eqToHom_left"><code>eqToHom_left</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>equivalenceOfIsTerminal_counitIso</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_functor"><code>equivalenceOfIsTerminal_functor</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_map"><code>equivalenceOfIsTerminal_inverse_map</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_obj"><code>equivalenceOfIsTerminal_inverse_obj</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a>, <a href="#CategoryTheory-Over-forall_iff"><code>forall_iff</code></a>, <a href="#CategoryTheory-Over-forgetCocone_pt"><code>forgetCocone_pt</code></a>, <a href="#CategoryTheory-Over-forgetCocone_Œπ_app"><code>forgetCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a>, <a href="#CategoryTheory-Over-forget_map"><code>forget_map</code></a>, <a href="#CategoryTheory-Over-forget_obj"><code>forget_obj</code></a>, <a href="#CategoryTheory-Over-forget_reflects_iso"><code>forget_reflects_iso</code></a>, <a href="#CategoryTheory-Over-homMk_comp"><code>homMk_comp</code></a>, <a href="#CategoryTheory-Over-homMk_eta"><code>homMk_eta</code></a>, <a href="#CategoryTheory-Over-homMk_left"><code>homMk_left</code></a>, <a href="#CategoryTheory-Over-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-Over-hom_left_inv_left"><code>hom_left_inv_left</code></a>, <a href="#CategoryTheory-Over-hom_left_inv_left_assoc"><code>hom_left_inv_left_assoc</code></a>, <a href="#CategoryTheory-Over-id_left"><code>id_left</code></a>, <a href="#CategoryTheory-Over-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a>, <a href="#CategoryTheory-Over-instFaithfulObjPost"><code>instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Over-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-Over-inv_left_hom_left"><code>inv_left_hom_left</code></a>, <a href="#CategoryTheory-Over-inv_left_hom_left_assoc"><code>inv_left_hom_left_assoc</code></a>, <a href="#CategoryTheory-Over-isRightAdjoint_post"><code>isRightAdjoint_post</code></a>, <a href="#CategoryTheory-Over-isoMk_hom_left"><code>isoMk_hom_left</code></a>, <a href="#CategoryTheory-Over-isoMk_inv_left"><code>isoMk_inv_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget"><code>iteratedSliceBackward_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget_forget"><code>iteratedSliceBackward_forget_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_map"><code>iteratedSliceBackward_map</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_obj"><code>iteratedSliceBackward_obj</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_functor"><code>iteratedSliceEquiv_functor</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_inverse"><code>iteratedSliceEquiv_inverse</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>iteratedSliceForwardNaturalityIso_hom_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>iteratedSliceForwardNaturalityIso_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_forget"><code>iteratedSliceForward_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_map"><code>iteratedSliceForward_map</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_obj"><code>iteratedSliceForward_obj</code></a>, <a href="#CategoryTheory-Over-liftCone_pt"><code>liftCone_pt</code></a>, <a href="#CategoryTheory-Over-liftCone_œÄ_app"><code>liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-Over-lift_map"><code>lift_map</code></a>, <a href="#CategoryTheory-Over-lift_obj"><code>lift_obj</code></a>, <a href="#CategoryTheory-Over-mapComp_eq"><code>mapComp_eq</code></a>, <a href="#CategoryTheory-Over-mapComp_hom_app_left"><code>mapComp_hom_app_left</code></a>, <a href="#CategoryTheory-Over-mapComp_inv_app_left"><code>mapComp_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapCongr_hom_app_left"><code>mapCongr_hom_app_left</code></a>, <a href="#CategoryTheory-Over-mapCongr_inv_app_left"><code>mapCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapCongr_rfl"><code>mapCongr_rfl</code></a>, <a href="#CategoryTheory-Over-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-Over-mapFunctor_map"><code>mapFunctor_map</code></a>, <a href="#CategoryTheory-Over-mapFunctor_obj"><code>mapFunctor_obj</code></a>, <a href="#CategoryTheory-Over-mapId_eq"><code>mapId_eq</code></a>, <a href="#CategoryTheory-Over-mapId_hom_app_left"><code>mapId_hom_app_left</code></a>, <a href="#CategoryTheory-Over-mapId_inv_app_left"><code>mapId_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapIso_functor"><code>mapIso_functor</code></a>, <a href="#CategoryTheory-Over-mapIso_inverse"><code>mapIso_inverse</code></a>, <a href="#CategoryTheory-Over-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-Over-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-Over-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-Over-mkIdTerminal_from_left"><code>mkIdTerminal_from_left</code></a>, <a href="#CategoryTheory-Over-mk_hom"><code>mk_hom</code></a>, <a href="#CategoryTheory-Over-mk_left"><code>mk_left</code></a>, <a href="#CategoryTheory-Over-mk_surjective"><code>mk_surjective</code></a>, <a href="#CategoryTheory-Over-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-Over-mono_left_of_mono"><code>mono_left_of_mono</code></a>, <a href="#CategoryTheory-Over-mono_of_mono_left"><code>mono_of_mono_left</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>opEquivOpUnder_counitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>opEquivOpUnder_functor_map</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>opEquivOpUnder_functor_obj</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>opEquivOpUnder_inverse_obj</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_unitIso"><code>opEquivOpUnder_unitIso</code></a>, <a href="#CategoryTheory-Over-over_right"><code>over_right</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-Over-postComp_hom_app_left"><code>postComp_hom_app_left</code></a>, <a href="#CategoryTheory-Over-postComp_inv_app_left"><code>postComp_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postCongr_hom_app_left"><code>postCongr_hom_app_left</code></a>, <a href="#CategoryTheory-Over-postCongr_inv_app_left"><code>postCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-postEquiv_functor"><code>postEquiv_functor</code></a>, <a href="#CategoryTheory-Over-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-Over-post_comp"><code>post_comp</code></a>, <a href="#CategoryTheory-Over-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-Over-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-Over-w"><code>w</code></a>, <a href="#CategoryTheory-Over-w_assoc"><code>w_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>inverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>inverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>toUnder_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>toUnder_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>toUnder_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>toUnder_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>toUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-UnderMorphism-ext"><code>ext</code></a>, <a href="#CategoryTheory-Under-UnderMorphism-ext_iff"><code>ext_iff</code></a>, <a href="#CategoryTheory-Under-comp_right"><code>comp_right</code></a>, <a href="#CategoryTheory-Under-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-Under-epi_of_epi_right"><code>epi_of_epi_right</code></a>, <a href="#CategoryTheory-Under-epi_right_of_epi"><code>epi_right_of_epi</code></a>, <a href="#CategoryTheory-Under-eqToHom_right"><code>eqToHom_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>equivalenceOfIsInitial_functor</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>equivalenceOfIsInitial_inverse_map</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_obj"><code>equivalenceOfIsInitial_inverse_obj</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Under-forall_iff"><code>forall_iff</code></a>, <a href="#CategoryTheory-Under-forgetCone_pt"><code>forgetCone_pt</code></a>, <a href="#CategoryTheory-Under-forgetCone_œÄ_app"><code>forgetCone_œÄ_app</code></a>, <a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a>, <a href="#CategoryTheory-Under-forget_map"><code>forget_map</code></a>, <a href="#CategoryTheory-Under-forget_obj"><code>forget_obj</code></a>, <a href="#CategoryTheory-Under-forget_reflects_iso"><code>forget_reflects_iso</code></a>, <a href="#CategoryTheory-Under-homMk_comp"><code>homMk_comp</code></a>, <a href="#CategoryTheory-Under-homMk_eta"><code>homMk_eta</code></a>, <a href="#CategoryTheory-Under-homMk_right"><code>homMk_right</code></a>, <a href="#CategoryTheory-Under-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right"><code>hom_right_inv_right</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right_assoc"><code>hom_right_inv_right_assoc</code></a>, <a href="#CategoryTheory-Under-id_right"><code>id_right</code></a>, <a href="#CategoryTheory-Under-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a>, <a href="#CategoryTheory-Under-instFaithfulObjPost"><code>instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Under-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right"><code>inv_right_hom_right</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right_assoc"><code>inv_right_hom_right_assoc</code></a>, <a href="#CategoryTheory-Under-isLeftAdjoint_post"><code>isLeftAdjoint_post</code></a>, <a href="#CategoryTheory-Under-isoMk_hom_right"><code>isoMk_hom_right</code></a>, <a href="#CategoryTheory-Under-isoMk_inv_right"><code>isoMk_inv_right</code></a>, <a href="#CategoryTheory-Under-liftCocone_pt"><code>liftCocone_pt</code></a>, <a href="#CategoryTheory-Under-liftCocone_Œπ_app"><code>liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Under-lift_map"><code>lift_map</code></a>, <a href="#CategoryTheory-Under-lift_obj"><code>lift_obj</code></a>, <a href="#CategoryTheory-Under-mapComp_eq"><code>mapComp_eq</code></a>, <a href="#CategoryTheory-Under-mapComp_hom"><code>mapComp_hom</code></a>, <a href="#CategoryTheory-Under-mapComp_inv"><code>mapComp_inv</code></a>, <a href="#CategoryTheory-Under-mapCongr_hom_app"><code>mapCongr_hom_app</code></a>, <a href="#CategoryTheory-Under-mapCongr_inv_app"><code>mapCongr_inv_app</code></a>, <a href="#CategoryTheory-Under-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-Under-mapFunctor_map"><code>mapFunctor_map</code></a>, <a href="#CategoryTheory-Under-mapFunctor_obj"><code>mapFunctor_obj</code></a>, <a href="#CategoryTheory-Under-mapId_eq"><code>mapId_eq</code></a>, <a href="#CategoryTheory-Under-mapId_hom"><code>mapId_hom</code></a>, <a href="#CategoryTheory-Under-mapId_inv"><code>mapId_inv</code></a>, <a href="#CategoryTheory-Under-mapIso_functor"><code>mapIso_functor</code></a>, <a href="#CategoryTheory-Under-mapIso_inverse"><code>mapIso_inverse</code></a>, <a href="#CategoryTheory-Under-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-Under-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-Under-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-Under-mkIdInitial_to_right"><code>mkIdInitial_to_right</code></a>, <a href="#CategoryTheory-Under-mk_hom"><code>mk_hom</code></a>, <a href="#CategoryTheory-Under-mk_right"><code>mk_right</code></a>, <a href="#CategoryTheory-Under-mk_surjective"><code>mk_surjective</code></a>, <a href="#CategoryTheory-Under-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-Under-mono_of_mono_right"><code>mono_of_mono_right</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>opEquivOpOver_functor_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_obj"><code>opEquivOpOver_functor_obj</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>opEquivOpOver_inverse_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>opEquivOpOver_inverse_obj</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_unitIso"><code>opEquivOpOver_unitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-Under-postComp_hom_app_right"><code>postComp_hom_app_right</code></a>, <a href="#CategoryTheory-Under-postComp_inv_app_right"><code>postComp_inv_app_right</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>postCongr_hom_app_right</code></a>, <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-postEquiv_functor"><code>postEquiv_functor</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-Under-post_comp"><code>post_comp</code></a>, <a href="#CategoryTheory-Under-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-Under-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-Under-under_left"><code>under_left</code></a>, <a href="#CategoryTheory-Under-w"><code>w</code></a>, <a href="#CategoryTheory-Under-w_assoc"><code>w_assoc</code></a></details></td><td>302</td></tr>
<tr><td><strong>Total</strong></td><td><strong>393</strong></td></tr>
</table>
<h2>CategoryTheory</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L611" id="CategoryTheory-Under"><code>Under</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>272 math</summary><strong>math:</strong> <a href="#CommRingCat-tensorProd_map_right"><code>CommRingCat.tensorProd_map_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_pt"><code>Limits.Cone.toUnder_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>StructuredArrow.instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-Limits-PreservesColimitsOfSize-underPost"><code>Limits.PreservesColimitsOfSize.underPost</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_obj"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_obj</code></a>, <a href="#CategoryTheory-Under-postComp_inv_app_right"><code>Under.postComp_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>StructuredArrow.ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>StructuredArrow.ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_inv_app"><code>Under.forgetMapInitial_inv_app</code></a>, <a href="#CategoryTheory-Under-post_comp"><code>Under.post_comp</code></a>, <a href="#CategoryTheory-WithInitial-isColimitEquiv_apply_desc_right"><code>WithInitial.isColimitEquiv_apply_desc_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>Under.equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_pt"><code>WithInitial.coconeEquiv_functor_obj_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>Under.postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>StructuredArrow.toUnder_obj_left</code></a>, <a href="#CategoryTheory-Under-mapIso_functor"><code>Under.mapIso_functor</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-g_app"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.g_app</code></a>, <a href="#CategoryTheory-Under-instHasLimitsOfShape"><code>Under.instHasLimitsOfShape</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_inverse_obj"><code>Limits.pushoutCoconeEquivBinaryCofan_inverse_obj</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_obj"><code>Limits.pushoutCoconeEquivBinaryCofan_functor_obj</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_right"><code>WithInitial.coconeEquiv_inverse_obj_pt_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_unitIso"><code>Limits.pushoutCoconeEquivBinaryCofan_unitIso</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsUnderUnderObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsUnderUnderObjOfRespectsIso</code></a>, <a href="#CommRingCat-toAlgHom_comp"><code>CommRingCat.toAlgHom_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>Under.equivalenceOfIsInitial_functor</code></a>, <a href="#CategoryTheory-WithInitial-isColimitEquiv_symm_apply_desc"><code>WithInitial.isColimitEquiv_symm_apply_desc</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>Limits.Cocone.underPost_Œπ_app</code></a>, <a href="#instHasColimitsOfShapeUnderOfWithInitial"><code>instHasColimitsOfShapeUnderOfWithInitial</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_unitIso"><code>Over.opEquivOpUnder_unitIso</code></a>, <a href="#CategoryTheory-Under-epi_of_epi_right"><code>Under.epi_of_epi_right</code></a>, <a href="#CategoryTheory-Under-liftCone_pt"><code>Under.liftCone_pt</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_inv_app"><code>WithInitial.liftFromUnderComp_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_faithful"><code>Under.forget_faithful</code></a>, <a href="#CategoryTheory-Under-mapCongr_inv_app"><code>Under.mapCongr_inv_app</code></a>, <a href="#CategoryTheory-Under-pushoutIsLeftAdjoint"><code>Under.pushoutIsLeftAdjoint</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-MorphismProperty-ind_iff_ind_underMk"><code>MorphismProperty.ind_iff_ind_underMk</code></a>, <a href="#CategoryTheory-Under-mapFunctor_obj"><code>Under.mapFunctor_obj</code></a>, <a href="#instHasColimitsOfSizeUnder"><code>instHasColimitsOfSizeUnder</code></a>, <a href="#CategoryTheory-Under-pushout_map"><code>Under.pushout_map</code></a>, <a href="#CategoryTheory-Under-lift_obj"><code>Under.lift_obj</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_hom"><code>WithInitial.coconeEquiv_inverse_obj_pt_hom</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_inverse_map_hom"><code>Limits.pushoutCoconeEquivBinaryCofan_inverse_map_hom</code></a>, <a href="#CommRingCat-Under-preservesFiniteLimits_of_flat"><code>CommRingCat.Under.preservesFiniteLimits_of_flat</code></a>, <a href="#CommRingCat-pushout_inr_tensorProdObjIsoPushoutObj_inv_right_assoc"><code>CommRingCat.pushout_inr_tensorProdObjIsoPushoutObj_inv_right_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>StructuredArrow.ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_unit_app_right"><code>Under.postAdjunctionRight_unit_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>StructuredArrow.ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Under-map_map_right"><code>Under.map_map_right</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>Over.opEquivOpUnder_inverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#AlgHom-toUnder_comp"><code>AlgHom.toUnder_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Under-map_obj_right"><code>Under.map_obj_right</code></a>, <a href="#CategoryTheory-Under-post_obj"><code>Under.post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_hom</code></a>, <a href="#commAlgCatEquivUnder_functor_obj"><code>commAlgCatEquivUnder_functor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-Under-eqToHom_right"><code>Under.eqToHom_right</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteLimitsUnderTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesFiniteLimitsUnderTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-Under-mapId_inv"><code>Under.mapId_inv</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-coneFunctorEnrichedHom_œÄ_app"><code>Enriched.FunctorCategory.coneFunctorEnrichedHom_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Presheaf-functorEnrichedHomCoyonedaObjEquiv_naturality"><code>Presheaf.functorEnrichedHomCoyonedaObjEquiv_naturality</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_counitIso_inv_app_hom"><code>WithInitial.coconeEquiv_counitIso_inv_app_hom</code></a>, <a href="#CommRingCat-Under-instPreservesLimitsOfShapeUnderWalkingParallelPairTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesLimitsOfShapeUnderWalkingParallelPairTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-MorphismProperty-under_eq_inverseImage"><code>MorphismProperty.under_eq_inverseImage</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_left"><code>WithInitial.commaFromUnder_map_left</code></a>, <a href="#CategoryTheory-NatTrans-instIsClosedUnderColimitsOfShapeUnderFunctorCoequifiberedHomDiscretePUnitOfHasProductsOfShapeHom"><code>NatTrans.instIsClosedUnderColimitsOfShapeUnderFunctorCoequifiberedHomDiscretePUnitOfHasProductsOfShapeHom</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-Under-costar_obj_left"><code>Under.costar_obj_left</code></a>, <a href="#CategoryTheory-Under-isoMk_inv_right"><code>Under.isoMk_inv_right</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_unit_app"><code>Under.mapPushoutAdj_unit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceMapOfIsIso"><code>Under.instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_Œπ_app_star"><code>WithInitial.coconeEquiv_functor_obj_Œπ_app_star</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>Over.opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-Under-liftCocone_Œπ_app"><code>Under.liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Under-post_map"><code>Under.post_map</code></a>, <a href="#AlgEquiv-toUnder_trans"><code>AlgEquiv.toUnder_trans</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_unitIso_hom_app_hom_right"><code>WithInitial.coconeEquiv_unitIso_hom_app_hom_right</code></a>, <a href="#CategoryTheory-Functor-essImage_underPost"><code>Functor.essImage_underPost</code></a>, <a href="#CategoryTheory-Under-instFaithfulObjPost"><code>Under.instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Under-map_obj_hom"><code>Under.map_obj_hom</code></a>, <a href="#CommRingCat-Under-tensorProdEqualizer_Œπ"><code>CommRingCat.Under.tensorProdEqualizer_Œπ</code></a>, <a href="#CategoryTheory-Under-instEssSurjObjPostOfFull"><code>Under.instEssSurjObjPostOfFull</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteProductsUnderPushout"><code>CommRingCat.Under.instPreservesFiniteProductsUnderPushout</code></a>, <a href="#CommRingCat-toAlgHom_id"><code>CommRingCat.toAlgHom_id</code></a>, <a href="#CategoryTheory-Under-mono_iff_mono_right"><code>Under.mono_iff_mono_right</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_obj_obj"><code>WithInitial.liftFromUnder_obj_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>StructuredArrow.isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-Under-forgetCone_pt"><code>Under.forgetCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>Under.postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-postComp_hom_app_right"><code>Under.postComp_hom_app_right</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteColimits-underPost"><code>Limits.PreservesFiniteColimits.underPost</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_map_hom"><code>WithInitial.coconeEquiv_functor_map_hom</code></a>, <a href="#CategoryTheory-Under-isoMk_hom_right"><code>Under.isoMk_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-algebraEquivUnder_inverse"><code>algebraEquivUnder_inverse</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_left_as"><code>WithInitial.coconeEquiv_inverse_obj_pt_left_as</code></a>, <a href="#CategoryTheory-underToAlgebra_obj_A"><code>underToAlgebra_obj_A</code></a>, <a href="#CategoryTheory-Under-mapCongr_hom_app"><code>Under.mapCongr_hom_app</code></a>, <a href="#AlgEquiv-toUnder_inv_right_apply"><code>AlgEquiv.toUnder_inv_right_apply</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>StructuredArrow.toUnder_map_right</code></a>, <a href="#CategoryTheory-Under-instIsRightAdjointForget"><code>Under.instIsRightAdjointForget</code></a>, <a href="#CommRingCat-pushout_inl_tensorProdObjIsoPushoutObj_inv_right_assoc"><code>CommRingCat.pushout_inl_tensorProdObjIsoPushoutObj_inv_right_assoc</code></a>, <a href="#CategoryTheory-Under-mapFunctor_map"><code>Under.mapFunctor_map</code></a>, <a href="#CategoryTheory-Under-liftCone_œÄ_app"><code>Under.liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-Under-instIsLeftAdjointCostar"><code>Under.instIsLeftAdjointCostar</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_map"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_map</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_hom_app"><code>Under.forgetMapInitial_hom_app</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_map_hom"><code>Limits.pushoutCoconeEquivBinaryCofan_functor_map_hom</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_Œπ_app_right"><code>WithInitial.coconeEquiv_inverse_obj_Œπ_app_right</code></a>, <a href="#CommRingCat-monoidAlgebra_map"><code>CommRingCat.monoidAlgebra_map</code></a>, <a href="#CategoryTheory-MorphismProperty-instFullUnderTopUnderForget"><code>MorphismProperty.instFullUnderTopUnderForget</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_Œπ_app_of"><code>WithInitial.coconeEquiv_functor_obj_Œπ_app_of</code></a>, <a href="#CategoryTheory-Under-mapComp_hom"><code>Under.mapComp_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_obj"><code>Under.opEquivOpOver_functor_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_hom_app"><code>WithInitial.commaFromUnder_obj_hom_app</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_right"><code>WithInitial.commaFromUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_map"><code>Under.forget_map</code></a>, <a href="#commAlgCatEquivUnder_counitIso"><code>commAlgCatEquivUnder_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>StructuredArrow.instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-isCardinalFiltered_under"><code>isCardinalFiltered_under</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>Under.equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Under-isLeftAdjoint_post"><code>Under.isLeftAdjoint_post</code></a>, <a href="#CommRingCat-pushout_inl_tensorProdObjIsoPushoutObj_inv_right"><code>CommRingCat.pushout_inl_tensorProdObjIsoPushoutObj_inv_right</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>Over.opEquivOpUnder_counitIso</code></a>, <a href="#commAlgCatEquivUnder_inverse_obj_carrier"><code>commAlgCatEquivUnder_inverse_obj_carrier</code></a>, <a href="#CommRingCat-Under-instPreservesLimitUnderDiscreteFunctorTensorProdOfFinite"><code>CommRingCat.Under.instPreservesLimitUnderDiscreteFunctorTensorProdOfFinite</code></a>, <a href="#CategoryTheory-Under-mapIso_inverse"><code>Under.mapIso_inverse</code></a>, <a href="#CategoryTheory-Functor-toUnder_comp_forget"><code>Functor.toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#AlgEquiv-toUnder_hom_right_apply"><code>AlgEquiv.toUnder_hom_right_apply</code></a>, <a href="#preservesFilteredColimits_coyoneda"><code>preservesFilteredColimits_coyoneda</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedComp_app"><code>Enriched.FunctorCategory.functorEnrichedComp_app</code></a>, <a href="#commAlgCatEquivUnder_unitIso"><code>commAlgCatEquivUnder_unitIso</code></a>, <a href="#CommRingCat-isFinitelyPresentable_under"><code>CommRingCat.isFinitelyPresentable_under</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceObjPost"><code>Under.instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-algebraEquivUnder_unitIso"><code>algebraEquivUnder_unitIso</code></a>, <a href="#CategoryTheory-underToAlgebra_obj_a"><code>underToAlgebra_obj_a</code></a>, <a href="#CategoryTheory-algebraToUnder_obj"><code>algebraToUnder_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_right"><code>WithInitial.commaFromUnder_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_obj"><code>Enriched.FunctorCategory.functorEnrichedHom_obj</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>Under.postMap_app</code></a>, <a href="#CategoryTheory-Functor-toUnder_obj_right"><code>Functor.toUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right"><code>Under.hom_right_inv_right</code></a>, <a href="#CategoryTheory-Under-mapId_hom"><code>Under.mapId_hom</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>Under.postEquiv_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>StructuredArrow.toUnder_obj_hom</code></a>, <a href="#CategoryTheory-algebraEquivUnder_counitIso"><code>algebraEquivUnder_counitIso</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>Under.postCongr_hom_app_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-instHasEnrichedHomUnderCompMapForget"><code>Enriched.FunctorCategory.instHasEnrichedHomUnderCompMapForget</code></a>, <a href="#CategoryTheory-MorphismProperty-Under-forget_comp_forget_map"><code>MorphismProperty.Under.forget_comp_forget_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CommRingCat-tensorProdIsoPushout_app"><code>CommRingCat.tensorProdIsoPushout_app</code></a>, <a href="#CategoryTheory-Under-mapId_eq"><code>Under.mapId_eq</code></a>, <a href="#CategoryTheory-Under-pushout_obj"><code>Under.pushout_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_left"><code>WithInitial.commaFromUnder_obj_left</code></a>, <a href="#CategoryTheory-Limits-IsColimit-pushoutCoconeEquivBinaryCofanFunctor_desc_right"><code>Limits.IsColimit.pushoutCoconeEquivBinaryCofanFunctor_desc_right</code></a>, <a href="#CategoryTheory-Under-instHasLimits"><code>Under.instHasLimits</code></a>, <a href="#CategoryTheory-IsFiltered-under"><code>IsFiltered.under</code></a>, <a href="#commAlgCatEquivUnder_inverse_map"><code>commAlgCatEquivUnder_inverse_map</code></a>, <a href="#Under-hasColimit_of_hasColimit_liftFromUnder"><code>Under.hasColimit_of_hasColimit_liftFromUnder</code></a>, <a href="#CategoryTheory-Under-forget_obj"><code>Under.forget_obj</code></a>, <a href="#CategoryTheory-Under-liftCocone_pt"><code>Under.liftCocone_pt</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_map_hom_right"><code>WithInitial.coconeEquiv_inverse_map_hom_right</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteProductsUnderTensorProd"><code>CommRingCat.Under.instPreservesFiniteProductsUnderTensorProd</code></a>, <a href="#CategoryTheory-Under-mapForget_eq"><code>Under.mapForget_eq</code></a>, <a href="#CategoryTheory-underToAlgebra_map_f"><code>underToAlgebra_map_f</code></a>, <a href="#CategoryTheory-Under-instFullObjPostOfFaithful"><code>Under.instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Under-final_forget"><code>Under.final_forget</code></a>, <a href="#preservesColimit_coyoneda_of_finitePresentation"><code>preservesColimit_coyoneda_of_finitePresentation</code></a>, <a href="#CategoryTheory-Functor-toUnder_map_right"><code>Functor.toUnder_map_right</code></a>, <a href="#CategoryTheory-Under-mono_of_mono_right"><code>Under.mono_of_mono_right</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_counit_app"><code>Under.mapPushoutAdj_counit_app</code></a>, <a href="#CategoryTheory-Under-mapComp_eq"><code>Under.mapComp_eq</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_hom_app"><code>WithInitial.liftFromUnderComp_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CommRingCat-Under-equalizerFork_Œπ"><code>CommRingCat.Under.equalizerFork_Œπ</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_counitIso_hom_app_hom"><code>WithInitial.coconeEquiv_counitIso_hom_app_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>Under.postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right"><code>Under.inv_right_hom_right</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_map_app"><code>WithInitial.liftFromUnder_map_app</code></a>, <a href="#CategoryTheory-Under-mapComp_inv"><code>Under.mapComp_inv</code></a>, <a href="#CategoryTheory-MorphismProperty-underObj_ind_eq_ind_underObj"><code>MorphismProperty.underObj_ind_eq_ind_underObj</code></a>, <a href="#commAlgCatEquivUnder_functor_map"><code>commAlgCatEquivUnder_functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right_assoc"><code>Under.hom_right_inv_right_assoc</code></a>, <a href="#CategoryTheory-Under-locallySmall"><code>Under.locallySmall</code></a>, <a href="#CommRingCat-instIsLeftAdjointCommMonCatUnderMonoidAlgebra"><code>CommRingCat.instIsLeftAdjointCommMonCatUnderMonoidAlgebra</code></a>, <a href="#CommRingCat-monoidAlgebra_obj"><code>CommRingCat.monoidAlgebra_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>Under.opEquivOpOver_inverse_obj</code></a>, <a href="#CategoryTheory-Under-costar_map_left"><code>Under.costar_map_left</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>Under.equivalenceOfIsInitial_inverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>StructuredArrow.ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>Under.opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>StructuredArrow.toUnder_map_left</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_obj_map"><code>WithInitial.liftFromUnder_obj_map</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorHomEquiv_apply_app"><code>Enriched.FunctorCategory.functorHomEquiv_apply_app</code></a>, <a href="#CategoryTheory-Under-mkIdInitial_to_right"><code>Under.mkIdInitial_to_right</code></a>, <a href="#CategoryTheory-Under-mono_homMk"><code>Under.mono_homMk</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_obj"><code>Under.equivalenceOfIsInitial_inverse_obj</code></a>, <a href="#CategoryTheory-Under-costar_obj_hom"><code>Under.costar_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-Limits-PreservesColimitsOfShape-underPost"><code>Limits.PreservesColimitsOfShape.underPost</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>Under.postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_counitIso"><code>Limits.pushoutCoconeEquivBinaryCofan_counitIso</code></a>, <a href="#isFinitelyPresentable"><code>isFinitelyPresentable</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>Over.opEquivOpUnder_functor_map</code></a>, <a href="#CategoryTheory-Under-postEquiv_functor"><code>Under.postEquiv_functor</code></a>, <a href="#CategoryTheory-Under-lift_map"><code>Under.lift_map</code></a>, <a href="#CategoryTheory-Under-hasLimit_of_hasLimit_comp_forget"><code>Under.hasLimit_of_hasLimit_comp_forget</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_unitIso"><code>Under.opEquivOpOver_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>StructuredArrow.instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right_assoc"><code>Under.inv_right_hom_right_assoc</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-hf"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.hf</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>Under.opEquivOpOver_functor_map</code></a>, <a href="#CategoryTheory-Under-epi_homMk"><code>Under.epi_homMk</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>Under.postEquiv_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-algebraToUnder_map"><code>algebraToUnder_map</code></a>, <a href="#CategoryTheory-Limits-instPreservesFilteredColimitsOfSizeUnderForget"><code>Limits.instPreservesFilteredColimitsOfSizeUnderForget</code></a>, <a href="#CommRingCat-Under-instPreservesLimitUnderWalkingParallelPairParallelPairTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesLimitUnderWalkingParallelPairParallelPairTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-Under-id_right"><code>Under.id_right</code></a>, <a href="#CategoryTheory-algebraEquivUnder_functor"><code>algebraEquivUnder_functor</code></a>, <a href="#CategoryTheory-Under-homMk_comp"><code>Under.homMk_comp</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>Under.postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_map"><code>Enriched.FunctorCategory.functorEnrichedHom_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>StructuredArrow.toUnder_obj_right</code></a>, <a href="#CommRingCat-preservesFilteredColimits_coyoneda"><code>CommRingCat.preservesFilteredColimits_coyoneda</code></a>, <a href="#CategoryTheory-Under-isRightAdjoint_post"><code>Under.isRightAdjoint_post</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_unitIso_inv_app_hom_right"><code>WithInitial.coconeEquiv_unitIso_inv_app_hom_right</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>Under.opEquivOpOver_inverse_map</code></a>, <a href="#CategoryTheory-Under-preservesLimitsOfSize_map"><code>Under.preservesLimitsOfSize_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_pt"><code>Limits.Cocone.underPost_pt</code></a>, <a href="#CommRingCat-preservesColimit_coyoneda_of_finitePresentation"><code>CommRingCat.preservesColimit_coyoneda_of_finitePresentation</code></a>, <a href="#CategoryTheory-Under-forgetCone_œÄ_app"><code>Under.forgetCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-epi_f"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.epi_f</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>Over.opEquivOpUnder_functor_obj</code></a>, <a href="#CommRingCat-Under-equalizer_comp"><code>CommRingCat.Under.equalizer_comp</code></a>, <a href="#CategoryTheory-Under-forget_reflects_iso"><code>Under.forget_reflects_iso</code></a>, <a href="#CommRingCat-Under-equalizerFork'_Œπ"><code>CommRingCat.Under.equalizerFork'_Œπ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedId_app"><code>Enriched.FunctorCategory.functorEnrichedId_app</code></a>, <a href="#CategoryTheory-Under-comp_right"><code>Under.comp_right</code></a>, <a href="#CategoryTheory-MorphismProperty-instFaithfulUnderTopUnderForget"><code>MorphismProperty.instFaithfulUnderTopUnderForget</code></a>, <a href="#CategoryTheory-Under-faithful_pushout"><code>Under.faithful_pushout</code></a>, <a href="#CommRingCat-pushout_inr_tensorProdObjIsoPushoutObj_inv_right"><code>CommRingCat.pushout_inr_tensorProdObjIsoPushoutObj_inv_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L42" id="CategoryTheory-instCategoryOver"><code>instCategoryOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.instCategoryOver" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>806 math</summary><strong>math:</strong> <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_functor'_obj_obj"><code>TopCat.Presheaf.generateEquivalenceOpensLe_functor'_obj_obj</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_snd_fst_assoc"><code>Over.associator_hom_left_snd_fst_assoc</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_hom_app_val_app"><code>GrothendieckTopology.overMapPullbackId_hom_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerLeft_left_fst"><code>ChosenPullbacksAlong.Over.whiskerLeft_left_fst</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_hom_snd_assoc"><code>Over.prodLeftIsoPullback_hom_snd_assoc</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_isColimit"><code>Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_isColimit</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_snd'"><code>Over.Œº_pullback_left_snd'</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_unitIso_hom_app_hom_left"><code>WithTerminal.coneEquiv_unitIso_hom_app_hom_left</code></a>, <a href="#CategoryTheory-Pseudofunctor-DescentData-subtypeCompatibleHomEquiv_toCompatible_presheafHomObjHomEquiv"><code>Pseudofunctor.DescentData.subtypeCompatibleHomEquiv_toCompatible_presheafHomObjHomEquiv</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_hom</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-has_over_limit_discrete_of_widePullback_limit"><code>Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit</code></a>, <a href="#CategoryTheory-Subobject-factors_iff"><code>Subobject.factors_iff</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_snd_fst_assoc"><code>ChosenPullbacksAlong.Over.associator_hom_left_snd_fst_assoc</code></a>, <a href="#CategoryTheory-Over-faithful_pullback"><code>Over.faithful_pullback</code></a>, <a href="#CategoryTheory-Over-forget_faithful"><code>Over.forget_faithful</code></a>, <a href="#CategoryTheory-Over-instHasTerminal"><code>Over.instHasTerminal</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-pullbackCoverOver_X"><code>AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_X</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivInverseObj_pt"><code>Over.ConstructProducts.conesEquivInverseObj_pt</code></a>, <a href="#CategoryTheory-MorphismProperty-over_eq_inverseImage"><code>MorphismProperty.over_eq_inverseImage</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>Over.iteratedSliceForwardNaturalityIso_hom_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_map‚ÇÇ"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_map‚ÇÇ</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_left"><code>CostructuredArrow.toOver_obj_left</code></a>, <a href="#CategoryTheory-MonoOver-mk_coe"><code>MonoOver.mk_coe</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorHom_left_fst"><code>ChosenPullbacksAlong.Over.tensorHom_left_fst</code></a>, <a href="#AlgebraicGeometry-isCommMonObj_of_isProper_of_geometricallyIntegral"><code>AlgebraicGeometry.isCommMonObj_of_isProper_of_geometricallyIntegral</code></a>, <a href="#CategoryTheory-OverPresheafAux-costructuredArrowPresheafToOver_map"><code>OverPresheafAux.costructuredArrowPresheafToOver_map</code></a>, <a href="#CategoryTheory-Over-forgetCocone_pt"><code>Over.forgetCocone_pt</code></a>, <a href="#AlgebraicGeometry-opensCone_pt"><code>AlgebraicGeometry.opensCone_pt</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_pullback_map"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryFst_pullback_map</code></a>, <a href="#CategoryTheory-MonoOver-congr_unitIso"><code>MonoOver.congr_unitIso</code></a>, <a href="#CategoryTheory-MorphismProperty-HasFactorization-over"><code>MorphismProperty.HasFactorization.over</code></a>, <a href="#CategoryTheory-instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair"><code>instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair</code></a>, <a href="#CategoryTheory-instHasLimitsOfSizeOver"><code>instHasLimitsOfSizeOver</code></a>, <a href="#CategoryTheory-OverPresheafAux-unitAux_hom"><code>OverPresheafAux.unitAux_hom</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_map"><code>Over.iteratedSliceBackward_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>CostructuredArrow.ofDiagEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_obj"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_obj</code></a>, <a href="#CategoryTheory-MonoOver-mapIso_functor"><code>MonoOver.mapIso_functor</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_snd"><code>Over.associator_inv_left_snd</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-homEquiv_symm_apply_eq"><code>ExponentiableMorphism.homEquiv_symm_apply_eq</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_Œπ_app"><code>Limits.Cocone.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-Over-pullback_obj_left"><code>Over.pullback_obj_left</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctorŒì_inv_app"><code>AlgebraicGeometry.Scheme.restrictFunctorŒì_inv_app</code></a>, <a href="#CategoryTheory-Over-inv_left_hom_left_assoc"><code>Over.inv_left_hom_left_assoc</code></a>, <a href="#CategoryTheory-Over-instIsLeftAdjointForget"><code>Over.instIsLeftAdjointForget</code></a>, <a href="#AlgebraicGeometry-Scheme-overGrothendieckTopology_eq_toGrothendieck_overPretopology"><code>AlgebraicGeometry.Scheme.overGrothendieckTopology_eq_toGrothendieck_overPretopology</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_unitIso"><code>TopCat.Presheaf.generateEquivalenceOpensLe_unitIso</code></a>, <a href="#CategoryTheory-MonoOver-mk_obj"><code>MonoOver.mk_obj</code></a>, <a href="#CategoryTheory-Over-mapIso_inverse"><code>Over.mapIso_inverse</code></a>, <a href="#CategoryTheory-MonoOver-isIso_left_iff_subobjectMk_eq"><code>MonoOver.isIso_left_iff_subobjectMk_eq</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_comp_id"><code>GrothendieckTopology.overMapPullback_comp_id</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_pullback"><code>Sieve.overEquiv_pullback</code></a>, <a href="#CategoryTheory-Over-rightUnitor_inv_left_fst_assoc"><code>Over.rightUnitor_inv_left_fst_assoc</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYoneda_map"><code>OverPresheafAux.restrictedYoneda_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_inv_app_val_app"><code>GrothendieckTopology.overMapPullbackId_inv_app_val_app</code></a>, <a href="#CategoryTheory-toOver_obj_hom"><code>toOver_obj_hom</code></a>, <a href="#CategoryTheory-MonoOver-hasColimitsOfSize_of_hasStrongEpiMonoFactorisations"><code>MonoOver.hasColimitsOfSize_of_hasStrongEpiMonoFactorisations</code></a>, <a href="#CategoryTheory-Sieve-ofArrows_category'"><code>Sieve.ofArrows_category'</code></a>, <a href="#CategoryTheory-Over-comp_left_assoc"><code>Over.comp_left_assoc</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsContinuousOverStarOver"><code>GrothendieckTopology.instIsContinuousOverStarOver</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-id_pushforward"><code>ExponentiableMorphism.id_pushforward</code></a>, <a href="#CategoryTheory-Iso-asOver_hom"><code>Iso.asOver_hom</code></a>, <a href="#CategoryTheory-MonoOver-instIsRightAdjointOverForget"><code>MonoOver.instIsRightAdjointOverForget</code></a>, <a href="#CategoryTheory-Over-hom_left_inv_left"><code>Over.hom_left_inv_left</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceObjPost"><code>Over.instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-Limits-PreservesLimitsOfShape-overPost"><code>Limits.PreservesLimitsOfShape.overPost</code></a>, <a href="#CategoryTheory-Over-monObjMkPullbackSnd_mul"><code>Over.monObjMkPullbackSnd_mul</code></a>, <a href="#CategoryTheory-Over-whiskerLeft_left"><code>Over.whiskerLeft_left</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_hom_app"><code>Over.forgetMapTerminal_hom_app</code></a>, <a href="#CategoryTheory-OverPresheafAux-restrictedYoneda_obj"><code>OverPresheafAux.restrictedYoneda_obj</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>Over.equivalenceOfIsTerminal_counitIso</code></a>, <a href="#CategoryTheory-Presheaf-isSheaf_iff_isLimit_coverage"><code>Presheaf.isSheaf_iff_isLimit_coverage</code></a>, <a href="#CategoryTheory-MonoOver-isIso_iff_subobjectMk_eq"><code>MonoOver.isIso_iff_subobjectMk_eq</code></a>, <a href="#CategoryTheory-Over-epi_iff_epi_left"><code>Over.epi_iff_epi_left</code></a>, <a href="#CategoryTheory-Over-grpObjMkPullbackSnd_one"><code>Over.grpObjMkPullbackSnd_one</code></a>, <a href="#CategoryTheory-Classifier-SubobjectRepresentableBy-iso_inv_hom_left_comp"><code>Classifier.SubobjectRepresentableBy.iso_inv_hom_left_comp</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-pullbackCoverOver'_X"><code>AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_X</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_inverse_obj_œÄ_app_left"><code>WithTerminal.coneEquiv_inverse_obj_œÄ_app_left</code></a>, <a href="#CategoryTheory-Over-grpObjMkPullbackSnd_mul"><code>Over.grpObjMkPullbackSnd_mul</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_right"><code>CostructuredArrow.toOver_obj_right</code></a>, <a href="#AlgebraicGeometry-Scheme-locallyCoverDense_of_le"><code>AlgebraicGeometry.Scheme.locallyCoverDense_of_le</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackComp_hom_assoc"><code>ChosenPullbacksAlong.unit_pullbackComp_hom_assoc</code></a>, <a href="#CategoryTheory-Over-hasLimit_of_hasLimit_liftFromOver"><code>Over.hasLimit_of_hasLimit_liftFromOver</code></a>, <a href="#CategoryTheory-OverClass-asOverHom_comp_assoc"><code>OverClass.asOverHom_comp_assoc</code></a>, <a href="#CategoryTheory-MonoOver-mapIso_unitIso"><code>MonoOver.mapIso_unitIso</code></a>, <a href="#CategoryTheory-toOver_obj_left"><code>toOver_obj_left</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-surjectivity-F_map"><code>IsGrothendieckAbelian.IsPresentable.surjectivity.F_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_unit_app"><code>ChosenPullbacksAlong.iso_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_inv_app_left"><code>toOverPullbackIsoToOver_inv_app_left</code></a>, <a href="#CategoryTheory-Over-toUnit_left"><code>Over.toUnit_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_map_coverPreserving"><code>GrothendieckTopology.over_map_coverPreserving</code></a>, <a href="#CategoryTheory-coalgebraEquivOver_functor"><code>coalgebraEquivOver_functor</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_hom_app_comp_snd_assoc"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_hom_app_comp_snd_assoc</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_toOver_comp_forget"><code>Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget</code></a>, <a href="#CategoryTheory-Over-braiding_inv_left"><code>Over.braiding_inv_left</code></a>, <a href="#CategoryTheory-Over-mapId_eq"><code>Over.mapId_eq</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_unitIso"><code>Over.opEquivOpUnder_unitIso</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_inv_snd"><code>Over.prodLeftIsoPullback_inv_snd</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>Over.iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-toOverUnit_map_left"><code>toOverUnit_map_left</code></a>, <a href="#CategoryTheory-instIsContinuousOverLeftDiscretePUnitIteratedSliceForwardOver"><code>instIsContinuousOverLeftDiscretePUnitIteratedSliceForwardOver</code></a>, <a href="#CategoryTheory-MonoOver-mapIso_counitIso"><code>MonoOver.mapIso_counitIso</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-comp_pushforward"><code>ExponentiableMorphism.comp_pushforward</code></a>, <a href="#CategoryTheory-Over-leftUnitor_hom_left"><code>Over.leftUnitor_hom_left</code></a>, <a href="#CategoryTheory-Over-isCommMonObj_mk_pullbackSnd"><code>Over.isCommMonObj_mk_pullbackSnd</code></a>, <a href="#CategoryTheory-Over-tensorObj_ext_iff"><code>Over.tensorObj_ext_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_right"><code>CostructuredArrow.toOver_map_right</code></a>, <a href="#HomotopicalAlgebra-instIsStableUnderRetractsOverFibrations"><code>HomotopicalAlgebra.instIsStableUnderRetractsOverFibrations</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_forget"><code>Over.iteratedSliceForward_forget</code></a>, <a href="#Types-monoOverEquivalenceSet_inverse_map"><code>Types.monoOverEquivalenceSet_inverse_map</code></a>, <a href="#CategoryTheory-toOverIsoToOverUnit_inv_app_left"><code>toOverIsoToOverUnit_inv_app_left</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivCounitIso_inv_app_hom_left"><code>Over.ConstructProducts.conesEquivCounitIso_inv_app_hom_left</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse'_obj_obj_right_as"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_right_as</code></a>, <a href="#CategoryTheory-MorphismProperty-baseChange_map"><code>MorphismProperty.baseChange_map</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>Over.postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-Over-conePost_obj_œÄ_app"><code>Over.conePost_obj_œÄ_app</code></a>, <a href="#CategoryTheory-MonoOver-mkArrowIso_hom_hom_left"><code>MonoOver.mkArrowIso_hom_hom_left</code></a>, <a href="#CategoryTheory-NatTrans-instIsClosedUnderLimitsOfShapeOverFunctorEquifiberedHomDiscretePUnitOfHasCoproductsOfShapeHom"><code>NatTrans.instIsClosedUnderLimitsOfShapeOverFunctorEquifiberedHomDiscretePUnitOfHasCoproductsOfShapeHom</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_hom"><code>CostructuredArrow.toOver_obj_hom</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_le_overEquiv_iff"><code>Sieve.overEquiv_le_overEquiv_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullOverToOver"><code>CostructuredArrow.instFullOverToOver</code></a>, <a href="#CategoryTheory-MonoOver-map_obj_left"><code>MonoOver.map_obj_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-snd'_left"><code>ChosenPullbacksAlong.snd'_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorObj_ext_iff"><code>ChosenPullbacksAlong.Over.tensorObj_ext_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-Over-rightUnitor_inv_left_fst"><code>Over.rightUnitor_inv_left_fst</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquiv_unitIso"><code>Over.ConstructProducts.conesEquiv_unitIso</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_map_left"><code>WithTerminal.commaFromOver_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorHom_left_snd_assoc"><code>ChosenPullbacksAlong.Over.tensorHom_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-MonoOver-isIso_hom_left_iff_subobjectMk_eq"><code>MonoOver.isIso_hom_left_iff_subobjectMk_eq</code></a>, <a href="#CategoryTheory-Over-mapCongr_inv_app_left"><code>Over.mapCongr_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimits-overPost"><code>Limits.PreservesFiniteLimits.overPost</code></a>, <a href="#CategoryTheory-Sieve-ofArrows_category"><code>Sieve.ofArrows_category</code></a>, <a href="#CategoryTheory-Over-mapCongr_hom_app_left"><code>Over.mapCongr_hom_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-rightUnitor_inv_left_snd"><code>ChosenPullbacksAlong.Over.rightUnitor_inv_left_snd</code></a>, <a href="#CategoryTheory-equivToOverUnit_unitIso"><code>equivToOverUnit_unitIso</code></a>, <a href="#CategoryTheory-Over-postCongr_inv_app_left"><code>Over.postCongr_inv_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_pullback_obj_left"><code>ChosenPullbacksAlong.isoInv_pullback_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Over-mapComp_hom_app_left"><code>Over.mapComp_hom_app_left</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse'_obj_obj_hom"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_hom</code></a>, <a href="#CategoryTheory-essentiallySmall_monoOver"><code>essentiallySmall_monoOver</code></a>, <a href="#CategoryTheory-Over-whiskerRight_left_fst"><code>Over.whiskerRight_left_fst</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_Œπ_app"><code>Limits.colimit.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_unit_app_left"><code>Over.postAdjunctionLeft_unit_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_str_comp_val_app"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_str_comp_val_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>CostructuredArrow.costructuredArrowToOverEquivalence.functor_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app"><code>GrothendieckTopology.pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-MonoOver-pullback_obj_arrow"><code>MonoOver.pullback_obj_arrow</code></a>, <a href="#CategoryTheory-Over-preservesTerminalIso_pullback"><code>Over.preservesTerminalIso_pullback</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_obj_right"><code>WithTerminal.commaFromOver_obj_right</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_inv_fst"><code>Over.prodLeftIsoPullback_inv_fst</code></a>, <a href="#CategoryTheory-Presheaf-isLimit_iff_isSheafFor_presieve"><code>Presheaf.isLimit_iff_isSheafFor_presieve</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_functor_obj_œÄ_app_star"><code>WithTerminal.coneEquiv_functor_obj_œÄ_app_star</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_counitIso_inv_app_hom"><code>WithTerminal.coneEquiv_counitIso_inv_app_hom</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>Over.opEquivOpUnder_inverse_obj</code></a>, <a href="#CategoryTheory-MorphismProperty-instFaithfulOverTopOverForget"><code>MorphismProperty.instFaithfulOverTopOverForget</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulOverToOver"><code>CostructuredArrow.instFaithfulOverToOver</code></a>, <a href="#AlgebraicGeometry-Scheme-kerAdjunction_unit_app"><code>AlgebraicGeometry.Scheme.kerAdjunction_unit_app</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_inv_snd_assoc"><code>Over.prodLeftIsoPullback_inv_snd_assoc</code></a>, <a href="#CategoryTheory-Over-rightUnitor_inv_left_snd"><code>Over.rightUnitor_inv_left_snd</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorObj_hom"><code>ChosenPullbacksAlong.Over.tensorObj_hom</code></a>, <a href="#CategoryTheory-Over-coprod_obj"><code>Over.coprod_obj</code></a>, <a href="#AlgebraicGeometry-instIsClosedImmersionLeftSchemeDiscretePUnitOneOverSpecOf"><code>AlgebraicGeometry.instIsClosedImmersionLeftSchemeDiscretePUnitOneOverSpecOf</code></a>, <a href="#CategoryTheory-Over-post_map"><code>Over.post_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsCocontinuousOverForgetOver"><code>GrothendieckTopology.instIsCocontinuousOverForgetOver</code></a>, <a href="#CategoryTheory-regularTopology-equalizerConditionMap_iff_nonempty_isLimit"><code>regularTopology.equalizerConditionMap_iff_nonempty_isLimit</code></a>, <a href="#CategoryTheory-Pseudofunctor-presheafHom_obj"><code>Pseudofunctor.presheafHom_obj</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowOverToOver"><code>instInitialCostructuredArrowOverToOver</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_counit_app"><code>Over.mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget"><code>Over.iteratedSliceBackward_forget</code></a>, <a href="#CategoryTheory-Over-postCongr_hom_app_left"><code>Over.postCongr_hom_app_left</code></a>, <a href="#CategoryTheory-toOverUnit_obj_left"><code>toOverUnit_obj_left</code></a>, <a href="#CategoryTheory-instInitiallySmallOverOfLocallySmall"><code>instInitiallySmallOverOfLocallySmall</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_functor_map_hom"><code>Limits.pullbackConeEquivBinaryFan_functor_map_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorObj_left"><code>ChosenPullbacksAlong.Over.tensorObj_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget_forget"><code>Over.iteratedSliceBackward_forget_forget</code></a>, <a href="#CategoryTheory-Over-instHasColimitsOfShape"><code>Over.instHasColimitsOfShape</code></a>, <a href="#CategoryTheory-presheafHom_obj"><code>presheafHom_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_fst"><code>ChosenPullbacksAlong.Over.associator_hom_left_fst</code></a>, <a href="#CategoryTheory-IsCofiltered-over"><code>IsCofiltered.over</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_hom_snd"><code>Over.prodLeftIsoPullback_hom_snd</code></a>, <a href="#CategoryTheory-Over-locallySmall"><code>Over.locallySmall</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_counitIso"><code>Limits.pullbackConeEquivBinaryFan_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_pullback_map_left"><code>ChosenPullbacksAlong.isoInv_pullback_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>CostructuredArrow.ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-GrothendieckTopology-coverPreserving_over_star"><code>GrothendieckTopology.coverPreserving_over_star</code></a>, <a href="#CategoryTheory-Over-whiskerRight_left_snd_assoc"><code>Over.whiskerRight_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-snd_eq_snd'"><code>ChosenPullbacksAlong.Over.snd_eq_snd'</code></a>, <a href="#CategoryTheory-Limits-IsLimit-pullbackConeEquivBinaryFanFunctor_lift_left"><code>Limits.IsLimit.pullbackConeEquivBinaryFanFunctor_lift_left</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_fst_fst_assoc"><code>Over.associator_inv_left_fst_fst_assoc</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_symm_iff"><code>Sieve.overEquiv_symm_iff</code></a>, <a href="#AlgebraicGeometry-Scheme-isCommMonObj_asOver_pullback"><code>AlgebraicGeometry.Scheme.isCommMonObj_asOver_pullback</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overEquiv_symm_mem_over"><code>GrothendieckTopology.overEquiv_symm_mem_over</code></a>, <a href="#CategoryTheory-Sieve-functorPushforward_over_map"><code>Sieve.functorPushforward_over_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_obj"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_obj</code></a>, <a href="#CategoryTheory-Over-epi_of_epi_left"><code>Over.epi_of_epi_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_fst"><code>Over.associator_hom_left_fst</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_forget_compatiblePreserving"><code>GrothendieckTopology.over_forget_compatiblePreserving</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_inv_app"><code>Limits.Cocone.toCostructuredArrowCompToOverCompForget_inv_app</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_inverse_map"><code>Subfunctor.equivalenceMonoOver_inverse_map</code></a>, <a href="#AlgebraicGeometry-Scheme-isMonHom_fst_id_right"><code>AlgebraicGeometry.Scheme.isMonHom_fst_id_right</code></a>, <a href="#CategoryTheory-Over-forgetAdjStar_counit_app"><code>Over.forgetAdjStar_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-leftUnitor_inv_left_snd"><code>ChosenPullbacksAlong.Over.leftUnitor_inv_left_snd</code></a>, <a href="#CategoryTheory-OverClass-asOverHom_inv"><code>OverClass.asOverHom_inv</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorUnit_hom"><code>ChosenPullbacksAlong.Over.tensorUnit_hom</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_hom_fst_assoc"><code>Over.prodLeftIsoPullback_hom_fst_assoc</code></a>, <a href="#CategoryTheory-Over-map_map_left"><code>Over.map_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerLeft_left_snd_assoc"><code>ChosenPullbacksAlong.Over.whiskerLeft_left_snd_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjOverToOver"><code>CostructuredArrow.instEssSurjOverToOver</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-pushforwardId_hom_counit_assoc"><code>ExponentiableMorphism.pushforwardId_hom_counit_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_snd_fst"><code>ChosenPullbacksAlong.Over.associator_hom_left_snd_fst</code></a>, <a href="#CategoryTheory-MonoOver-image_map"><code>MonoOver.image_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-mem_over_iff"><code>GrothendieckTopology.mem_over_iff</code></a>, <a href="#CategoryTheory-Over-tensorUnit_hom"><code>Over.tensorUnit_hom</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>Over.opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_functor_map"><code>Subfunctor.equivalenceMonoOver_functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-presheafHom_map_app"><code>presheafHom_map_app</code></a>, <a href="#AlgebraicGeometry-instFaithfulOverSchemePullbackOfSurjectiveOfFlatOfQuasiCompact"><code>AlgebraicGeometry.instFaithfulOverSchemePullbackOfSurjectiveOfFlatOfQuasiCompact</code></a>, <a href="#CategoryTheory-Limits-instPreservesCofilteredLimitsOfSizeOverForget"><code>Limits.instPreservesCofilteredLimitsOfSizeOverForget</code></a>, <a href="#CategoryTheory-Over-leftUnitor_inv_left_fst"><code>Over.leftUnitor_inv_left_fst</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_unit_app_left"><code>ChosenPullbacksAlong.isoInv_mapPullbackAdj_unit_app_left</code></a>, <a href="#CategoryTheory-Over-inv_left_hom_left"><code>Over.inv_left_hom_left</code></a>, <a href="#CategoryTheory-Over-starPullbackIsoStar_hom_app_left"><code>Over.starPullbackIsoStar_hom_app_left</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_map"><code>Over.equivalenceOfIsTerminal_inverse_map</code></a>, <a href="#CategoryTheory-Over-postEquiv_inverse"><code>Over.postEquiv_inverse</code></a>, <a href="#AlgebraicGeometry-opensDiagram_map"><code>AlgebraicGeometry.opensDiagram_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerRight_left"><code>ChosenPullbacksAlong.Over.whiskerRight_left</code></a>, <a href="#HomotopicalAlgebra-cofibrations_over_iff"><code>HomotopicalAlgebra.cofibrations_over_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_functor_obj_œÄ_app_of"><code>WithTerminal.coneEquiv_functor_obj_œÄ_app_of</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_inv_app"><code>Over.forgetMapTerminal_inv_app</code></a>, <a href="#HomotopicalAlgebra-trivialFibrations_over_eq"><code>HomotopicalAlgebra.trivialFibrations_over_eq</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_app"><code>ChosenPullbacksAlong.unit_pullbackId_hom_app</code></a>, <a href="#CategoryTheory-Over-instIsRightAdjointStar"><code>Over.instIsRightAdjointStar</code></a>, <a href="#CategoryTheory-Subobject-inf_eq_map_pullback'"><code>Subobject.inf_eq_map_pullback'</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_functor"><code>Over.equivalenceOfIsTerminal_functor</code></a>, <a href="#CategoryTheory-Over-preservesColimitsOfSize_map"><code>Over.preservesColimitsOfSize_map</code></a>, <a href="#CategoryTheory-OverClass-asOverHom_id"><code>OverClass.asOverHom_id</code></a>, <a href="#CategoryTheory-Presheaf-isSeparated_iff_subsingleton"><code>Presheaf.isSeparated_iff_subsingleton</code></a>, <a href="#CategoryTheory-Over-isoMk_inv_left"><code>Over.isoMk_inv_left</code></a>, <a href="#CategoryTheory-Over-conePostIso_hom_app_hom"><code>Over.conePostIso_hom_app_hom</code></a>, <a href="#CategoryTheory-Over-eqToHom_left"><code>Over.eqToHom_left</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_top"><code>Sieve.overEquiv_top</code></a>, <a href="#CategoryTheory-Over-mapComp_eq"><code>Over.mapComp_eq</code></a>, <a href="#CategoryTheory-Over-tensorHom_left_snd_assoc"><code>Over.tensorHom_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-rightUnitor_inv_left_snd_assoc"><code>ChosenPullbacksAlong.Over.rightUnitor_inv_left_snd_assoc</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsOverOverObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsOverOverObjOfRespectsIso</code></a>, <a href="#CategoryTheory-Over-mono_homMk"><code>Over.mono_homMk</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-ev_coev"><code>ExponentiableMorphism.ev_coev</code></a>, <a href="#CategoryTheory-monoOver_terminal_to_subterminals_comp"><code>monoOver_terminal_to_subterminals_comp</code></a>, <a href="#HomotopicalAlgebra-instIsStableUnderRetractsOverCofibrations"><code>HomotopicalAlgebra.instIsStableUnderRetractsOverCofibrations</code></a>, <a href="#CategoryTheory-Over-leftUnitor_inv_left_snd"><code>Over.leftUnitor_inv_left_snd</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-leftUnitor_inv_left_fst_assoc"><code>ChosenPullbacksAlong.Over.leftUnitor_inv_left_fst_assoc</code></a>, <a href="#AlgebraicGeometry-Scheme-kerAdjunction_counit_app"><code>AlgebraicGeometry.Scheme.kerAdjunction_counit_app</code></a>, <a href="#AlgebraicGeometry-opensDiagramŒπ_app"><code>AlgebraicGeometry.opensDiagramŒπ_app</code></a>, <a href="#CategoryTheory-Over-prodComparisonIso_pullback_inv_left_snd'"><code>Over.prodComparisonIso_pullback_inv_left_snd'</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_assoc_assoc"><code>GrothendieckTopology.overMapPullback_assoc_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_right_as</code></a>, <a href="#CategoryTheory-Over-preservesLimitsOfShape_forget_of_isConnected"><code>Over.preservesLimitsOfShape_forget_of_isConnected</code></a>, <a href="#CategoryTheory-MonoOver-image_obj"><code>MonoOver.image_obj</code></a>, <a href="#TopologicalSpace-Opens-coe_overEquivalence_functor_obj"><code>TopologicalSpace.Opens.coe_overEquivalence_functor_obj</code></a>, <a href="#CategoryTheory-OverClass-instIsIsoOverAsOverHom"><code>OverClass.instIsIsoOverAsOverHom</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_fst_snd'"><code>Over.Œº_pullback_left_fst_snd'</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_left</code></a>, <a href="#CategoryTheory-Over-comp_left"><code>Over.comp_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorUnit_left"><code>ChosenPullbacksAlong.Over.tensorUnit_left</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_unit_app"><code>Over.mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-MorphismProperty-Over-forget_comp_forget_map"><code>MorphismProperty.Over.forget_comp_forget_map</code></a>, <a href="#CategoryTheory-Over-mapId_inv_app_left"><code>Over.mapId_inv_app_left</code></a>, <a href="#AlgebraicGeometry-Scheme-AffineZariskiSite-restrictIsoSpec_hom_app"><code>AlgebraicGeometry.Scheme.AffineZariskiSite.restrictIsoSpec_hom_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-leftUnitor_inv_left_fst"><code>ChosenPullbacksAlong.Over.leftUnitor_inv_left_fst</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_symm_pullback"><code>Sieve.overEquiv_symm_pullback</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_inverse_obj"><code>Subfunctor.equivalenceMonoOver_inverse_obj</code></a>, <a href="#CategoryTheory-Over-leftUnitor_inv_left_snd_assoc"><code>Over.leftUnitor_inv_left_snd_assoc</code></a>, <a href="#TopCat-Presheaf-whiskerIsoMapGenerateCocone_inv_hom"><code>TopCat.Presheaf.whiskerIsoMapGenerateCocone_inv_hom</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivFunctor_map_hom"><code>Over.ConstructProducts.conesEquivFunctor_map_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_pullback_obj"><code>ChosenPullbacksAlong.iso_pullback_obj</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_inverse_obj_pt_left"><code>WithTerminal.coneEquiv_inverse_obj_pt_left</code></a>, <a href="#CategoryTheory-Presieve-functorPushforward_overForget"><code>Presieve.functorPushforward_overForget</code></a>, <a href="#CategoryTheory-Over-pullbackIsRightAdjoint"><code>Over.pullbackIsRightAdjoint</code></a>, <a href="#CategoryTheory-Over-conePost_map_hom"><code>Over.conePost_map_hom</code></a>, <a href="#AlgebraicGeometry-Scheme-mem_overGrothendieckTopology"><code>AlgebraicGeometry.Scheme.mem_overGrothendieckTopology</code></a>, <a href="#CategoryTheory-Over-over_hasTerminal"><code>Over.over_hasTerminal</code></a>, <a href="#CategoryTheory-MonoOver-bot_left"><code>MonoOver.bot_left</code></a>, <a href="#CategoryTheory-Presieve-ofArrows_category"><code>Presieve.ofArrows_category</code></a>, <a href="#CategoryTheory-Over-lift_obj"><code>Over.lift_obj</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_unitIso_hom_app_left"><code>TopologicalSpace.Opens.overEquivalence_unitIso_hom_app_left</code></a>, <a href="#AlgebraicGeometry-instIsAffineHomMapOverSchemeOpensDiagram"><code>AlgebraicGeometry.instIsAffineHomMapOverSchemeOpensDiagram</code></a>, <a href="#CategoryTheory-MonoOver-map_obj_arrow"><code>MonoOver.map_obj_arrow</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_inverse_obj"><code>Limits.pullbackConeEquivBinaryFan_inverse_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_functor_obj"><code>Limits.pullbackConeEquivBinaryFan_functor_obj</code></a>, <a href="#CategoryTheory-Over-map_obj_hom"><code>Over.map_obj_hom</code></a>, <a href="#CategoryTheory-Over-initial_forget"><code>Over.initial_forget</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_snd_fst"><code>Over.associator_hom_left_snd_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_left"><code>CostructuredArrow.toOver_map_left</code></a>, <a href="#CategoryTheory-Over-postComp_inv_app_left"><code>Over.postComp_inv_app_left</code></a>, <a href="#HomotopicalAlgebra-trivialCofibrations_over_eq"><code>HomotopicalAlgebra.trivialCofibrations_over_eq</code></a>, <a href="#CategoryTheory-Over-toOverSectionsAdj_unit_app"><code>Over.toOverSectionsAdj_unit_app</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_inverse_map"><code>subterminalsEquivMonoOverTerminal_inverse_map</code></a>, <a href="#CategoryTheory-Subobject-lower_comm"><code>Subobject.lower_comm</code></a>, <a href="#CategoryTheory-Functor-toOver_obj_left"><code>Functor.toOver_obj_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_str_id_val_app"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_str_id_val_app</code></a>, <a href="#CategoryTheory-Over-post_comp"><code>Over.post_comp</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_obj"><code>Over.equivalenceOfIsTerminal_inverse_obj</code></a>, <a href="#CategoryTheory-Over-rightUnitor_inv_left_snd_assoc"><code>Over.rightUnitor_inv_left_snd_assoc</code></a>, <a href="#CategoryTheory-Over-toOverSectionsAdj_counit_app"><code>Over.toOverSectionsAdj_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerRight_left_snd"><code>ChosenPullbacksAlong.Over.whiskerRight_left_snd</code></a>, <a href="#CategoryTheory-MonoOver-w"><code>MonoOver.w</code></a>, <a href="#CategoryTheory-MonoOver-bot_arrow_eq_zero"><code>MonoOver.bot_arrow_eq_zero</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda</code></a>, <a href="#CategoryTheory-forgetAdjToOver_unit_app"><code>forgetAdjToOver_unit_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>Over.iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-MonoOver-hasFiniteLimits"><code>MonoOver.hasFiniteLimits</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>Over.iteratedSliceEquivOverMapIso_hom_app_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>CostructuredArrow.costructuredArrowToOverEquivalence.functor_obj</code></a>, <a href="#CategoryTheory-WithTerminal-isLimitEquiv_symm_apply_lift"><code>WithTerminal.isLimitEquiv_symm_apply_lift</code></a>, <a href="#CategoryTheory-regularTopology-parallelPair_pullback_initial"><code>regularTopology.parallelPair_pullback_initial</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOver_obj_obj"><code>WithTerminal.liftFromOver_obj_obj</code></a>, <a href="#CategoryTheory-overToCoalgebra_map_f"><code>overToCoalgebra_map_f</code></a>, <a href="#CategoryTheory-Over-isRightAdjoint_post"><code>Over.isRightAdjoint_post</code></a>, <a href="#CategoryTheory-Pseudofunctor-isStackFor_iff"><code>Pseudofunctor.isStackFor_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_functor_obj"><code>Subfunctor.equivalenceMonoOver_functor_obj</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_pt"><code>Limits.Cocone.toOver_pt</code></a>, <a href="#CategoryTheory-Pseudofunctor-isPrestackFor_iff_isSheafFor"><code>Pseudofunctor.isPrestackFor_iff_isSheafFor</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerRight_left_snd_assoc"><code>ChosenPullbacksAlong.Over.whiskerRight_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerRight_left_fst_assoc"><code>ChosenPullbacksAlong.Over.whiskerRight_left_fst_assoc</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctorŒì_hom_app"><code>AlgebraicGeometry.Scheme.restrictFunctorŒì_hom_app</code></a>, <a href="#CategoryTheory-Pseudofunctor-bijective_toDescentData_map_iff"><code>Pseudofunctor.bijective_toDescentData_map_iff</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivUnitIso_inv_app_hom"><code>Over.ConstructProducts.conesEquivUnitIso_inv_app_hom</code></a>, <a href="#CategoryTheory-Over-pullback_map_left"><code>Over.pullback_map_left</code></a>, <a href="#CategoryTheory-instIsContinuousOverLeftDiscretePUnitIteratedSliceBackwardOver"><code>instIsContinuousOverLeftDiscretePUnitIteratedSliceBackwardOver</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_map"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_map</code></a>, <a href="#CategoryTheory-isEventuallyConstant_of_isArtinianObject"><code>isEventuallyConstant_of_isArtinianObject</code></a>, <a href="#CategoryTheory-Over-prodComparisonIso_pullback_inv_left_fst_fst"><code>Over.prodComparisonIso_pullback_inv_left_fst_fst</code></a>, <a href="#CategoryTheory-Pseudofunctor-presheafHom_map"><code>Pseudofunctor.presheafHom_map</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_inverse_obj_pt_hom"><code>WithTerminal.coneEquiv_inverse_obj_pt_hom</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>Over.postEquiv_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackId_hom_counit"><code>ChosenPullbacksAlong.pullbackId_hom_counit</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-ev_def"><code>ExponentiableMorphism.ev_def</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivCounitIso_hom_app_hom_left"><code>Over.ConstructProducts.conesEquivCounitIso_hom_app_hom_left</code></a>, <a href="#CategoryTheory-Over-sections_obj"><code>Over.sections_obj</code></a>, <a href="#AlgebraicGeometry-opensDiagram_obj"><code>AlgebraicGeometry.opensDiagram_obj</code></a>, <a href="#CategoryTheory-Over-star_obj_left"><code>Over.star_obj_left</code></a>, <a href="#AlgebraicGeometry-Scheme-instFullOppositeIdealSheafDataOverSubschemeFunctor"><code>AlgebraicGeometry.Scheme.instFullOppositeIdealSheafDataOverSubschemeFunctor</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOverComp_hom_app"><code>WithTerminal.liftFromOverComp_hom_app</code></a>, <a href="#CategoryTheory-equivToOverUnit_counitIso"><code>equivToOverUnit_counitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_functor"><code>Over.iteratedSliceEquiv_functor</code></a>, <a href="#AlgebraicGeometry-opensCone_œÄ_app"><code>AlgebraicGeometry.opensCone_œÄ_app</code></a>, <a href="#CategoryTheory-Over-tensorHom_left"><code>Over.tensorHom_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_hom_app_left"><code>toOverIteratedSliceForwardIsoPullback_hom_app_left</code></a>, <a href="#CategoryTheory-MonoOver-mk'_coe'"><code>MonoOver.mk'_coe'</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-ev_coev_assoc"><code>ExponentiableMorphism.ev_coev_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-Presheaf-isSheaf_iff_isLimit"><code>Presheaf.isSheaf_iff_isLimit</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_obj"><code>Under.opEquivOpOver_functor_obj</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquiv_counitIso"><code>Over.ConstructProducts.conesEquiv_counitIso</code></a>, <a href="#CategoryTheory-MonoOver-mono"><code>MonoOver.mono</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_fst_snd"><code>Over.associator_inv_left_fst_snd</code></a>, <a href="#CategoryTheory-MonoOver-forget_obj_left"><code>MonoOver.forget_obj_left</code></a>, <a href="#CategoryTheory-Subobject-instIsEquivalenceMonoOverRepresentative"><code>Subobject.instIsEquivalenceMonoOverRepresentative</code></a>, <a href="#CategoryTheory-Over-forget_obj"><code>Over.forget_obj</code></a>, <a href="#CategoryTheory-Over-closedUnderLimitsOfShape_pullback"><code>Over.closedUnderLimitsOfShape_pullback</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_hom_app_left"><code>toOverPullbackIsoToOver_hom_app_left</code></a>, <a href="#CategoryTheory-Over-star_obj_hom"><code>Over.star_obj_hom</code></a>, <a href="#CategoryTheory-Over-forgetPreservesConnectedLimits"><code>Over.forgetPreservesConnectedLimits</code></a>, <a href="#CategoryTheory-coalgebraToOver_obj"><code>coalgebraToOver_obj</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_snd_snd_assoc"><code>Over.associator_hom_left_snd_snd_assoc</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_pt"><code>Limits.Cone.overPost_pt</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-pushforwardComp_hom_counit_assoc"><code>ExponentiableMorphism.pushforwardComp_hom_counit_assoc</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-coev_def"><code>ExponentiableMorphism.coev_def</code></a>, <a href="#CategoryTheory-Over-liftCone_œÄ_app"><code>Over.liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>CostructuredArrow.ofCommaFstEquivalence_functor</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_counitIso_inv_app"><code>TopologicalSpace.Opens.overEquivalence_counitIso_inv_app</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceMapOfIsIso"><code>Over.instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_inv_app_comp_fst"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_inv_app_comp_fst</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_functor"><code>TopCat.Presheaf.generateEquivalenceOpensLe_functor</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_fst_fst'"><code>Over.Œº_pullback_left_fst_fst'</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_pullback_obj"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_pullback_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_map_right</code></a>, <a href="#Types-monoOverEquivalenceSet_functor_map"><code>Types.monoOverEquivalenceSet_functor_map</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_fst_snd"><code>Over.Œº_pullback_left_fst_snd</code></a>, <a href="#CategoryTheory-Over-whiskerRight_left"><code>Over.whiskerRight_left</code></a>, <a href="#CategoryTheory-Over-monObjMkPullbackSnd_one"><code>Over.monObjMkPullbackSnd_one</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_unitIso_inv_app_left"><code>TopologicalSpace.Opens.overEquivalence_unitIso_inv_app_left</code></a>, <a href="#AlgebraicGeometry-Scheme-IdealSheafData-subschemeFunctor_obj"><code>AlgebraicGeometry.Scheme.IdealSheafData.subschemeFunctor_obj</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-ev_naturality_assoc"><code>ExponentiableMorphism.ev_naturality_assoc</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>Over.opEquivOpUnder_counitIso</code></a>, <a href="#CategoryTheory-Over-hasFiniteLimits"><code>Over.hasFiniteLimits</code></a>, <a href="#AlgebraicGeometry-instIsOpenImmersionMapSchemeCompOverOverTopMorphismPropertyForgetForget"><code>AlgebraicGeometry.instIsOpenImmersionMapSchemeCompOverOverTopMorphismPropertyForgetForget</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_eq_eqToIso"><code>GrothendieckTopology.overMapPullbackCongr_eq_eqToIso</code></a>, <a href="#CategoryTheory-Over-hasColimit_of_hasColimit_comp_forget"><code>Over.hasColimit_of_hasColimit_comp_forget</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_inv_app_comp_snd"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_inv_app_comp_snd</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_left</code></a>, <a href="#CategoryTheory-toOverIsoToOverUnit_hom_app_left"><code>toOverIsoToOverUnit_hom_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_pullback_map"><code>ChosenPullbacksAlong.cartesianMonoidalCategorySnd_pullback_map</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_counitIso"><code>TopCat.Presheaf.generateEquivalenceOpensLe_counitIso</code></a>, <a href="#SheafOfModules-instIsLeftAdjointOverOverRingCatPushforwardIdSheafOver"><code>SheafOfModules.instIsLeftAdjointOverOverRingCatPushforwardIdSheafOver</code></a>, <a href="#CategoryTheory-Sieve-yonedaFamily_fromCocone_compatible"><code>Sieve.yonedaFamily_fromCocone_compatible</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_inverse_obj_obj"><code>subterminalsEquivMonoOverTerminal_inverse_obj_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerLeft_left_fst_assoc"><code>ChosenPullbacksAlong.Over.whiskerLeft_left_fst_assoc</code></a>, <a href="#AlgebraicGeometry-Scheme-monObjAsOverPullback_mul"><code>AlgebraicGeometry.Scheme.monObjAsOverPullback_mul</code></a>, <a href="#CategoryTheory-coalgebraEquivOver_counitIso"><code>coalgebraEquivOver_counitIso</code></a>, <a href="#CategoryTheory-Over-closedUnderLimitsOfShape_discrete_empty"><code>Over.closedUnderLimitsOfShape_discrete_empty</code></a>, <a href="#Types-monoOverEquivalenceSet_functor_obj"><code>Types.monoOverEquivalenceSet_functor_obj</code></a>, <a href="#CategoryTheory-MonoOver-hasLimitsOfShape"><code>MonoOver.hasLimitsOfShape</code></a>, <a href="#AlgebraicGeometry-Scheme-kerFunctor_map"><code>AlgebraicGeometry.Scheme.kerFunctor_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackId_hom_counit_assoc"><code>ChosenPullbacksAlong.pullbackId_hom_counit_assoc</code></a>, <a href="#CategoryTheory-MonoOver-congr_functor"><code>MonoOver.congr_functor</code></a>, <a href="#CategoryTheory-Pseudofunctor-IsStack-essSurj_of_sieve"><code>Pseudofunctor.IsStack.essSurj_of_sieve</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_fst_fst"><code>Over.associator_inv_left_fst_fst</code></a>, <a href="#CategoryTheory-Presieve-isSheafFor_over_map_op_comp_ofArrows_iff"><code>Presieve.isSheafFor_over_map_op_comp_ofArrows_iff</code></a>, <a href="#CategoryTheory-Presieve-isSheafFor_over_map_op_comp_iff"><code>Presieve.isSheafFor_over_map_op_comp_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-MonoOver-isIso_iff_isIso_hom_left"><code>MonoOver.isIso_iff_isIso_hom_left</code></a>, <a href="#CategoryTheory-instHasLimitsOfShapeOverOfWithTerminal"><code>instHasLimitsOfShapeOverOfWithTerminal</code></a>, <a href="#CategoryTheory-Over-snd_left"><code>Over.snd_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_hom_app_comp_snd"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_hom_app_comp_snd</code></a>, <a href="#CategoryTheory-MonoOver-congr_inverse"><code>MonoOver.congr_inverse</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorHom_left_fst_assoc"><code>ChosenPullbacksAlong.Over.tensorHom_left_fst_assoc</code></a>, <a href="#CategoryTheory-instIsCocontinuousOverLeftDiscretePUnitIteratedSliceBackwardOver"><code>instIsCocontinuousOverLeftDiscretePUnitIteratedSliceBackwardOver</code></a>, <a href="#CategoryTheory-Over-tensorHom_left_fst"><code>Over.tensorHom_left_fst</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_symm_generate"><code>Sieve.overEquiv_symm_generate</code></a>, <a href="#CategoryTheory-Over-whiskerRight_left_snd"><code>Over.whiskerRight_left_snd</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-pullbackCoverOver_f"><code>AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_f</code></a>, <a href="#CategoryTheory-Over-conePostIso_inv_app_hom"><code>Over.conePostIso_inv_app_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackComp_hom_counit"><code>ChosenPullbacksAlong.pullbackComp_hom_counit</code></a>, <a href="#TopCat-Presheaf-whiskerIsoMapGenerateCocone_hom_hom"><code>TopCat.Presheaf.whiskerIsoMapGenerateCocone_hom_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_fst_snd_assoc"><code>ChosenPullbacksAlong.Over.associator_inv_left_fst_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_fst_snd"><code>ChosenPullbacksAlong.Over.associator_inv_left_fst_snd</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_obj_hom_app"><code>WithTerminal.commaFromOver_obj_hom_app</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-toPresieveOver_le_arrows_iff"><code>AlgebraicGeometry.Scheme.Cover.toPresieveOver_le_arrows_iff</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>Over.iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Classifier-SubobjectRepresentableBy-iso_inv_left_œÄ_assoc"><code>Classifier.SubobjectRepresentableBy.iso_inv_left_œÄ_assoc</code></a>, <a href="#CategoryTheory-Over-isoMk_hom_left"><code>Over.isoMk_hom_left</code></a>, <a href="#HomotopicalAlgebra-fibrations_over_def"><code>HomotopicalAlgebra.fibrations_over_def</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerRight_left_fst"><code>ChosenPullbacksAlong.Over.whiskerRight_left_fst</code></a>, <a href="#CategoryTheory-Functor-toOver_map_left"><code>Functor.toOver_map_left</code></a>, <a href="#CategoryTheory-Over-star_map_left"><code>Over.star_map_left</code></a>, <a href="#CategoryTheory-Over-tensorHom_left_fst_assoc"><code>Over.tensorHom_left_fst_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_snd_assoc"><code>ChosenPullbacksAlong.Over.associator_inv_left_snd_assoc</code></a>, <a href="#CategoryTheory-forgetAdjToOver-homEquiv_symm"><code>forgetAdjToOver.homEquiv_symm</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-overEquiv_generate_toPresieveOver_eq_ofArrows"><code>AlgebraicGeometry.Scheme.Cover.overEquiv_generate_toPresieveOver_eq_ofArrows</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_inv_fst_assoc"><code>Over.prodLeftIsoPullback_inv_fst_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-rightUnitor_hom_left"><code>ChosenPullbacksAlong.Over.rightUnitor_hom_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_map_val_app"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_map_val_app</code></a>, <a href="#HomotopicalAlgebra-cofibrations_over_def"><code>HomotopicalAlgebra.cofibrations_over_def</code></a>, <a href="#CategoryTheory-Subobject-lowerEquivalence_counitIso"><code>Subobject.lowerEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Pseudofunctor-IsPrestack-isSheaf"><code>Pseudofunctor.IsPrestack.isSheaf</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_functor_map"><code>subterminalsEquivMonoOverTerminal_functor_map</code></a>, <a href="#CategoryTheory-Over-Œ∑_pullback_left"><code>Over.Œ∑_pullback_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_comp_id_assoc"><code>GrothendieckTopology.overMapPullback_comp_id_assoc</code></a>, <a href="#CategoryTheory-Pseudofunctor-presheafHomObjHomEquiv_apply"><code>Pseudofunctor.presheafHomObjHomEquiv_apply</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-coev_ev_assoc"><code>ExponentiableMorphism.coev_ev_assoc</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>Over.postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-Over-conePost_obj_pt"><code>Over.conePost_obj_pt</code></a>, <a href="#CategoryTheory-Over-id_left"><code>Over.id_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-leftUnitor_hom_left"><code>ChosenPullbacksAlong.Over.leftUnitor_hom_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_pullback_obj"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryFst_pullback_obj</code></a>, <a href="#CategoryTheory-Over-postComp_hom_app_left"><code>Over.postComp_hom_app_left</code></a>, <a href="#CategoryTheory-HasLiftingProperty-over"><code>HasLiftingProperty.over</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-generatingMonomorphisms-functorToMonoOver_map"><code>IsGrothendieckAbelian.generatingMonomorphisms.functorToMonoOver_map</code></a>, <a href="#CategoryTheory-Over-instHasFiniteColimits"><code>Over.instHasFiniteColimits</code></a>, <a href="#CategoryTheory-Over-whiskerLeft_left_fst"><code>Over.whiskerLeft_left_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>CostructuredArrow.ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-MonoOver-inf_map_app"><code>MonoOver.inf_map_app</code></a>, <a href="#CategoryTheory-MonoOver-isThin"><code>MonoOver.isThin</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_counit_app_left"><code>ChosenPullbacksAlong.isoInv_mapPullbackAdj_counit_app_left</code></a>, <a href="#CategoryTheory-Over-post_obj"><code>Over.post_obj</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquiv_functor"><code>Over.ConstructProducts.conesEquiv_functor</code></a>, <a href="#CategoryTheory-MonoOver-mkArrowIso_inv_hom_left"><code>MonoOver.mkArrowIso_inv_hom_left</code></a>, <a href="#CategoryTheory-Over-epi_homMk"><code>Over.epi_homMk</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_hom_app"><code>Limits.Cocone.toCostructuredArrowCompToOverCompForget_hom_app</code></a>, <a href="#CategoryTheory-MorphismProperty-Over-instPreservesFiniteLimitsTopOverForget"><code>MorphismProperty.Over.instPreservesFiniteLimitsTopOverForget</code></a>, <a href="#CategoryTheory-Pseudofunctor-isPrestackFor_iff"><code>Pseudofunctor.isPrestackFor_iff</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-lift_left"><code>ChosenPullbacksAlong.Over.lift_left</code></a>, <a href="#CategoryTheory-Over-mapId_hom_app_left"><code>Over.mapId_hom_app_left</code></a>, <a href="#CategoryTheory-Limits-PreservesLimitsOfSize-overPost"><code>Limits.PreservesLimitsOfSize.overPost</code></a>, <a href="#CategoryTheory-Presieve-map_functorPullback_overForget"><code>Presieve.map_functorPullback_overForget</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_map_right"><code>WithTerminal.commaFromOver_map_right</code></a>, <a href="#CategoryTheory-MonoOver-w_assoc"><code>MonoOver.w_assoc</code></a>, <a href="#CategoryTheory-Over-forget_reflects_iso"><code>Over.forget_reflects_iso</code></a>, <a href="#CategoryTheory-Over-isPullback_of_binaryFan_isLimit"><code>Over.isPullback_of_binaryFan_isLimit</code></a>, <a href="#CategoryTheory-Pseudofunctor-IsStackFor-isEquivalence"><code>Pseudofunctor.IsStackFor.isEquivalence</code></a>, <a href="#CategoryTheory-Classifier-SubobjectRepresentableBy-iso_inv_hom_left_comp_assoc"><code>Classifier.SubobjectRepresentableBy.iso_inv_hom_left_comp_assoc</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-over_products_of_widePullbacks"><code>Over.ConstructProducts.over_products_of_widePullbacks</code></a>, <a href="#CategoryTheory-MorphismProperty-instFullOverTopOverForget"><code>MorphismProperty.instFullOverTopOverForget</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-Over-whiskerLeft_left_fst_assoc"><code>Over.whiskerLeft_left_fst_assoc</code></a>, <a href="#CategoryTheory-MonoOver-pullback_obj_left"><code>MonoOver.pullback_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left</code></a>, <a href="#AlgebraicGeometry-instIsOpenImmersionAppOverSchemeOpensDiagramŒπ"><code>AlgebraicGeometry.instIsOpenImmersionAppOverSchemeOpensDiagramŒπ</code></a>, <a href="#CategoryTheory-Over-instFaithfulObjPost"><code>Over.instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Subobject-lowerEquivalence_unitIso"><code>Subobject.lowerEquivalence_unitIso</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_map"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_map</code></a>, <a href="#CategoryTheory-Over-coprodObj_obj"><code>Over.coprodObj_obj</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_inv_app_val_app"><code>GrothendieckTopology.overMapPullbackComp_inv_app_val_app</code></a>, <a href="#AlgebraicGeometry-isClosedImmersion_equalizer_Œπ_left"><code>AlgebraicGeometry.isClosedImmersion_equalizer_Œπ_left</code></a>, <a href="#CategoryTheory-Iso-asOver_inv"><code>Iso.asOver_inv</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_fst_fst"><code>ChosenPullbacksAlong.Over.associator_inv_left_fst_fst</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_pullback_obj"><code>ChosenPullbacksAlong.cartesianMonoidalCategorySnd_pullback_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_unitIso"><code>Subfunctor.equivalenceMonoOver_unitIso</code></a>, <a href="#CategoryTheory-Over-prodComparisonIso_pullback_Spec_inv_left_fst_fst'"><code>Over.prodComparisonIso_pullback_Spec_inv_left_fst_fst'</code></a>, <a href="#AlgebraicGeometry-Scheme-instLocallyCoverDenseOverTopMorphismPropertyOverForgetOverGrothendieckTopology"><code>AlgebraicGeometry.Scheme.instLocallyCoverDenseOverTopMorphismPropertyOverForgetOverGrothendieckTopology</code></a>, <a href="#CategoryTheory-MonoOver-subobjectMk_le_mk_of_hom"><code>MonoOver.subobjectMk_le_mk_of_hom</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-over_binaryProduct_of_pullback"><code>Over.ConstructProducts.over_binaryProduct_of_pullback</code></a>, <a href="#CategoryTheory-Over-whiskerLeft_left_snd_assoc"><code>Over.whiskerLeft_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom"><code>ChosenPullbacksAlong.unit_pullbackId_hom</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>Over.equivalenceOfIsTerminal_unitIso</code></a>, <a href="#TopologicalSpace-Opens-coe_overEquivalence_inverse_obj_left"><code>TopologicalSpace.Opens.coe_overEquivalence_inverse_obj_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>Over.iteratedSliceEquiv_counitIso</code></a>, <a href="#HomotopicalAlgebra-instHasFactorizationOverTrivialCofibrationsFibrations"><code>HomotopicalAlgebra.instHasFactorizationOverTrivialCofibrationsFibrations</code></a>, <a href="#CategoryTheory-Over-leftUnitor_inv_left_fst_assoc"><code>Over.leftUnitor_inv_left_fst_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerLeft_left"><code>ChosenPullbacksAlong.Over.whiskerLeft_left</code></a>, <a href="#CategoryTheory-Sieve-forallYonedaIsSheaf_iff_colimit"><code>Sieve.forallYonedaIsSheaf_iff_colimit</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOver_obj_map"><code>WithTerminal.liftFromOver_obj_map</code></a>, <a href="#CategoryTheory-equivToOverUnit_inverse"><code>equivToOverUnit_inverse</code></a>, <a href="#CategoryTheory-Over-liftCocone_Œπ_app"><code>Over.liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Over-instHasFiniteCoproducts"><code>Over.instHasFiniteCoproducts</code></a>, <a href="#HomotopicalAlgebra-instHasTwoOutOfThreePropertyOverWeakEquivalences"><code>HomotopicalAlgebra.instHasTwoOutOfThreePropertyOverWeakEquivalences</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-coev_naturality_assoc"><code>ExponentiableMorphism.coev_naturality_assoc</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_inv_hom"><code>Limits.Cocone.mapCoconeToOver_inv_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-WithTerminal-isLimitEquiv_apply_lift_left"><code>WithTerminal.isLimitEquiv_apply_lift_left</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_unitIso"><code>subterminalsEquivMonoOverTerminal_unitIso</code></a>, <a href="#CategoryTheory-overToCoalgebra_obj_A"><code>overToCoalgebra_obj_A</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>Over.postEquiv_unitIso</code></a>, <a href="#CategoryTheory-coalgebraToOver_map"><code>coalgebraToOver_map</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-pushforwardComp_hom_counit"><code>ExponentiableMorphism.pushforwardComp_hom_counit</code></a>, <a href="#CategoryTheory-Pseudofunctor-IsStackFor-essSurj"><code>Pseudofunctor.IsStackFor.essSurj</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_Œ±"><code>GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj_Œ±</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_fst_snd_assoc"><code>Over.associator_inv_left_fst_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app"><code>ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-MonoOver-forget_obj_hom"><code>MonoOver.forget_obj_hom</code></a>, <a href="#CategoryTheory-Classifier-SubobjectRepresentableBy-iso_inv_left_comp"><code>Classifier.SubobjectRepresentableBy.iso_inv_left_comp</code></a>, <a href="#CategoryTheory-Over-rightUnitor_hom_left"><code>Over.rightUnitor_hom_left</code></a>, <a href="#CategoryTheory-Functor-over_forget_locallyCoverDense"><code>Functor.over_forget_locallyCoverDense</code></a>, <a href="#CategoryTheory-Over-instHasPullbacks"><code>Over.instHasPullbacks</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivFunctor_obj_pt"><code>Over.ConstructProducts.conesEquivFunctor_obj_pt</code></a>, <a href="#CategoryTheory-toOver_map_left"><code>toOver_map_left</code></a>, <a href="#CategoryTheory-Over-sections_map"><code>Over.sections_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-fst'_left"><code>ChosenPullbacksAlong.fst'_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_right</code></a>, <a href="#CategoryTheory-MonoOver-commSqOfHasStrongEpiMonoFactorisation"><code>MonoOver.commSqOfHasStrongEpiMonoFactorisation</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-over_finiteProducts_of_finiteWidePullbacks"><code>Over.ConstructProducts.over_finiteProducts_of_finiteWidePullbacks</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-coev_naturality"><code>ExponentiableMorphism.coev_naturality</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_snd"><code>Over.Œº_pullback_left_snd</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_obj"><code>Over.iteratedSliceBackward_obj</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_counitIso"><code>subterminalsEquivMonoOverTerminal_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>CostructuredArrow.ofDiagEquivalence.inverse_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-toUnit_left"><code>ChosenPullbacksAlong.Over.toUnit_left</code></a>, <a href="#CategoryTheory-Over-mapFunctor_obj"><code>Over.mapFunctor_obj</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_unitIso_inv_app_hom_left"><code>WithTerminal.coneEquiv_unitIso_inv_app_hom_left</code></a>, <a href="#CategoryTheory-Classifier-SubobjectRepresentableBy-iso_inv_left_œÄ"><code>Classifier.SubobjectRepresentableBy.iso_inv_left_œÄ</code></a>, <a href="#CategoryTheory-Over-map_obj_left"><code>Over.map_obj_left</code></a>, <a href="#AlgebraicGeometry-instIsLocallyDirectedCompSchemeOverOverTopMorphismPropertyForgetForgetForget"><code>AlgebraicGeometry.instIsLocallyDirectedCompSchemeOverOverTopMorphismPropertyForgetForgetForget</code></a>, <a href="#Types-monoOverEquivalenceSet_inverse_obj"><code>Types.monoOverEquivalenceSet_inverse_obj</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-unit_pushforwardId_hom"><code>ExponentiableMorphism.unit_pushforwardId_hom</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_symm_top"><code>Sieve.overEquiv_symm_top</code></a>, <a href="#CategoryTheory-MonoOver-hasLimit"><code>MonoOver.hasLimit</code></a>, <a href="#CategoryTheory-PresheafHom-IsSheafFor-app_cond"><code>PresheafHom.IsSheafFor.app_cond</code></a>, <a href="#CategoryTheory-coalgebraEquivOver_inverse"><code>coalgebraEquivOver_inverse</code></a>, <a href="#CategoryTheory-Over-instFullObjPostOfFaithful"><code>Over.instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Over-instEssSurjObjPostOfFull"><code>Over.instEssSurjObjPostOfFull</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivUnitIso_hom_app_hom"><code>Over.ConstructProducts.conesEquivUnitIso_hom_app_hom</code></a>, <a href="#CategoryTheory-Over-braiding_hom_left"><code>Over.braiding_hom_left</code></a>, <a href="#CategoryTheory-MonoOver-instMonoHomDiscretePUnitObjOverForget"><code>MonoOver.instMonoHomDiscretePUnitObjOverForget</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_snd"><code>ChosenPullbacksAlong.Over.associator_inv_left_snd</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_pullback_obj_hom"><code>ChosenPullbacksAlong.isoInv_pullback_obj_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_counit_app"><code>ChosenPullbacksAlong.iso_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_hom_app_val_app"><code>GrothendieckTopology.overMapPullbackComp_hom_app_val_app</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-surjectivity-F_obj"><code>IsGrothendieckAbelian.IsPresentable.surjectivity.F_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-whiskerLeft_left_snd"><code>ChosenPullbacksAlong.Over.whiskerLeft_left_snd</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_snd_snd"><code>ChosenPullbacksAlong.Over.associator_hom_left_snd_snd</code></a>, <a href="#CategoryTheory-overToCoalgebra_obj_a"><code>overToCoalgebra_obj_a</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_pullback_obj_right_as"><code>ChosenPullbacksAlong.isoInv_pullback_obj_right_as</code></a>, <a href="#CategoryTheory-FunctorToTypes-mem_fromOverSubfunctor_iff"><code>FunctorToTypes.mem_fromOverSubfunctor_iff</code></a>, <a href="#CategoryTheory-Over-Œº_pullback_left_fst_fst"><code>Over.Œº_pullback_left_fst_fst</code></a>, <a href="#CategoryTheory-Over-starPullbackIsoStar_inv_app_left"><code>Over.starPullbackIsoStar_inv_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsContinuousOverForgetOver"><code>GrothendieckTopology.instIsContinuousOverForgetOver</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_map"><code>Over.iteratedSliceForward_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_id_comp_assoc"><code>GrothendieckTopology.overMapPullback_id_comp_assoc</code></a>, <a href="#AlgebraicGeometry-Scheme-instFullEtaleOverForget"><code>AlgebraicGeometry.Scheme.instFullEtaleOverForget</code></a>, <a href="#CategoryTheory-MonoOver-inf_obj"><code>MonoOver.inf_obj</code></a>, <a href="#AlgebraicGeometry-Scheme-Cover-pullbackCoverOver'_f"><code>AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_f</code></a>, <a href="#CategoryTheory-MonoOver-top_left"><code>MonoOver.top_left</code></a>, <a href="#CategoryTheory-Over-tensorUnit_left"><code>Over.tensorUnit_left</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-Over-hom_left_inv_left_assoc"><code>Over.hom_left_inv_left_assoc</code></a>, <a href="#CategoryTheory-MorphismProperty-faithful_overPullback_of_isomorphisms_descendAlong"><code>MorphismProperty.faithful_overPullback_of_isomorphisms_descendAlong</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_pullback_map"><code>ChosenPullbacksAlong.iso_pullback_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>Under.opEquivOpOver_inverse_obj</code></a>, <a href="#CategoryTheory-PresheafHom-IsSheafFor-exists_app"><code>PresheafHom.IsSheafFor.exists_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivInverse_obj"><code>Over.ConstructProducts.conesEquivInverse_obj</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app"><code>GrothendieckTopology.pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-OverClass-asOverHom_comp"><code>OverClass.asOverHom_comp</code></a>, <a href="#Types-monoOverEquivalenceSet_unitIso"><code>Types.monoOverEquivalenceSet_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>CostructuredArrow.ofCommaFstEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>CostructuredArrow.costructuredArrowToOverEquivalence.inverse_obj</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_inverse"><code>Over.iteratedSliceEquiv_inverse</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse'_obj_obj_left"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_left</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-unit_pushforwardId_hom_assoc"><code>ExponentiableMorphism.unit_pushforwardId_hom_assoc</code></a>, <a href="#AlgebraicGeometry-Scheme-kerFunctor_obj"><code>AlgebraicGeometry.Scheme.kerFunctor_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_hom_app_comp_fst_assoc"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_hom_app_comp_fst_assoc</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-ev_naturality"><code>ExponentiableMorphism.ev_naturality</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-generatingMonomorphisms-functorToMonoOver_obj"><code>IsGrothendieckAbelian.generatingMonomorphisms.functorToMonoOver_obj</code></a>, <a href="#CategoryTheory-Over-forgetCocone_Œπ_app"><code>Over.forgetCocone_Œπ_app</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOverComp_inv_app"><code>WithTerminal.liftFromOverComp_inv_app</code></a>, <a href="#CategoryTheory-coalgebraEquivOver_unitIso"><code>coalgebraEquivOver_unitIso</code></a>, <a href="#CategoryTheory-Over-whiskerRight_left_fst_assoc"><code>Over.whiskerRight_left_fst_assoc</code></a>, <a href="#CategoryTheory-Over-tensorHom_left_snd"><code>Over.tensorHom_left_snd</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>Limits.Cone.overPost_œÄ_app</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>Under.opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-equivToOverUnit_functor"><code>equivToOverUnit_functor</code></a>, <a href="#CategoryTheory-Over-forget_map"><code>Over.forget_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_hom_app_val_app"><code>GrothendieckTopology.overMapPullbackCongr_hom_app_val_app</code></a>, <a href="#CategoryTheory-Subobject-representative_coe"><code>Subobject.representative_coe</code></a>, <a href="#CategoryTheory-MonoOver-full_map"><code>MonoOver.full_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_toOver"><code>CostructuredArrow.isEquivalence_toOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOver_map_app"><code>WithTerminal.liftFromOver_map_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackComp_hom"><code>ChosenPullbacksAlong.unit_pullbackComp_hom</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_generate"><code>Sieve.overEquiv_generate</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_inverse_map_hom_left"><code>WithTerminal.coneEquiv_inverse_map_hom_left</code></a>, <a href="#CategoryTheory-Over-postMap_app"><code>Over.postMap_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsContinuousOverMapOver"><code>GrothendieckTopology.instIsContinuousOverMapOver</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivInverseObj_œÄ_app"><code>Over.ConstructProducts.conesEquivInverseObj_œÄ_app</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-unit_pushforwardComp_hom"><code>ExponentiableMorphism.unit_pushforwardComp_hom</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_inverse_obj_right_as"><code>TopologicalSpace.Opens.overEquivalence_inverse_obj_right_as</code></a>, <a href="#AlgebraicGeometry-instIsQuasicoherentOpensCarrierCarrierCommRingCatSpecTilde"><code>AlgebraicGeometry.instIsQuasicoherentOpensCarrierCarrierCommRingCatSpecTilde</code></a>, <a href="#CategoryTheory-MonoOver-mapIso_inverse"><code>MonoOver.mapIso_inverse</code></a>, <a href="#CategoryTheory-Presheaf-isLimit_iff_isSheafFor"><code>Presheaf.isLimit_iff_isSheafFor</code></a>, <a href="#CategoryTheory-Over-instHasEqualizers"><code>Over.instHasEqualizers</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_inv_app_comp_fst_assoc"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_inv_app_comp_fst_assoc</code></a>, <a href="#CategoryTheory-Over-lift_left"><code>Over.lift_left</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctor_obj_left"><code>AlgebraicGeometry.Scheme.restrictFunctor_obj_left</code></a>, <a href="#CategoryTheory-MonoOver-congr_counitIso"><code>MonoOver.congr_counitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>Over.opEquivOpUnder_functor_map</code></a>, <a href="#AlgebraicGeometry-instPreservesColimitOverSchemeTopMorphismPropertyOverForget"><code>AlgebraicGeometry.instPreservesColimitOverSchemeTopMorphismPropertyOverForget</code></a>, <a href="#CategoryTheory-PresheafHom-isAmalgamation_iff"><code>PresheafHom.isAmalgamation_iff</code></a>, <a href="#CategoryTheory-Subobject-lowerEquivalence_inverse"><code>Subobject.lowerEquivalence_inverse</code></a>, <a href="#CategoryTheory-Subobject-lowerEquivalence_functor"><code>Subobject.lowerEquivalence_functor</code></a>, <a href="#CategoryTheory-OverPresheafAux-costructuredArrowPresheafToOver_obj"><code>OverPresheafAux.costructuredArrowPresheafToOver_obj</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_map_compatiblePreserving"><code>GrothendieckTopology.over_map_compatiblePreserving</code></a>, <a href="#AlgebraicGeometry-instMonoObjWalkingSpanCompOverSchemeTopMorphismPropertySpanOverForgetForgetForgetNoneWalkingPairSomeMapInitOfIsOpenImmersionLeftDiscretePUnit"><code>AlgebraicGeometry.instMonoObjWalkingSpanCompOverSchemeTopMorphismPropertySpanOverForgetForgetForgetNoneWalkingPairSomeMapInitOfIsOpenImmersionLeftDiscretePUnit</code></a>, <a href="#CategoryTheory-Over-mapIso_functor"><code>Over.mapIso_functor</code></a>, <a href="#AlgebraicGeometry-Scheme-monObjAsOverPullback_one"><code>AlgebraicGeometry.Scheme.monObjAsOverPullback_one</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_pullback_map"><code>ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_pullback_map</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_colimit"><code>Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_colimit</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctor_map_left"><code>AlgebraicGeometry.Scheme.restrictFunctor_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_hom_app_comp_fst"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_hom_app_comp_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda"><code>CostructuredArrow.overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_functor'_map"><code>TopCat.Presheaf.generateEquivalenceOpensLe_functor'_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_hom_hom"><code>Limits.Cocone.mapCoconeToOver_hom_hom</code></a>, <a href="#HomotopicalAlgebra-weakEquivalences_over_iff"><code>HomotopicalAlgebra.weakEquivalences_over_iff</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_unitIso"><code>Under.opEquivOpOver_unitIso</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-over_product_of_widePullback"><code>Over.ConstructProducts.over_product_of_widePullback</code></a>, <a href="#CategoryTheory-sheafHomSectionsEquiv_symm_apply_coe_apply"><code>sheafHomSectionsEquiv_symm_apply_coe_apply</code></a>, <a href="#CategoryTheory-Subobject-thinSkeleton_mk_representative_eq_self"><code>Subobject.thinSkeleton_mk_representative_eq_self</code></a>, <a href="#CategoryTheory-Over-mkIdTerminal_from_left"><code>Over.mkIdTerminal_from_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-fst_eq_fst'"><code>ChosenPullbacksAlong.Over.fst_eq_fst'</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_functor_obj_pt"><code>WithTerminal.coneEquiv_functor_obj_pt</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>Under.opEquivOpOver_functor_map</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquiv_inverse"><code>Over.ConstructProducts.conesEquiv_inverse</code></a>, <a href="#HomotopicalAlgebra-instHasFactorizationOverCofibrationsTrivialFibrations"><code>HomotopicalAlgebra.instHasFactorizationOverCofibrationsTrivialFibrations</code></a>, <a href="#CategoryTheory-Functor-essImage_overPost"><code>Functor.essImage_overPost</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_obj_left"><code>WithTerminal.commaFromOver_obj_left</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_counitIso_hom_app"><code>TopologicalSpace.Opens.overEquivalence_counitIso_hom_app</code></a>, <a href="#CategoryTheory-Over-fst_left"><code>Over.fst_left</code></a>, <a href="#CategoryTheory-Over-prodLeftIsoPullback_hom_fst"><code>Over.prodLeftIsoPullback_hom_fst</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_assoc"><code>GrothendieckTopology.overMapPullback_assoc</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_fst_assoc"><code>Over.associator_hom_left_fst_assoc</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-pushforwardId_hom_counit"><code>ExponentiableMorphism.pushforwardId_hom_counit</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_unitIso"><code>Limits.pullbackConeEquivBinaryFan_unitIso</code></a>, <a href="#CategoryTheory-Pseudofunctor-presheafHomObjHomEquiv_symm_apply"><code>Pseudofunctor.presheafHomObjHomEquiv_symm_apply</code></a>, <a href="#CategoryTheory-Over-isMonHom_pullbackFst_id_right"><code>Over.isMonHom_pullbackFst_id_right</code></a>, <a href="#CategoryTheory-over_toGrothendieck_eq_toGrothendieck_comap_forget"><code>over_toGrothendieck_eq_toGrothendieck_comap_forget</code></a>, <a href="#CategoryTheory-Over-pullback_obj_hom"><code>Over.pullback_obj_hom</code></a>, <a href="#CategoryTheory-FunctorToTypes-instIsCofilteredElementsOverFromOverFunctor"><code>FunctorToTypes.instIsCofilteredElementsOverFromOverFunctor</code></a>, <a href="#CategoryTheory-Over-forgetAdjStar_unit_app_left"><code>Over.forgetAdjStar_unit_app_left</code></a>, <a href="#CategoryTheory-Pseudofunctor-isPrestackFor_iff_isSheafFor'"><code>Pseudofunctor.isPrestackFor_iff_isSheafFor'</code></a>, <a href="#CategoryTheory-Over-mapFunctor_map"><code>Over.mapFunctor_map</code></a>, <a href="#CategoryTheory-Over-mapCongr_rfl"><code>Over.mapCongr_rfl</code></a>, <a href="#CategoryTheory-isEventuallyConstant_of_isNoetherianObject"><code>isEventuallyConstant_of_isNoetherianObject</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullback_id_comp"><code>GrothendieckTopology.overMapPullback_id_comp</code></a>, <a href="#CategoryTheory-Over-tensorObj_left"><code>Over.tensorObj_left</code></a>, <a href="#CategoryTheory-MonoOver-faithful_exists"><code>MonoOver.faithful_exists</code></a>, <a href="#CategoryTheory-isNoetherianObject_iff_isEventuallyConstant"><code>isNoetherianObject_iff_isEventuallyConstant</code></a>, <a href="#Types-monoOverEquivalenceSet_counitIso"><code>Types.monoOverEquivalenceSet_counitIso</code></a>, <a href="#CategoryTheory-instIsCocontinuousOverLeftDiscretePUnitIteratedSliceForwardOver"><code>instIsCocontinuousOverLeftDiscretePUnitIteratedSliceForwardOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-Over-prodComparisonIso_pullback_inv_left_fst_snd'"><code>Over.prodComparisonIso_pullback_inv_left_fst_snd'</code></a>, <a href="#CategoryTheory-toOverUnitPullback_hom_app_left"><code>toOverUnitPullback_hom_app_left</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-coev_ev"><code>ExponentiableMorphism.coev_ev</code></a>, <a href="#CategoryTheory-subterminalsEquivMonoOverTerminal_functor_obj_obj"><code>subterminalsEquivMonoOverTerminal_functor_obj_obj</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_inv_toNatTrans_app_val_app"><code>GrothendieckTopology.pseudofunctorOver_mapId_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-instIsDenseSubsiteOverLeftDiscretePUnitOverInverseIteratedSliceEquiv"><code>instIsDenseSubsiteOverLeftDiscretePUnitOverInverseIteratedSliceEquiv</code></a>, <a href="#CategoryTheory-Over-Œµ_pullback_left"><code>Over.Œµ_pullback_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackComp_hom_counit_assoc"><code>ChosenPullbacksAlong.pullbackComp_hom_counit_assoc</code></a>, <a href="#CategoryTheory-isArtinianObject_iff_isEventuallyConstant"><code>isArtinianObject_iff_isEventuallyConstant</code></a>, <a href="#CategoryTheory-Over-coprod_map_app"><code>Over.coprod_map_app</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_pt"><code>Limits.colimit.toOver_pt</code></a>, <a href="#CategoryTheory-MonoOver-faithful_map"><code>MonoOver.faithful_map</code></a>, <a href="#CategoryTheory-Presheaf-subsingleton_iff_isSeparatedFor"><code>Presheaf.subsingleton_iff_isSeparatedFor</code></a>, <a href="#CategoryTheory-Over-liftCone_pt"><code>Over.liftCone_pt</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_app_assoc"><code>ChosenPullbacksAlong.unit_pullbackId_hom_app_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-leftUnitor_inv_left_snd_assoc"><code>ChosenPullbacksAlong.Over.leftUnitor_inv_left_snd_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-rightUnitor_inv_left_fst_assoc"><code>ChosenPullbacksAlong.Over.rightUnitor_inv_left_fst_assoc</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse'_map"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map</code></a>, <a href="#CategoryTheory-Over-homMk_comp"><code>Over.homMk_comp</code></a>, <a href="#CategoryTheory-MonoOver-hasLimitsOfSize"><code>MonoOver.hasLimitsOfSize</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_hom_toNatTrans_app_val_app"><code>GrothendieckTopology.pseudofunctorOver_mapId_hom_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-subterminals_to_monoOver_terminal_comp_forget"><code>subterminals_to_monoOver_terminal_comp_forget</code></a>, <a href="#CategoryTheory-Over-hasLimits"><code>Over.hasLimits</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctor_obj_hom"><code>AlgebraicGeometry.Scheme.restrictFunctor_obj_hom</code></a>, <a href="#HomotopicalAlgebra-instIsStableUnderRetractsOverWeakEquivalences"><code>HomotopicalAlgebra.instIsStableUnderRetractsOverWeakEquivalences</code></a>, <a href="#AlgebraicGeometry-Scheme-instFaithfulEtaleOverForget"><code>AlgebraicGeometry.Scheme.instFaithfulEtaleOverForget</code></a>, <a href="#AlgebraicGeometry-Scheme-IdealSheafData-subschemeFunctor_map"><code>AlgebraicGeometry.Scheme.IdealSheafData.subschemeFunctor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-Subobject-representative_arrow"><code>Subobject.representative_arrow</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-homEquiv_apply_eq"><code>ExponentiableMorphism.homEquiv_apply_eq</code></a>, <a href="#CategoryTheory-Over-associator_hom_left_snd_snd"><code>Over.associator_hom_left_snd_snd</code></a>, <a href="#CategoryTheory-Over-associator_inv_left_snd_assoc"><code>Over.associator_inv_left_snd_assoc</code></a>, <a href="#CategoryTheory-Over-coprodObj_map"><code>Over.coprodObj_map</code></a>, <a href="#CategoryTheory-toOverUnitPullback_inv_app_left"><code>toOverUnitPullback_inv_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_inv_app_val_app"><code>GrothendieckTopology.overMapPullbackCongr_inv_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_assoc"><code>ChosenPullbacksAlong.unit_pullbackId_hom_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-rightUnitor_inv_left_fst"><code>ChosenPullbacksAlong.Over.rightUnitor_inv_left_fst</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_forget_coverPreserving"><code>GrothendieckTopology.over_forget_coverPreserving</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackIsoOverPullback_inv_app_comp_snd_assoc"><code>ChosenPullbacksAlong.pullbackIsoOverPullback_inv_app_comp_snd_assoc</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>Under.opEquivOpOver_inverse_map</code></a>, <a href="#AlgebraicGeometry-isCommMonObj_of_isProper_of_isIntegral_tensorObj_of_isAlgClosed"><code>AlgebraicGeometry.isCommMonObj_of_isProper_of_isIntegral_tensorObj_of_isAlgClosed</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_obj"><code>Over.iteratedSliceForward_obj</code></a>, <a href="#CategoryTheory-Functor-toOver_comp_forget"><code>Functor.toOver_comp_forget</code></a>, <a href="#CategoryTheory-Over-postEquiv_functor"><code>Over.postEquiv_functor</code></a>, <a href="#CategoryTheory-Over-coreHomEquivToOverSections_homEquiv"><code>Over.coreHomEquivToOverSections_homEquiv</code></a>, <a href="#CategoryTheory-Over-whiskerLeft_left_snd"><code>Over.whiskerLeft_left_snd</code></a>, <a href="#CategoryTheory-Pseudofunctor-IsPrestackFor-nonempty_fullyFaithful"><code>Pseudofunctor.IsPrestackFor.nonempty_fullyFaithful</code></a>, <a href="#CategoryTheory-Over-liftCocone_pt"><code>Over.liftCocone_pt</code></a>, <a href="#CategoryTheory-Subfunctor-equivalenceMonoOver_counitIso"><code>Subfunctor.equivalenceMonoOver_counitIso</code></a>, <a href="#CategoryTheory-toOver_map"><code>toOver_map</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_counitIso_hom_app_hom"><code>WithTerminal.coneEquiv_counitIso_hom_app_hom</code></a>, <a href="#CategoryTheory-presheafHom_map_app_op_mk_id"><code>presheafHom_map_app_op_mk_id</code></a>, <a href="#CategoryTheory-Limits-diagonal_pullback_fst"><code>Limits.diagonal_pullback_fst</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>Over.iteratedSliceForwardNaturalityIso_inv_app</code></a>, <a href="#CategoryTheory-Over-isLeftAdjoint_post"><code>Over.isLeftAdjoint_post</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_fst_assoc"><code>ChosenPullbacksAlong.Over.associator_hom_left_fst_assoc</code></a>, <a href="#CategoryTheory-forgetAdjToOver_counit_app"><code>forgetAdjToOver_counit_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>CostructuredArrow.costructuredArrowToOverEquivalence.inverse_map</code></a>, <a href="#CategoryTheory-MorphismProperty-baseChange_obj"><code>MorphismProperty.baseChange_obj</code></a>, <a href="#CategoryTheory-MonoOver-mono_obj_hom"><code>MonoOver.mono_obj_hom</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivFunctor_obj_œÄ_app"><code>Over.ConstructProducts.conesEquivFunctor_obj_œÄ_app</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_iff"><code>Sieve.overEquiv_iff</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorHom_left_snd"><code>ChosenPullbacksAlong.Over.tensorHom_left_snd</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>Over.opEquivOpUnder_functor_obj</code></a>, <a href="#AlgebraicGeometry-Scheme-AffineZariskiSite-restrictIsoSpec_inv_app"><code>AlgebraicGeometry.Scheme.AffineZariskiSite.restrictIsoSpec_inv_app</code></a>, <a href="#AlgebraicGeometry-instFaithfulOverSchemePullbackOfSurjectiveOfFlatOfLocallyOfFinitePresentation"><code>AlgebraicGeometry.instFaithfulOverSchemePullbackOfSurjectiveOfFlatOfLocallyOfFinitePresentation</code></a>, <a href="#HomotopicalAlgebra-fibrations_over_iff"><code>HomotopicalAlgebra.fibrations_over_iff</code></a>, <a href="#CategoryTheory-MonoOver-instIsClosedUnderLimitsOfShapeOverIsMono"><code>MonoOver.instIsClosedUnderLimitsOfShapeOverIsMono</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivInverse_map_hom"><code>Over.ConstructProducts.conesEquivInverse_map_hom</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>Over.iteratedSliceForwardIsoPost_hom_app</code></a>, <a href="#CategoryTheory-Over-mono_of_mono_left"><code>Over.mono_of_mono_left</code></a>, <a href="#CategoryTheory-Over-mapForget_eq"><code>Over.mapForget_eq</code></a>, <a href="#CategoryTheory-ExponentiableMorphism-unit_pushforwardComp_hom_assoc"><code>ExponentiableMorphism.unit_pushforwardComp_hom_assoc</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_inverse_obj_pt_right_as"><code>WithTerminal.coneEquiv_inverse_obj_pt_right_as</code></a>, <a href="#CategoryTheory-Over-lift_map"><code>Over.lift_map</code></a>, <a href="#CategoryTheory-Over-tensorObj_hom"><code>Over.tensorObj_hom</code></a>, <a href="#CategoryTheory-toOverUnit_obj_hom"><code>toOverUnit_obj_hom</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_counit_app_left"><code>Over.postAdjunctionLeft_counit_app_left</code></a>, <a href="#CategoryTheory-Over-hasLimitsOfShape_of_isConnected"><code>Over.hasLimitsOfShape_of_isConnected</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_inverse_map_hom"><code>Limits.pullbackConeEquivBinaryFan_inverse_map_hom</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse</code></a>, <a href="#CategoryTheory-Over-mapComp_inv_app_left"><code>Over.mapComp_inv_app_left</code></a>, <a href="#CategoryTheory-Pseudofunctor-sheafHom_val"><code>Pseudofunctor.sheafHom_val</code></a>, <a href="#CategoryTheory-Over-instHasColimits"><code>Over.instHasColimits</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_inv_left_fst_fst_assoc"><code>ChosenPullbacksAlong.Over.associator_inv_left_fst_fst_assoc</code></a>, <a href="#CategoryTheory-MonoOver-isIso_iff_isIso_left"><code>MonoOver.isIso_iff_isIso_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-associator_hom_left_snd_snd_assoc"><code>ChosenPullbacksAlong.Over.associator_hom_left_snd_snd_assoc</code></a>, <a href="#HomotopicalAlgebra-weakEquivalences_over_def"><code>HomotopicalAlgebra.weakEquivalences_over_def</code></a>, <a href="#CategoryTheory-MonoOver-instIsIsoLeftDiscretePUnitHomFullSubcategoryOverIsMono"><code>MonoOver.instIsIsoLeftDiscretePUnitHomFullSubcategoryOverIsMono</code></a>, <a href="#CategoryTheory-WithTerminal-coneEquiv_functor_map_hom"><code>WithTerminal.coneEquiv_functor_map_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-Over-tensorHom_left"><code>ChosenPullbacksAlong.Over.tensorHom_left</code></a>, <a href="#CategoryTheory-Presheaf-isSheaf_iff_isLimit_pretopology"><code>Presheaf.isSheaf_iff_isLimit_pretopology</code></a>, <a href="#CategoryTheory-essentiallySmall_monoOver_iff_small_subobject"><code>essentiallySmall_monoOver_iff_small_subobject</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L614" id="CategoryTheory-instCategoryUnder"><code>instCategoryUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.instCategoryUnder" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>272 math</summary><strong>math:</strong> <a href="#CommRingCat-tensorProd_map_right"><code>CommRingCat.tensorProd_map_right</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_pt"><code>Limits.Cone.toUnder_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>StructuredArrow.instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-Limits-PreservesColimitsOfSize-underPost"><code>Limits.PreservesColimitsOfSize.underPost</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_obj"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_obj</code></a>, <a href="#CategoryTheory-Under-postComp_inv_app_right"><code>Under.postComp_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>StructuredArrow.ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>StructuredArrow.ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_inv_app"><code>Under.forgetMapInitial_inv_app</code></a>, <a href="#CategoryTheory-Under-post_comp"><code>Under.post_comp</code></a>, <a href="#CategoryTheory-WithInitial-isColimitEquiv_apply_desc_right"><code>WithInitial.isColimitEquiv_apply_desc_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>Under.equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_pt"><code>WithInitial.coconeEquiv_functor_obj_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>Under.postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>StructuredArrow.toUnder_obj_left</code></a>, <a href="#CategoryTheory-Under-mapIso_functor"><code>Under.mapIso_functor</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-g_app"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.g_app</code></a>, <a href="#CategoryTheory-Under-instHasLimitsOfShape"><code>Under.instHasLimitsOfShape</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_inverse_obj"><code>Limits.pushoutCoconeEquivBinaryCofan_inverse_obj</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_obj"><code>Limits.pushoutCoconeEquivBinaryCofan_functor_obj</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_right"><code>WithInitial.coconeEquiv_inverse_obj_pt_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_unitIso"><code>Limits.pushoutCoconeEquivBinaryCofan_unitIso</code></a>, <a href="#CategoryTheory-MorphismProperty-instIsClosedUnderIsomorphismsUnderUnderObjOfRespectsIso"><code>MorphismProperty.instIsClosedUnderIsomorphismsUnderUnderObjOfRespectsIso</code></a>, <a href="#CommRingCat-toAlgHom_comp"><code>CommRingCat.toAlgHom_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>Under.equivalenceOfIsInitial_functor</code></a>, <a href="#CategoryTheory-WithInitial-isColimitEquiv_symm_apply_desc"><code>WithInitial.isColimitEquiv_symm_apply_desc</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>Limits.Cocone.underPost_Œπ_app</code></a>, <a href="#instHasColimitsOfShapeUnderOfWithInitial"><code>instHasColimitsOfShapeUnderOfWithInitial</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_unitIso"><code>Over.opEquivOpUnder_unitIso</code></a>, <a href="#CategoryTheory-Under-epi_of_epi_right"><code>Under.epi_of_epi_right</code></a>, <a href="#CategoryTheory-Under-liftCone_pt"><code>Under.liftCone_pt</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_inv_app"><code>WithInitial.liftFromUnderComp_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_faithful"><code>Under.forget_faithful</code></a>, <a href="#CategoryTheory-Under-mapCongr_inv_app"><code>Under.mapCongr_inv_app</code></a>, <a href="#CategoryTheory-Under-pushoutIsLeftAdjoint"><code>Under.pushoutIsLeftAdjoint</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-MorphismProperty-ind_iff_ind_underMk"><code>MorphismProperty.ind_iff_ind_underMk</code></a>, <a href="#CategoryTheory-Under-mapFunctor_obj"><code>Under.mapFunctor_obj</code></a>, <a href="#instHasColimitsOfSizeUnder"><code>instHasColimitsOfSizeUnder</code></a>, <a href="#CategoryTheory-Under-pushout_map"><code>Under.pushout_map</code></a>, <a href="#CategoryTheory-Under-lift_obj"><code>Under.lift_obj</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_hom"><code>WithInitial.coconeEquiv_inverse_obj_pt_hom</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_inverse_map_hom"><code>Limits.pushoutCoconeEquivBinaryCofan_inverse_map_hom</code></a>, <a href="#CommRingCat-Under-preservesFiniteLimits_of_flat"><code>CommRingCat.Under.preservesFiniteLimits_of_flat</code></a>, <a href="#CommRingCat-pushout_inr_tensorProdObjIsoPushoutObj_inv_right_assoc"><code>CommRingCat.pushout_inr_tensorProdObjIsoPushoutObj_inv_right_assoc</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>StructuredArrow.ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_unit_app_right"><code>Under.postAdjunctionRight_unit_app_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>StructuredArrow.ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Under-map_map_right"><code>Under.map_map_right</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>Over.opEquivOpUnder_inverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#AlgHom-toUnder_comp"><code>AlgHom.toUnder_comp</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Under-map_obj_right"><code>Under.map_obj_right</code></a>, <a href="#CategoryTheory-Under-post_obj"><code>Under.post_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_hom</code></a>, <a href="#commAlgCatEquivUnder_functor_obj"><code>commAlgCatEquivUnder_functor_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-Under-eqToHom_right"><code>Under.eqToHom_right</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteLimitsUnderTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesFiniteLimitsUnderTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-Under-mapId_inv"><code>Under.mapId_inv</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-coneFunctorEnrichedHom_œÄ_app"><code>Enriched.FunctorCategory.coneFunctorEnrichedHom_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Presheaf-functorEnrichedHomCoyonedaObjEquiv_naturality"><code>Presheaf.functorEnrichedHomCoyonedaObjEquiv_naturality</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_counitIso_inv_app_hom"><code>WithInitial.coconeEquiv_counitIso_inv_app_hom</code></a>, <a href="#CommRingCat-Under-instPreservesLimitsOfShapeUnderWalkingParallelPairTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesLimitsOfShapeUnderWalkingParallelPairTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-MorphismProperty-under_eq_inverseImage"><code>MorphismProperty.under_eq_inverseImage</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_left"><code>WithInitial.commaFromUnder_map_left</code></a>, <a href="#CategoryTheory-NatTrans-instIsClosedUnderColimitsOfShapeUnderFunctorCoequifiberedHomDiscretePUnitOfHasProductsOfShapeHom"><code>NatTrans.instIsClosedUnderColimitsOfShapeUnderFunctorCoequifiberedHomDiscretePUnitOfHasProductsOfShapeHom</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-Under-costar_obj_left"><code>Under.costar_obj_left</code></a>, <a href="#CategoryTheory-Under-isoMk_inv_right"><code>Under.isoMk_inv_right</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_unit_app"><code>Under.mapPushoutAdj_unit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceMapOfIsIso"><code>Under.instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_Œπ_app_star"><code>WithInitial.coconeEquiv_functor_obj_Œπ_app_star</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>Over.opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-Under-liftCocone_Œπ_app"><code>Under.liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Under-post_map"><code>Under.post_map</code></a>, <a href="#AlgEquiv-toUnder_trans"><code>AlgEquiv.toUnder_trans</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_unitIso_hom_app_hom_right"><code>WithInitial.coconeEquiv_unitIso_hom_app_hom_right</code></a>, <a href="#CategoryTheory-Functor-essImage_underPost"><code>Functor.essImage_underPost</code></a>, <a href="#CategoryTheory-Under-instFaithfulObjPost"><code>Under.instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Under-map_obj_hom"><code>Under.map_obj_hom</code></a>, <a href="#CommRingCat-Under-tensorProdEqualizer_Œπ"><code>CommRingCat.Under.tensorProdEqualizer_Œπ</code></a>, <a href="#CategoryTheory-Under-instEssSurjObjPostOfFull"><code>Under.instEssSurjObjPostOfFull</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteProductsUnderPushout"><code>CommRingCat.Under.instPreservesFiniteProductsUnderPushout</code></a>, <a href="#CommRingCat-toAlgHom_id"><code>CommRingCat.toAlgHom_id</code></a>, <a href="#CategoryTheory-Under-mono_iff_mono_right"><code>Under.mono_iff_mono_right</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_obj_obj"><code>WithInitial.liftFromUnder_obj_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>StructuredArrow.isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-Under-forgetCone_pt"><code>Under.forgetCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>Under.postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-postComp_hom_app_right"><code>Under.postComp_hom_app_right</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteColimits-underPost"><code>Limits.PreservesFiniteColimits.underPost</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_map_hom"><code>WithInitial.coconeEquiv_functor_map_hom</code></a>, <a href="#CategoryTheory-Under-isoMk_hom_right"><code>Under.isoMk_hom_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-algebraEquivUnder_inverse"><code>algebraEquivUnder_inverse</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_pt_left_as"><code>WithInitial.coconeEquiv_inverse_obj_pt_left_as</code></a>, <a href="#CategoryTheory-underToAlgebra_obj_A"><code>underToAlgebra_obj_A</code></a>, <a href="#CategoryTheory-Under-mapCongr_hom_app"><code>Under.mapCongr_hom_app</code></a>, <a href="#AlgEquiv-toUnder_inv_right_apply"><code>AlgEquiv.toUnder_inv_right_apply</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>StructuredArrow.toUnder_map_right</code></a>, <a href="#CategoryTheory-Under-instIsRightAdjointForget"><code>Under.instIsRightAdjointForget</code></a>, <a href="#CommRingCat-pushout_inl_tensorProdObjIsoPushoutObj_inv_right_assoc"><code>CommRingCat.pushout_inl_tensorProdObjIsoPushoutObj_inv_right_assoc</code></a>, <a href="#CategoryTheory-Under-mapFunctor_map"><code>Under.mapFunctor_map</code></a>, <a href="#CategoryTheory-Under-liftCone_œÄ_app"><code>Under.liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-Under-instIsLeftAdjointCostar"><code>Under.instIsLeftAdjointCostar</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_map"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_map</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_hom_app"><code>Under.forgetMapInitial_hom_app</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_map_hom"><code>Limits.pushoutCoconeEquivBinaryCofan_functor_map_hom</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_obj_Œπ_app_right"><code>WithInitial.coconeEquiv_inverse_obj_Œπ_app_right</code></a>, <a href="#CommRingCat-monoidAlgebra_map"><code>CommRingCat.monoidAlgebra_map</code></a>, <a href="#CategoryTheory-MorphismProperty-instFullUnderTopUnderForget"><code>MorphismProperty.instFullUnderTopUnderForget</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_functor_obj_Œπ_app_of"><code>WithInitial.coconeEquiv_functor_obj_Œπ_app_of</code></a>, <a href="#CategoryTheory-Under-mapComp_hom"><code>Under.mapComp_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_obj"><code>Under.opEquivOpOver_functor_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_hom_app"><code>WithInitial.commaFromUnder_obj_hom_app</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_right"><code>WithInitial.commaFromUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_map"><code>Under.forget_map</code></a>, <a href="#commAlgCatEquivUnder_counitIso"><code>commAlgCatEquivUnder_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>StructuredArrow.instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-isCardinalFiltered_under"><code>isCardinalFiltered_under</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>Under.equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Under-isLeftAdjoint_post"><code>Under.isLeftAdjoint_post</code></a>, <a href="#CommRingCat-pushout_inl_tensorProdObjIsoPushoutObj_inv_right"><code>CommRingCat.pushout_inl_tensorProdObjIsoPushoutObj_inv_right</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>Over.opEquivOpUnder_counitIso</code></a>, <a href="#commAlgCatEquivUnder_inverse_obj_carrier"><code>commAlgCatEquivUnder_inverse_obj_carrier</code></a>, <a href="#CommRingCat-Under-instPreservesLimitUnderDiscreteFunctorTensorProdOfFinite"><code>CommRingCat.Under.instPreservesLimitUnderDiscreteFunctorTensorProdOfFinite</code></a>, <a href="#CategoryTheory-Under-mapIso_inverse"><code>Under.mapIso_inverse</code></a>, <a href="#CategoryTheory-Functor-toUnder_comp_forget"><code>Functor.toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#AlgEquiv-toUnder_hom_right_apply"><code>AlgEquiv.toUnder_hom_right_apply</code></a>, <a href="#preservesFilteredColimits_coyoneda"><code>preservesFilteredColimits_coyoneda</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedComp_app"><code>Enriched.FunctorCategory.functorEnrichedComp_app</code></a>, <a href="#commAlgCatEquivUnder_unitIso"><code>commAlgCatEquivUnder_unitIso</code></a>, <a href="#CommRingCat-isFinitelyPresentable_under"><code>CommRingCat.isFinitelyPresentable_under</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceObjPost"><code>Under.instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-algebraEquivUnder_unitIso"><code>algebraEquivUnder_unitIso</code></a>, <a href="#CategoryTheory-underToAlgebra_obj_a"><code>underToAlgebra_obj_a</code></a>, <a href="#CategoryTheory-algebraToUnder_obj"><code>algebraToUnder_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_right"><code>WithInitial.commaFromUnder_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_obj"><code>Enriched.FunctorCategory.functorEnrichedHom_obj</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>Under.postMap_app</code></a>, <a href="#CategoryTheory-Functor-toUnder_obj_right"><code>Functor.toUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right"><code>Under.hom_right_inv_right</code></a>, <a href="#CategoryTheory-Under-mapId_hom"><code>Under.mapId_hom</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>Under.postEquiv_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>StructuredArrow.toUnder_obj_hom</code></a>, <a href="#CategoryTheory-algebraEquivUnder_counitIso"><code>algebraEquivUnder_counitIso</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>Under.postCongr_hom_app_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-instHasEnrichedHomUnderCompMapForget"><code>Enriched.FunctorCategory.instHasEnrichedHomUnderCompMapForget</code></a>, <a href="#CategoryTheory-MorphismProperty-Under-forget_comp_forget_map"><code>MorphismProperty.Under.forget_comp_forget_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CommRingCat-tensorProdIsoPushout_app"><code>CommRingCat.tensorProdIsoPushout_app</code></a>, <a href="#CategoryTheory-Under-mapId_eq"><code>Under.mapId_eq</code></a>, <a href="#CategoryTheory-Under-pushout_obj"><code>Under.pushout_obj</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_left"><code>WithInitial.commaFromUnder_obj_left</code></a>, <a href="#CategoryTheory-Limits-IsColimit-pushoutCoconeEquivBinaryCofanFunctor_desc_right"><code>Limits.IsColimit.pushoutCoconeEquivBinaryCofanFunctor_desc_right</code></a>, <a href="#CategoryTheory-Under-instHasLimits"><code>Under.instHasLimits</code></a>, <a href="#CategoryTheory-IsFiltered-under"><code>IsFiltered.under</code></a>, <a href="#commAlgCatEquivUnder_inverse_map"><code>commAlgCatEquivUnder_inverse_map</code></a>, <a href="#Under-hasColimit_of_hasColimit_liftFromUnder"><code>Under.hasColimit_of_hasColimit_liftFromUnder</code></a>, <a href="#CategoryTheory-Under-forget_obj"><code>Under.forget_obj</code></a>, <a href="#CategoryTheory-Under-liftCocone_pt"><code>Under.liftCocone_pt</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_inverse_map_hom_right"><code>WithInitial.coconeEquiv_inverse_map_hom_right</code></a>, <a href="#CommRingCat-Under-instPreservesFiniteProductsUnderTensorProd"><code>CommRingCat.Under.instPreservesFiniteProductsUnderTensorProd</code></a>, <a href="#CategoryTheory-Under-mapForget_eq"><code>Under.mapForget_eq</code></a>, <a href="#CategoryTheory-underToAlgebra_map_f"><code>underToAlgebra_map_f</code></a>, <a href="#CategoryTheory-Under-instFullObjPostOfFaithful"><code>Under.instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Under-final_forget"><code>Under.final_forget</code></a>, <a href="#preservesColimit_coyoneda_of_finitePresentation"><code>preservesColimit_coyoneda_of_finitePresentation</code></a>, <a href="#CategoryTheory-Functor-toUnder_map_right"><code>Functor.toUnder_map_right</code></a>, <a href="#CategoryTheory-Under-mono_of_mono_right"><code>Under.mono_of_mono_right</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_counit_app"><code>Under.mapPushoutAdj_counit_app</code></a>, <a href="#CategoryTheory-Under-mapComp_eq"><code>Under.mapComp_eq</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_hom_app"><code>WithInitial.liftFromUnderComp_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>StructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CommRingCat-Under-equalizerFork_Œπ"><code>CommRingCat.Under.equalizerFork_Œπ</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_counitIso_hom_app_hom"><code>WithInitial.coconeEquiv_counitIso_hom_app_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>Under.postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right"><code>Under.inv_right_hom_right</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_map_app"><code>WithInitial.liftFromUnder_map_app</code></a>, <a href="#CategoryTheory-Under-mapComp_inv"><code>Under.mapComp_inv</code></a>, <a href="#CategoryTheory-MorphismProperty-underObj_ind_eq_ind_underObj"><code>MorphismProperty.underObj_ind_eq_ind_underObj</code></a>, <a href="#commAlgCatEquivUnder_functor_map"><code>commAlgCatEquivUnder_functor_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Under-hom_right_inv_right_assoc"><code>Under.hom_right_inv_right_assoc</code></a>, <a href="#CategoryTheory-Under-locallySmall"><code>Under.locallySmall</code></a>, <a href="#CommRingCat-instIsLeftAdjointCommMonCatUnderMonoidAlgebra"><code>CommRingCat.instIsLeftAdjointCommMonCatUnderMonoidAlgebra</code></a>, <a href="#CommRingCat-monoidAlgebra_obj"><code>CommRingCat.monoidAlgebra_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>Under.opEquivOpOver_inverse_obj</code></a>, <a href="#CategoryTheory-Under-costar_map_left"><code>Under.costar_map_left</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>Under.equivalenceOfIsInitial_inverse_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>StructuredArrow.ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>Under.opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>StructuredArrow.toUnder_map_left</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnder_obj_map"><code>WithInitial.liftFromUnder_obj_map</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorHomEquiv_apply_app"><code>Enriched.FunctorCategory.functorHomEquiv_apply_app</code></a>, <a href="#CategoryTheory-Under-mkIdInitial_to_right"><code>Under.mkIdInitial_to_right</code></a>, <a href="#CategoryTheory-Under-mono_homMk"><code>Under.mono_homMk</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_obj"><code>Under.equivalenceOfIsInitial_inverse_obj</code></a>, <a href="#CategoryTheory-Under-costar_obj_hom"><code>Under.costar_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-Limits-PreservesColimitsOfShape-underPost"><code>Limits.PreservesColimitsOfShape.underPost</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>Under.postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_counitIso"><code>Limits.pushoutCoconeEquivBinaryCofan_counitIso</code></a>, <a href="#isFinitelyPresentable"><code>isFinitelyPresentable</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>Over.opEquivOpUnder_functor_map</code></a>, <a href="#CategoryTheory-Under-postEquiv_functor"><code>Under.postEquiv_functor</code></a>, <a href="#CategoryTheory-Under-lift_map"><code>Under.lift_map</code></a>, <a href="#CategoryTheory-Under-hasLimit_of_hasLimit_comp_forget"><code>Under.hasLimit_of_hasLimit_comp_forget</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_unitIso"><code>Under.opEquivOpOver_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>StructuredArrow.instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-Under-inv_right_hom_right_assoc"><code>Under.inv_right_hom_right_assoc</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-hf"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.hf</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>Under.opEquivOpOver_functor_map</code></a>, <a href="#CategoryTheory-Under-epi_homMk"><code>Under.epi_homMk</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>Under.postEquiv_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-algebraToUnder_map"><code>algebraToUnder_map</code></a>, <a href="#CategoryTheory-Limits-instPreservesFilteredColimitsOfSizeUnderForget"><code>Limits.instPreservesFilteredColimitsOfSizeUnderForget</code></a>, <a href="#CommRingCat-Under-instPreservesLimitUnderWalkingParallelPairParallelPairTensorProdOfFlatCarrier"><code>CommRingCat.Under.instPreservesLimitUnderWalkingParallelPairParallelPairTensorProdOfFlatCarrier</code></a>, <a href="#CategoryTheory-Under-id_right"><code>Under.id_right</code></a>, <a href="#CategoryTheory-algebraEquivUnder_functor"><code>algebraEquivUnder_functor</code></a>, <a href="#CategoryTheory-Under-homMk_comp"><code>Under.homMk_comp</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>Under.postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>StructuredArrow.ofDiagEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_map"><code>Enriched.FunctorCategory.functorEnrichedHom_map</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>StructuredArrow.toUnder_obj_right</code></a>, <a href="#CommRingCat-preservesFilteredColimits_coyoneda"><code>CommRingCat.preservesFilteredColimits_coyoneda</code></a>, <a href="#CategoryTheory-Under-isRightAdjoint_post"><code>Under.isRightAdjoint_post</code></a>, <a href="#CategoryTheory-WithInitial-coconeEquiv_unitIso_inv_app_hom_right"><code>WithInitial.coconeEquiv_unitIso_inv_app_hom_right</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>Under.opEquivOpOver_inverse_map</code></a>, <a href="#CategoryTheory-Under-preservesLimitsOfSize_map"><code>Under.preservesLimitsOfSize_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_pt"><code>Limits.Cocone.underPost_pt</code></a>, <a href="#CommRingCat-preservesColimit_coyoneda_of_finitePresentation"><code>CommRingCat.preservesColimit_coyoneda_of_finitePresentation</code></a>, <a href="#CategoryTheory-Under-forgetCone_œÄ_app"><code>Under.forgetCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-epi_f"><code>IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.epi_f</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>Over.opEquivOpUnder_functor_obj</code></a>, <a href="#CommRingCat-Under-equalizer_comp"><code>CommRingCat.Under.equalizer_comp</code></a>, <a href="#CategoryTheory-Under-forget_reflects_iso"><code>Under.forget_reflects_iso</code></a>, <a href="#CommRingCat-Under-equalizerFork'_Œπ"><code>CommRingCat.Under.equalizerFork'_Œπ</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedId_app"><code>Enriched.FunctorCategory.functorEnrichedId_app</code></a>, <a href="#CategoryTheory-Under-comp_right"><code>Under.comp_right</code></a>, <a href="#CategoryTheory-MorphismProperty-instFaithfulUnderTopUnderForget"><code>MorphismProperty.instFaithfulUnderTopUnderForget</code></a>, <a href="#CategoryTheory-Under-faithful_pushout"><code>Under.faithful_pushout</code></a>, <a href="#CommRingCat-pushout_inr_tensorProdObjIsoPushoutObj_inv_right"><code>CommRingCat.pushout_inr_tensorProdObjIsoPushoutObj_inv_right</code></a><br></details></td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L598" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence"><code>costructuredArrowToOverEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1314" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>ofCommaFstEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>ofCommaFstEquivalence_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1297" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>8 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>ofCommaFstEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>ofCommaFstEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>ofCommaFstEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>ofCommaFstEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>ofCommaFstEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>ofCommaFstEquivalence_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1305" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>10 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>ofCommaFstEquivalenceInverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>ofCommaFstEquivalenceInverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>ofCommaFstEquivalenceInverse_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>ofCommaFstEquivalenceInverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>ofCommaFstEquivalenceInverse_obj_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>ofCommaFstEquivalence_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>ofCommaFstEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>ofCommaFstEquivalenceInverse_map_left_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1247" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence"><code>ofCostructuredArrowProjEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1275" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence"><code>ofDiagEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1285" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence'"><code>ofDiagEquivalence'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence'" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L553" id="CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>29 math</summary><strong>math:</strong> <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_isColimit"><code>CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_isColimit</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_left"><code>toOver_obj_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_Œπ_app"><code>CategoryTheory.Limits.Cocone.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_right"><code>toOver_obj_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_toOver_comp_forget"><code>CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda"><code>overEquivPresheafCostructuredArrow_inverse_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_right"><code>toOver_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_obj_hom"><code>toOver_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFullOverToOver"><code>instFullOverToOver</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_Œπ_app"><code>CategoryTheory.Limits.colimit.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>costructuredArrowToOverEquivalence.functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-instFaithfulOverToOver"><code>instFaithfulOverToOver</code></a>, <a href="#CategoryTheory-instInitialCostructuredArrowOverToOver"><code>CategoryTheory.instInitialCostructuredArrowOverToOver</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_inv_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_inv_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-instEssSurjOverToOver"><code>instEssSurjOverToOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-toOver_map_left"><code>toOver_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda"><code>overEquivPresheafCostructuredArrow_functor_map_toOverCompYoneda</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>costructuredArrowToOverEquivalence.functor_obj</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_pt"><code>CategoryTheory.Limits.Cocone.toOver_pt</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_hom_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_hom_app</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_inv_hom"><code>CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda"><code>overEquivPresheafCostructuredArrow_functor_map_toOverCompCoyoneda</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>costructuredArrowToOverEquivalence.inverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-isEquivalence_toOver"><code>isEquivalence_toOver</code></a>, <a href="#CategoryTheory-Limits-IndizationClosedUnderFilteredColimitsAux-exists_nonempty_limit_obj_of_colimit"><code>CategoryTheory.Limits.IndizationClosedUnderFilteredColimitsAux.exists_nonempty_limit_obj_of_colimit</code></a>, <a href="#CategoryTheory-CostructuredArrow-overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda"><code>overEquivPresheafCostructuredArrow_inverse_map_toOverCompYoneda</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_hom_hom"><code>CategoryTheory.Limits.Cocone.mapCoconeToOver_hom_hom</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_pt"><code>CategoryTheory.Limits.colimit.toOver_pt</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>costructuredArrowToOverEquivalence.inverse_map</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L562" id="CategoryTheory-CostructuredArrow-instEssSurjOverToOver"><code>instEssSurjOverToOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.instEssSurjOverToOver" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L556" id="CategoryTheory-CostructuredArrow-instFaithfulOverToOver"><code>instFaithfulOverToOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.instFaithfulOverToOver" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L559" id="CategoryTheory-CostructuredArrow-instFullOverToOver"><code>instFullOverToOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.instFullOverToOver" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-instFullCompPre"><code>instFullCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L566" id="CategoryTheory-CostructuredArrow-isEquivalence_toOver"><code>isEquivalence_toOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.isEquivalence_toOver" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CostructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1296" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>ofCommaFstEquivalenceFunctor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1296" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>ofCommaFstEquivalenceFunctor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1296" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>ofCommaFstEquivalenceFunctor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1296" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>ofCommaFstEquivalenceFunctor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1296" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>ofCommaFstEquivalenceFunctor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>ofCommaFstEquivalenceInverse_map_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-preLeft"><code>CategoryTheory.Comma.preLeft</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>ofCommaFstEquivalenceInverse_map_left_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-preLeft"><code>CategoryTheory.Comma.preLeft</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>ofCommaFstEquivalenceInverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>ofCommaFstEquivalenceInverse_obj_left_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>ofCommaFstEquivalenceInverse_obj_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>ofCommaFstEquivalenceInverse_obj_left_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1304" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>ofCommaFstEquivalenceInverse_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1313" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>ofCommaFstEquivalence_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1313" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>ofCommaFstEquivalence_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1313" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>ofCommaFstEquivalence_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1313" id="CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>ofCommaFstEquivalence_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence"><code>ofCommaFstEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor"><code>ofCommaFstEquivalenceFunctor</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse"><code>ofCommaFstEquivalenceInverse</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L552" id="CategoryTheory-CostructuredArrow-toOver_map_left"><code>toOver_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L552" id="CategoryTheory-CostructuredArrow-toOver_map_right"><code>toOver_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L552" id="CategoryTheory-CostructuredArrow-toOver_obj_hom"><code>toOver_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L552" id="CategoryTheory-CostructuredArrow-toOver_obj_left"><code>toOver_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L552" id="CategoryTheory-CostructuredArrow-toOver_obj_right"><code>toOver_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.toOver_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>toOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L576" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>functor_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>functor_obj</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L584" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>inverse_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>inverse_map</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L575" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_map"><code>functor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.functor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>CategoryTheory.CostructuredArrow.toOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L575" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor_obj"><code>functor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.functor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>CategoryTheory.CostructuredArrow.toOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L583" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>inverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.inverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>CategoryTheory.CostructuredArrow.toOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-CostructuredArrow-homMk"><code>CategoryTheory.CostructuredArrow.homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L583" id="CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>inverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.inverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-toOver"><code>CategoryTheory.CostructuredArrow.toOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1228" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1238" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-toOver"><code>CategoryTheory.Functor.toOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1227" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>inverse_map_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toCostructuredArrow"><code>CategoryTheory.Functor.toCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>inverse_obj_left_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>inverse_obj_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>inverse_obj_left_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1237" id="CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.CostructuredArrow.ofDiagEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1258" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1269" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>inverse_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>inverse_map_left</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>functor_map_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-toOver"><code>CategoryTheory.Functor.toOver</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>functor_obj_left_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>functor_obj_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>functor_obj_left_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1257" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>functor_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1268" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>inverse_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-CostructuredArrow-proj"><code>CategoryTheory.CostructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1268" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1268" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>inverse_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1268" id="CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>inverse_obj_right_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CostructuredArrow"><code>CategoryTheory.CostructuredArrow</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a><br><a href="#CategoryTheory-instCategoryCostructuredArrow"><code>CategoryTheory.instCategoryCostructuredArrow</code></a><br><a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Functor</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1085" id="CategoryTheory-Functor-toOver"><code>toOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toOver" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-Functor-toOver_obj_left"><code>toOver_obj_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-Functor-toOver_map_left"><code>toOver_map_left</code></a>, <a href="#CategoryTheory-Functor-toOver_comp_forget"><code>toOver_comp_forget</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1091" id="CategoryTheory-Functor-toOverCompForget"><code>toOverCompForget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toOverCompForget" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1104" id="CategoryTheory-Functor-toUnder"><code>toUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toUnder" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-Functor-toUnder_comp_forget"><code>toUnder_comp_forget</code></a>, <a href="#CategoryTheory-Functor-toUnder_obj_right"><code>toUnder_obj_right</code></a>, <a href="#CategoryTheory-Functor-toUnder_map_right"><code>toUnder_map_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1110" id="CategoryTheory-Functor-toUnderCompForget"><code>toUnderCompForget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toUnderCompForget" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1067" id="CategoryTheory-Functor-essImage_overPost"><code>essImage_overPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.essImage_overPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-essImage"><code>essImage</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>CategoryTheory.Over.post</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-essImage-of_overPost"><code>essImage.of_overPost</code></a><br><a href="#CategoryTheory-Functor-map_surjective"><code>map_surjective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1074" id="CategoryTheory-Functor-essImage_underPost"><code>essImage_underPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.essImage_underPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-essImage"><code>essImage</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>CategoryTheory.Under.post</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-essImage-of_underPost"><code>essImage.of_underPost</code></a><br><a href="#CategoryTheory-Functor-map_surjective"><code>map_surjective</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Iso-inv_hom_id"><code>CategoryTheory.Iso.inv_hom_id</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1096" id="CategoryTheory-Functor-toOver_comp_forget"><code>toOver_comp_forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toOver_comp_forget" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Functor-comp"><code>comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-toOver"><code>toOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>CategoryTheory.Over.forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1084" id="CategoryTheory-Functor-toOver_map_left"><code>toOver_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toOver_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-toOver"><code>toOver</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1084" id="CategoryTheory-Functor-toOver_obj_left"><code>toOver_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toOver_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-toOver"><code>toOver</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1115" id="CategoryTheory-Functor-toUnder_comp_forget"><code>toUnder_comp_forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toUnder_comp_forget" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Functor-comp"><code>comp</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-toUnder"><code>toUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1103" id="CategoryTheory-Functor-toUnder_map_right"><code>toUnder_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toUnder_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1103" id="CategoryTheory-Functor-toUnder_obj_right"><code>toUnder_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.toUnder_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>obj</code></a><br><a href="#CategoryTheory-Functor-map"><code>map</code></a></td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Functor.FullyFaithful</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L455" id="CategoryTheory-Functor-FullyFaithful-over"><code>over</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.FullyFaithful.over" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L945" id="CategoryTheory-Functor-FullyFaithful-under"><code>under</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.FullyFaithful.under" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Functor.essImage</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1057" id="CategoryTheory-Functor-essImage-of_overPost"><code>of_overPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.essImage.of_overPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-Functor-essImage"><code>CategoryTheory.Functor.essImage</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>CategoryTheory.Over.post</code></a></td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1061" id="CategoryTheory-Functor-essImage-of_underPost"><code>of_underPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Functor.essImage.of_underPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-Functor-essImage"><code>CategoryTheory.Functor.essImage</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>CategoryTheory.Under.post</code></a></td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Limits.Cocone</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1022" id="CategoryTheory-Limits-Cocone-underPost"><code>underPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cocone.underPost" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>underPost_Œπ_app</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_pt"><code>underPost_pt</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1021" id="CategoryTheory-Limits-Cocone-underPost_pt"><code>underPost_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cocone.underPost_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-Cocone-pt"><code>pt</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>CategoryTheory.Under.post</code></a><br><a href="#CategoryTheory-Limits-Cocone-underPost"><code>underPost</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cocone-Œπ"><code>Œπ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1021" id="CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>underPost_Œπ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cocone.underPost_Œπ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>CategoryTheory.Under.post</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cocone-pt"><code>pt</code></a><br><a href="#CategoryTheory-Limits-Cocone-Œπ"><code>Œπ</code></a><br><a href="#CategoryTheory-Limits-Cocone-underPost"><code>underPost</code></a><br><a href="#CategoryTheory-Under-homMk"><code>CategoryTheory.Under.homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Limits.Cone</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L542" id="CategoryTheory-Limits-Cone-overPost"><code>overPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cone.overPost" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Limits-Cone-overPost_pt"><code>overPost_pt</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>overPost_œÄ_app</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L541" id="CategoryTheory-Limits-Cone-overPost_pt"><code>overPost_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cone.overPost_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-Cone-pt"><code>pt</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-post"><code>CategoryTheory.Over.post</code></a><br><a href="#CategoryTheory-Limits-Cone-overPost"><code>overPost</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cone-œÄ"><code>œÄ</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L541" id="CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>overPost_œÄ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Limits.Cone.overPost_œÄ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cone-pt"><code>pt</code></a><br><a href="#CategoryTheory-Limits-Cone-œÄ"><code>œÄ</code></a><br><a href="#CategoryTheory-Over-post"><code>CategoryTheory.Over.post</code></a><br><a href="#CategoryTheory-Limits-Cone-overPost"><code>overPost</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Over</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L84" id="CategoryTheory-Over-coeFromHom"><code>coeFromHom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.coeFromHom" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L495" id="CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>7 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-forgetMapTerminal_hom_app"><code>forgetMapTerminal_hom_app</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>equivalenceOfIsTerminal_counitIso</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_map"><code>equivalenceOfIsTerminal_inverse_map</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_inv_app"><code>forgetMapTerminal_inv_app</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_functor"><code>equivalenceOfIsTerminal_functor</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_obj"><code>equivalenceOfIsTerminal_inverse_obj</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L151" id="CategoryTheory-Over-forget"><code>forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forget" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>117 math</summary><strong>math:</strong> <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_hom"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_hom</code></a>, <a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a>, <a href="#CategoryTheory-MorphismProperty-over_eq_inverseImage"><code>CategoryTheory.MorphismProperty.over_eq_inverseImage</code></a>, <a href="#CategoryTheory-Over-forgetCocone_pt"><code>forgetCocone_pt</code></a>, <a href="#CategoryTheory-instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair"><code>CategoryTheory.instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_map_left_left"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctorŒì_inv_app"><code>AlgebraicGeometry.Scheme.restrictFunctorŒì_inv_app</code></a>, <a href="#CategoryTheory-Over-instIsLeftAdjointForget"><code>instIsLeftAdjointForget</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_hom_app"><code>forgetMapTerminal_hom_app</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>equivalenceOfIsTerminal_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_hom"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_left"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_inv_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_inv_app_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrow_comp_toOver_comp_forget"><code>CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_forget"><code>iteratedSliceForward_forget</code></a>, <a href="#CategoryTheory-toOverIsoToOverUnit_inv_app_left"><code>CategoryTheory.toOverIsoToOverUnit_inv_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_map_left"><code>CategoryTheory.WithTerminal.commaFromOver_map_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_right_as"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as</code></a>, <a href="#CategoryTheory-equivToOverUnit_unitIso"><code>CategoryTheory.equivToOverUnit_unitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_hom"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_hom"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsCocontinuousOverForgetOver"><code>CategoryTheory.GrothendieckTopology.instIsCocontinuousOverForgetOver</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget"><code>iteratedSliceBackward_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget_forget"><code>iteratedSliceBackward_forget_forget</code></a>, <a href="#CategoryTheory-presheafHom_obj"><code>CategoryTheory.presheafHom_obj</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_inverse"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_inverse</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_hom"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_forget_compatiblePreserving"><code>CategoryTheory.GrothendieckTopology.over_forget_compatiblePreserving</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_inv_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_inv_app</code></a>, <a href="#CategoryTheory-Over-forgetAdjStar_counit_app"><code>forgetAdjStar_counit_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_left"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_map_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left</code></a>, <a href="#CategoryTheory-presheafHom_map_app"><code>CategoryTheory.presheafHom_map_app</code></a>, <a href="#CategoryTheory-Limits-instPreservesCofilteredLimitsOfSizeOverForget"><code>CategoryTheory.Limits.instPreservesCofilteredLimitsOfSizeOverForget</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_inv_app"><code>forgetMapTerminal_inv_app</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_functor"><code>equivalenceOfIsTerminal_functor</code></a>, <a href="#CategoryTheory-Over-conePostIso_hom_app_hom"><code>conePostIso_hom_app_hom</code></a>, <a href="#SheafOfModules-Presentation-quasicoherentData_presentation"><code>SheafOfModules.Presentation.quasicoherentData_presentation</code></a>, <a href="#CategoryTheory-monoOver_terminal_to_subterminals_comp"><code>CategoryTheory.monoOver_terminal_to_subterminals_comp</code></a>, <a href="#AlgebraicGeometry-opensDiagramŒπ_app"><code>AlgebraicGeometry.opensDiagramŒπ_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_right_as"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_right_as</code></a>, <a href="#CategoryTheory-Over-preservesLimitsOfShape_forget_of_isConnected"><code>preservesLimitsOfShape_forget_of_isConnected</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_left"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_left</code></a>, <a href="#CategoryTheory-MorphismProperty-Over-forget_comp_forget_map"><code>CategoryTheory.MorphismProperty.Over.forget_comp_forget_map</code></a>, <a href="#AlgebraicGeometry-Scheme-AffineZariskiSite-restrictIsoSpec_hom_app"><code>AlgebraicGeometry.Scheme.AffineZariskiSite.restrictIsoSpec_hom_app</code></a>, <a href="#CategoryTheory-Presieve-functorPushforward_overForget"><code>CategoryTheory.Presieve.functorPushforward_overForget</code></a>, <a href="#CategoryTheory-Over-initial_forget"><code>initial_forget</code></a>, <a href="#CategoryTheory-forgetAdjToOver_unit_app"><code>CategoryTheory.forgetAdjToOver_unit_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_right_as"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as</code></a>, <a href="#AlgebraicGeometry-Scheme-restrictFunctorŒì_hom_app"><code>AlgebraicGeometry.Scheme.restrictFunctorŒì_hom_app</code></a>, <a href="#CategoryTheory-equivToOverUnit_counitIso"><code>CategoryTheory.equivToOverUnit_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_right_as"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_hom"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom</code></a>, <a href="#CategoryTheory-Over-forget_obj"><code>forget_obj</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_hom_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_hom_app_left</code></a>, <a href="#CategoryTheory-Over-forgetPreservesConnectedLimits"><code>forgetPreservesConnectedLimits</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_functor"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_functor</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_right"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_right_as"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as</code></a>, <a href="#AlgebraicGeometry-instIsOpenImmersionMapSchemeCompOverOverTopMorphismPropertyForgetForget"><code>AlgebraicGeometry.instIsOpenImmersionMapSchemeCompOverOverTopMorphismPropertyForgetForget</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_left"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_left</code></a>, <a href="#CategoryTheory-toOverIsoToOverUnit_hom_app_left"><code>CategoryTheory.toOverIsoToOverUnit_hom_app_left</code></a>, <a href="#SheafOfModules-instIsLeftAdjointOverOverRingCatPushforwardIdSheafOver"><code>SheafOfModules.instIsLeftAdjointOverOverRingCatPushforwardIdSheafOver</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_obj_right_as"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_map_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_symm_generate"><code>CategoryTheory.Sieve.overEquiv_symm_generate</code></a>, <a href="#CategoryTheory-Over-conePostIso_inv_app_hom"><code>conePostIso_inv_app_hom</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_obj_hom_app"><code>CategoryTheory.WithTerminal.commaFromOver_obj_hom_app</code></a>, <a href="#CategoryTheory-forgetAdjToOver-homEquiv_symm"><code>CategoryTheory.forgetAdjToOver.homEquiv_symm</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_hom"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_counitIso"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_counitIso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_left"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-Limits-Cocone-toCostructuredArrowCompToOverCompForget_hom_app"><code>CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_hom_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Presieve-map_functorPullback_overForget"><code>CategoryTheory.Presieve.map_functorPullback_overForget</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_map_right"><code>CategoryTheory.WithTerminal.commaFromOver_map_right</code></a>, <a href="#CategoryTheory-Over-forget_reflects_iso"><code>forget_reflects_iso</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_obj_right"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-functor_obj_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left</code></a>, <a href="#AlgebraicGeometry-instIsOpenImmersionAppOverSchemeOpensDiagramŒπ"><code>AlgebraicGeometry.instIsOpenImmersionAppOverSchemeOpensDiagramŒπ</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-functor_obj_left_right_as"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_inv_hom"><code>CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom</code></a>, <a href="#CategoryTheory-Functor-over_forget_locallyCoverDense"><code>CategoryTheory.Functor.over_forget_locallyCoverDense</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_left_right"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_right</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofDiagEquivalence-inverse_map_left"><code>CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left</code></a>, <a href="#AlgebraicGeometry-instIsLocallyDirectedCompSchemeOverOverTopMorphismPropertyForgetForgetForget"><code>AlgebraicGeometry.instIsLocallyDirectedCompSchemeOverOverTopMorphismPropertyForgetForgetForget</code></a>, <a href="#CategoryTheory-PresheafHom-IsSheafFor-app_cond"><code>CategoryTheory.PresheafHom.IsSheafFor.app_cond</code></a>, <a href="#CategoryTheory-FunctorToTypes-mem_fromOverSubfunctor_iff"><code>CategoryTheory.FunctorToTypes.mem_fromOverSubfunctor_iff</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsContinuousOverForgetOver"><code>CategoryTheory.GrothendieckTopology.instIsContinuousOverForgetOver</code></a>, <a href="#CategoryTheory-PresheafHom-IsSheafFor-exists_app"><code>CategoryTheory.PresheafHom.IsSheafFor.exists_app</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalence_unitIso"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_unitIso</code></a>, <a href="#CategoryTheory-Over-forgetCocone_Œπ_app"><code>forgetCocone_Œπ_app</code></a>, <a href="#CategoryTheory-equivToOverUnit_functor"><code>CategoryTheory.equivToOverUnit_functor</code></a>, <a href="#CategoryTheory-Over-forget_map"><code>forget_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_right_as"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_generate"><code>CategoryTheory.Sieve.overEquiv_generate</code></a>, <a href="#CategoryTheory-PresheafHom-isAmalgamation_iff"><code>CategoryTheory.PresheafHom.isAmalgamation_iff</code></a>, <a href="#AlgebraicGeometry-instMonoObjWalkingSpanCompOverSchemeTopMorphismPropertySpanOverForgetForgetForgetNoneWalkingPairSomeMapInitOfIsOpenImmersionLeftDiscretePUnit"><code>AlgebraicGeometry.instMonoObjWalkingSpanCompOverSchemeTopMorphismPropertySpanOverForgetForgetForgetNoneWalkingPairSomeMapInitOfIsOpenImmersionLeftDiscretePUnit</code></a>, <a href="#CategoryTheory-Limits-Cocone-mapCoconeToOver_hom_hom"><code>CategoryTheory.Limits.Cocone.mapCoconeToOver_hom_hom</code></a>, <a href="#CategoryTheory-WithTerminal-commaFromOver_obj_left"><code>CategoryTheory.WithTerminal.commaFromOver_obj_left</code></a>, <a href="#CategoryTheory-over_toGrothendieck_eq_toGrothendieck_comap_forget"><code>CategoryTheory.over_toGrothendieck_eq_toGrothendieck_comap_forget</code></a>, <a href="#CategoryTheory-Over-forgetAdjStar_unit_app_left"><code>forgetAdjStar_unit_app_left</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCostructuredArrowProjEquivalence-inverse_obj_left_left"><code>CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left</code></a>, <a href="#CategoryTheory-subterminals_to_monoOver_terminal_comp_forget"><code>CategoryTheory.subterminals_to_monoOver_terminal_comp_forget</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_obj_hom"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_forget_coverPreserving"><code>CategoryTheory.GrothendieckTopology.over_forget_coverPreserving</code></a>, <a href="#CategoryTheory-Functor-toOver_comp_forget"><code>CategoryTheory.Functor.toOver_comp_forget</code></a>, <a href="#CategoryTheory-presheafHom_map_app_op_mk_id"><code>CategoryTheory.presheafHom_map_app_op_mk_id</code></a>, <a href="#CategoryTheory-forgetAdjToOver_counit_app"><code>CategoryTheory.forgetAdjToOver_counit_app</code></a>, <a href="#AlgebraicGeometry-Scheme-AffineZariskiSite-restrictIsoSpec_inv_app"><code>AlgebraicGeometry.Scheme.AffineZariskiSite.restrictIsoSpec_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a>, <a href="#CategoryTheory-Over-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceInverse_map_left_right"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L167" id="CategoryTheory-Over-forgetCocone"><code>forgetCocone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forgetCocone" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-forgetCocone_pt"><code>forgetCocone_pt</code></a>, <a href="#CategoryTheory-Over-forgetCocone_Œπ_app"><code>forgetCocone_Œπ_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L99" id="CategoryTheory-Over-homMk"><code>homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.homMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>76 math</summary><strong>math:</strong> <a href="#CategoryTheory-Pseudofunctor-DescentData-subtypeCompatibleHomEquiv_toCompatible_presheafHomObjHomEquiv"><code>CategoryTheory.Pseudofunctor.DescentData.subtypeCompatibleHomEquiv_toCompatible_presheafHomObjHomEquiv</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_pullback_map"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryFst_pullback_map</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_map"><code>iteratedSliceBackward_map</code></a>, <a href="#CategoryTheory-Limits-Cocone-toOver_Œπ_app"><code>CategoryTheory.Limits.Cocone.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>equivalenceOfIsTerminal_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.iso_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_inv_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-Over-conePost_obj_œÄ_app"><code>conePost_obj_œÄ_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Limits-colimit-toOver_Œπ_app"><code>CategoryTheory.Limits.colimit.toOver_Œπ_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_unit_app_left"><code>postAdjunctionLeft_unit_app_left</code></a>, <a href="#CategoryTheory-Over-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_counit_app"><code>mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_functor_map_hom"><code>CategoryTheory.Limits.pullbackConeEquivBinaryFan_functor_map_hom</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_counitIso"><code>CategoryTheory.Limits.pullbackConeEquivBinaryFan_counitIso</code></a>, <a href="#CategoryTheory-MonoOver-image_map"><code>CategoryTheory.MonoOver.image_map</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_unit_app_left"><code>CategoryTheory.ChosenPullbacksAlong.isoInv_mapPullbackAdj_unit_app_left</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_inverse_map"><code>equivalenceOfIsTerminal_inverse_map</code></a>, <a href="#CategoryTheory-Over-mono_homMk"><code>mono_homMk</code></a>, <a href="#AlgebraicGeometry-Scheme-kerAdjunction_counit_app"><code>AlgebraicGeometry.Scheme.kerAdjunction_counit_app</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_unit_app"><code>mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivFunctor_map_hom"><code>ConstructProducts.conesEquivFunctor_map_hom</code></a>, <a href="#CategoryTheory-Over-conePost_map_hom"><code>conePost_map_hom</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_unitIso_hom_app_left"><code>TopologicalSpace.Opens.overEquivalence_unitIso_hom_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_functor_obj"><code>CategoryTheory.Limits.pullbackConeEquivBinaryFan_functor_obj</code></a>, <a href="#CategoryTheory-forgetAdjToOver_unit_app"><code>CategoryTheory.forgetAdjToOver_unit_app</code></a>, <a href="#CategoryTheory-regularTopology-parallelPair_pullback_initial"><code>CategoryTheory.regularTopology.parallelPair_pullback_initial</code></a>, <a href="#CategoryTheory-Over-homMk_left"><code>homMk_left</code></a>, <a href="#CategoryTheory-Pseudofunctor-bijective_toDescentData_map_iff"><code>CategoryTheory.Pseudofunctor.bijective_toDescentData_map_iff</code></a>, <a href="#CategoryTheory-Over-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-Over-liftCone_œÄ_app"><code>liftCone_œÄ_app</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_counitIso_inv_app"><code>TopologicalSpace.Opens.overEquivalence_counitIso_inv_app</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_unitIso_inv_app_left"><code>TopologicalSpace.Opens.overEquivalence_unitIso_inv_app_left</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>opEquivOpUnder_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_pullback_map"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategorySnd_pullback_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Over-homMk_eta"><code>homMk_eta</code></a>, <a href="#CategoryTheory-MorphismProperty-Over-homMk_hom"><code>CategoryTheory.MorphismProperty.Over.homMk_hom</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_counit_app_left"><code>CategoryTheory.ChosenPullbacksAlong.isoInv_mapPullbackAdj_counit_app_left</code></a>, <a href="#CategoryTheory-Over-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-CostructuredArrow-ofCommaFstEquivalenceFunctor_map_left"><code>CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a>, <a href="#CategoryTheory-Over-liftCocone_Œπ_app"><code>liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-coalgebraToOver_map"><code>CategoryTheory.coalgebraToOver_map</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_obj"><code>iteratedSliceBackward_obj</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.iso_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_map"><code>iteratedSliceForward_map</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_pullback_map"><code>CategoryTheory.ChosenPullbacksAlong.iso_pullback_map</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_obj"><code>CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.inverse_obj</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>CategoryTheory.Limits.Cone.overPost_œÄ_app</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>CategoryTheory.Under.opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-Over-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_pullback_map"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_pullback_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>CategoryTheory.Under.opEquivOpOver_functor_map</code></a>, <a href="#TopologicalSpace-Opens-overEquivalence_counitIso_hom_app"><code>TopologicalSpace.Opens.overEquivalence_counitIso_hom_app</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_unitIso"><code>CategoryTheory.Limits.pullbackConeEquivBinaryFan_unitIso</code></a>, <a href="#CategoryTheory-Over-isMonHom_pullbackFst_id_right"><code>isMonHom_pullbackFst_id_right</code></a>, <a href="#CategoryTheory-Over-coprod_map_app"><code>coprod_map_app</code></a>, <a href="#TopCat-Presheaf-generateEquivalenceOpensLe_inverse'_map"><code>TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map</code></a>, <a href="#CategoryTheory-Over-homMk_comp"><code>homMk_comp</code></a>, <a href="#AlgebraicGeometry-Scheme-IdealSheafData-subschemeFunctor_map"><code>AlgebraicGeometry.Scheme.IdealSheafData.subschemeFunctor_map</code></a>, <a href="#CategoryTheory-Over-coprodObj_map"><code>coprodObj_map</code></a>, <a href="#CategoryTheory-toOver_map"><code>CategoryTheory.toOver_map</code></a>, <a href="#CategoryTheory-Limits-diagonal_pullback_fst"><code>CategoryTheory.Limits.diagonal_pullback_fst</code></a>, <a href="#CategoryTheory-CostructuredArrow-costructuredArrowToOverEquivalence-inverse_map"><code>CategoryTheory.CostructuredArrow.costructuredArrowToOverEquivalence.inverse_map</code></a>, <a href="#CategoryTheory-Over-ConstructProducts-conesEquivFunctor_obj_œÄ_app"><code>ConstructProducts.conesEquivFunctor_obj_œÄ_app</code></a>, <a href="#CategoryTheory-Sieve-overEquiv_iff"><code>CategoryTheory.Sieve.overEquiv_iff</code></a>, <a href="#CategoryTheory-Over-lift_map"><code>lift_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L45" id="CategoryTheory-Over-inhabited"><code>inhabited</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.inhabited" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L522" id="CategoryTheory-Over-isLimitLiftCone"><code>isLimitLiftCone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.isLimitLiftCone" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L117" id="CategoryTheory-Over-isoMk"><code>isoMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.isoMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>12 math</summary><strong>math:</strong> <a href="#CategoryTheory-equivToOverUnit_unitIso"><code>CategoryTheory.equivToOverUnit_unitIso</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_unit_app_left"><code>postAdjunctionLeft_unit_app_left</code></a>, <a href="#CategoryTheory-Over-preservesTerminalIso_pullback"><code>preservesTerminalIso_pullback</code></a>, <a href="#CategoryTheory-Limits-pullbackConeEquivBinaryFan_counitIso"><code>CategoryTheory.Limits.pullbackConeEquivBinaryFan_counitIso</code></a>, <a href="#CategoryTheory-Over-isoMk_inv_left"><code>isoMk_inv_left</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-coalgebraEquivOver_counitIso"><code>CategoryTheory.coalgebraEquivOver_counitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-isoMk_hom_left"><code>isoMk_hom_left</code></a>, <a href="#CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L353" id="CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceBackward" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>13 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceBackward_map"><code>iteratedSliceBackward_map</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget"><code>iteratedSliceBackward_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget_forget"><code>iteratedSliceBackward_forget_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a>, <a href="#CategoryTheory-instIsContinuousOverLeftDiscretePUnitIteratedSliceBackwardOver"><code>CategoryTheory.instIsContinuousOverLeftDiscretePUnitIteratedSliceBackwardOver</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_hom_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_hom_app_left</code></a>, <a href="#CategoryTheory-instIsCocontinuousOverLeftDiscretePUnitIteratedSliceBackwardOver"><code>CategoryTheory.instIsCocontinuousOverLeftDiscretePUnitIteratedSliceBackwardOver</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_obj"><code>iteratedSliceBackward_obj</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_inverse"><code>iteratedSliceEquiv_inverse</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L364" id="CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquiv" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>7 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceEquiv_functor"><code>iteratedSliceEquiv_functor</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_hom_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_hom_app_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_inverse"><code>iteratedSliceEquiv_inverse</code></a>, <a href="#CategoryTheory-instIsDenseSubsiteOverLeftDiscretePUnitOverInverseIteratedSliceEquiv"><code>CategoryTheory.instIsDenseSubsiteOverLeftDiscretePUnitOverInverseIteratedSliceEquiv</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L395" id="CategoryTheory-Over-iteratedSliceEquivOverMapIso"><code>iteratedSliceEquivOverMapIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquivOverMapIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L347" id="CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForward" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>16 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>iteratedSliceForwardNaturalityIso_hom_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-instIsContinuousOverLeftDiscretePUnitIteratedSliceForwardOver"><code>CategoryTheory.instIsContinuousOverLeftDiscretePUnitIteratedSliceForwardOver</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_forget"><code>iteratedSliceForward_forget</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_functor"><code>iteratedSliceEquiv_functor</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_hom_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_hom_app_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_map"><code>iteratedSliceForward_map</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-instIsCocontinuousOverLeftDiscretePUnitIteratedSliceForwardOver"><code>CategoryTheory.instIsCocontinuousOverLeftDiscretePUnitIteratedSliceForwardOver</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForward_obj"><code>iteratedSliceForward_obj</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>iteratedSliceForwardNaturalityIso_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L486" id="CategoryTheory-Over-iteratedSliceForwardIsoPost"><code>iteratedSliceForwardIsoPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardIsoPost" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L382" id="CategoryTheory-Over-iteratedSliceForwardNaturalityIso"><code>iteratedSliceForwardNaturalityIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardNaturalityIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>iteratedSliceForwardNaturalityIso_hom_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>iteratedSliceForwardNaturalityIso_inv_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L513" id="CategoryTheory-Over-liftCone"><code>liftCone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.liftCone" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-liftCone_œÄ_app"><code>liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-Over-liftCone_pt"><code>liftCone_pt</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L173" id="CategoryTheory-Over-map"><code>map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.map" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>82 math</summary><strong>math:</strong> <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackId_hom_app_val_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>iteratedSliceForwardNaturalityIso_hom_app</code></a>, <a href="#CategoryTheory-Over-mapIso_inverse"><code>mapIso_inverse</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackId_inv_app_val_app</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_hom_app"><code>forgetMapTerminal_hom_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackComp_hom_assoc"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackComp_hom_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.iso_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_inv_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_inv_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_map_coverPreserving"><code>CategoryTheory.GrothendieckTopology.over_map_coverPreserving</code></a>, <a href="#CategoryTheory-Over-mapId_eq"><code>mapId_eq</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-snd'_left"><code>CategoryTheory.ChosenPullbacksAlong.snd'_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Over-mapCongr_inv_app_left"><code>mapCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapCongr_hom_app_left"><code>mapCongr_hom_app_left</code></a>, <a href="#CategoryTheory-Over-postCongr_inv_app_left"><code>postCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapComp_hom_app_left"><code>mapComp_hom_app_left</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_unit_app_left"><code>postAdjunctionLeft_unit_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_counit_app"><code>mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Over-iteratedSliceBackward_forget"><code>iteratedSliceBackward_forget</code></a>, <a href="#CategoryTheory-Over-postCongr_hom_app_left"><code>postCongr_hom_app_left</code></a>, <a href="#CategoryTheory-Sieve-functorPushforward_over_map"><code>CategoryTheory.Sieve.functorPushforward_over_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_obj"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_obj</code></a>, <a href="#CategoryTheory-Over-map_map_left"><code>map_map_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_unit_app_left"><code>CategoryTheory.ChosenPullbacksAlong.isoInv_mapPullbackAdj_unit_app_left</code></a>, <a href="#CategoryTheory-Over-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Over-forgetMapTerminal_inv_app"><code>forgetMapTerminal_inv_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_app"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackId_hom_app</code></a>, <a href="#CategoryTheory-Over-preservesColimitsOfSize_map"><code>preservesColimitsOfSize_map</code></a>, <a href="#CategoryTheory-Over-mapComp_eq"><code>mapComp_eq</code></a>, <a href="#CategoryTheory-Over-mapPullbackAdj_unit_app"><code>mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Over-mapId_inv_app_left"><code>mapId_inv_app_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-Over-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a>, <a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackId_hom_counit"><code>CategoryTheory.ChosenPullbacksAlong.pullbackId_hom_counit</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_hom_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_hom_app_left</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_hom_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_hom_app_left</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackId_hom_counit_assoc"><code>CategoryTheory.ChosenPullbacksAlong.pullbackId_hom_counit_assoc</code></a>, <a href="#CategoryTheory-Presieve-isSheafFor_over_map_op_comp_ofArrows_iff"><code>CategoryTheory.Presieve.isSheafFor_over_map_op_comp_ofArrows_iff</code></a>, <a href="#CategoryTheory-Presieve-isSheafFor_over_map_op_comp_iff"><code>CategoryTheory.Presieve.isSheafFor_over_map_op_comp_iff</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_unit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackComp_hom_counit"><code>CategoryTheory.ChosenPullbacksAlong.pullbackComp_hom_counit</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_map_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_map_val_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryFst_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-isoInv_mapPullbackAdj_counit_app_left"><code>CategoryTheory.ChosenPullbacksAlong.isoInv_mapPullbackAdj_counit_app_left</code></a>, <a href="#CategoryTheory-Over-mapId_hom_app_left"><code>mapId_hom_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_map"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map_toFunctor_obj_val_map</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackComp_inv_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackId_hom</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategoryToUnit_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.cartesianMonoidalCategorySnd_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-fst'_left"><code>CategoryTheory.ChosenPullbacksAlong.fst'_left</code></a>, <a href="#CategoryTheory-Over-map_obj_left"><code>map_obj_left</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-iso_mapPullbackAdj_counit_app"><code>CategoryTheory.ChosenPullbacksAlong.iso_mapPullbackAdj_counit_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackComp_hom_app_val_app</code></a>, <a href="#CategoryTheory-toOverIteratedSliceForwardIsoPullback_inv_app_left"><code>CategoryTheory.toOverIteratedSliceForwardIsoPullback_inv_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackCongr_hom_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackComp_hom"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackComp_hom</code></a>, <a href="#CategoryTheory-Over-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-instIsContinuousOverMapOver"><code>CategoryTheory.GrothendieckTopology.instIsContinuousOverMapOver</code></a>, <a href="#CategoryTheory-GrothendieckTopology-over_map_compatiblePreserving"><code>CategoryTheory.GrothendieckTopology.over_map_compatiblePreserving</code></a>, <a href="#CategoryTheory-Over-mapIso_functor"><code>mapIso_functor</code></a>, <a href="#CategoryTheory-Over-mapFunctor_map"><code>mapFunctor_map</code></a>, <a href="#CategoryTheory-Over-mapCongr_rfl"><code>mapCongr_rfl</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_inv_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapId_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-pullbackComp_hom_counit_assoc"><code>CategoryTheory.ChosenPullbacksAlong.pullbackComp_hom_counit_assoc</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_app_assoc"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackId_hom_app_assoc</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_hom_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapId_hom_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackCongr_inv_app_val_app</code></a>, <a href="#CategoryTheory-ChosenPullbacksAlong-unit_pullbackId_hom_assoc"><code>CategoryTheory.ChosenPullbacksAlong.unit_pullbackId_hom_assoc</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>iteratedSliceForwardNaturalityIso_inv_app</code></a>, <a href="#CategoryTheory-Over-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_counit_app_left"><code>postAdjunctionLeft_counit_app_left</code></a>, <a href="#CategoryTheory-Over-mapComp_inv_app_left"><code>mapComp_inv_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L256" id="CategoryTheory-Over-mapComp"><code>mapComp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapComp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-mapComp_hom_app_left"><code>mapComp_hom_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapComp_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackComp_inv_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackComp_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackComp_hom_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapComp_hom_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-Over-mapComp_inv_app_left"><code>mapComp_inv_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L262" id="CategoryTheory-Over-mapCongr"><code>mapCongr</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapCongr" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>5 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-mapCongr_inv_app_left"><code>mapCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapCongr_hom_app_left"><code>mapCongr_hom_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackCongr_hom_app_val_app</code></a>, <a href="#CategoryTheory-Over-mapCongr_rfl"><code>mapCongr_rfl</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackCongr_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackCongr_inv_app_val_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L237" id="CategoryTheory-Over-mapForget"><code>mapForget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapForget" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-toOverPullbackIsoToOver_inv_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_inv_app_left</code></a>, <a href="#CategoryTheory-toOverPullbackIsoToOver_hom_app_left"><code>CategoryTheory.toOverPullbackIsoToOver_hom_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L272" id="CategoryTheory-Over-mapFunctor"><code>mapFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-mapFunctor_obj"><code>mapFunctor_obj</code></a>, <a href="#CategoryTheory-Over-mapFunctor_map"><code>mapFunctor_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L229" id="CategoryTheory-Over-mapId"><code>mapId</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapId" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_hom_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackId_hom_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-overMapPullbackId_inv_app_val_app"><code>CategoryTheory.GrothendieckTopology.overMapPullbackId_inv_app_val_app</code></a>, <a href="#CategoryTheory-Over-mapId_inv_app_left"><code>mapId_inv_app_left</code></a>, <a href="#CategoryTheory-Over-mapId_hom_app_left"><code>mapId_hom_app_left</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_inv_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapId_inv_toNatTrans_app_val_app</code></a>, <a href="#CategoryTheory-GrothendieckTopology-pseudofunctorOver_mapId_hom_toNatTrans_app_val_app"><code>CategoryTheory.GrothendieckTopology.pseudofunctorOver_mapId_hom_toNatTrans_app_val_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L193" id="CategoryTheory-Over-mapIso"><code>mapIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-mapIso_inverse"><code>mapIso_inverse</code></a>, <a href="#CategoryTheory-Over-mapIso_functor"><code>mapIso_functor</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L78" id="CategoryTheory-Over-mk"><code>mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mk" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L290" id="CategoryTheory-Over-mkIdTerminal"><code>mkIdTerminal</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mkIdTerminal" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-mkIdTerminal_from_left"><code>mkIdTerminal_from_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1334" id="CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-opEquivOpUnder_unitIso"><code>opEquivOpUnder_unitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>opEquivOpUnder_inverse_obj</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>opEquivOpUnder_inverse_map</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>opEquivOpUnder_counitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>opEquivOpUnder_functor_map</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>opEquivOpUnder_functor_obj</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L404" id="CategoryTheory-Over-post"><code>post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.post" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>42 math</summary><strong>math:</strong> <a href="#CategoryTheory-MonoOver-congr_unitIso"><code>CategoryTheory.MonoOver.congr_unitIso</code></a>, <a href="#CategoryTheory-instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair"><code>CategoryTheory.instGuitartExactOverObjOverPostOfHasBinaryProductOfPreservesLimitDiscreteWalkingPairPair</code></a>, <a href="#CategoryTheory-Over-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-Limits-PreservesLimitsOfShape-overPost"><code>CategoryTheory.Limits.PreservesLimitsOfShape.overPost</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-Over-conePost_obj_œÄ_app"><code>conePost_obj_œÄ_app</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteLimits-overPost"><code>CategoryTheory.Limits.PreservesFiniteLimits.overPost</code></a>, <a href="#CategoryTheory-Over-postCongr_inv_app_left"><code>postCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_unit_app_left"><code>postAdjunctionLeft_unit_app_left</code></a>, <a href="#CategoryTheory-Over-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-Over-postCongr_hom_app_left"><code>postCongr_hom_app_left</code></a>, <a href="#CategoryTheory-Over-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Over-conePostIso_hom_app_hom"><code>conePostIso_hom_app_hom</code></a>, <a href="#CategoryTheory-Over-conePost_map_hom"><code>conePost_map_hom</code></a>, <a href="#CategoryTheory-Over-postComp_inv_app_left"><code>postComp_inv_app_left</code></a>, <a href="#CategoryTheory-Over-post_comp"><code>post_comp</code></a>, <a href="#CategoryTheory-Over-isRightAdjoint_post"><code>isRightAdjoint_post</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOverComp_hom_app"><code>CategoryTheory.WithTerminal.liftFromOverComp_hom_app</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_pt"><code>CategoryTheory.Limits.Cone.overPost_pt</code></a>, <a href="#CategoryTheory-MonoOver-congr_functor"><code>CategoryTheory.MonoOver.congr_functor</code></a>, <a href="#CategoryTheory-MonoOver-congr_inverse"><code>CategoryTheory.MonoOver.congr_inverse</code></a>, <a href="#CategoryTheory-Over-conePostIso_inv_app_hom"><code>conePostIso_inv_app_hom</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-Over-conePost_obj_pt"><code>conePost_obj_pt</code></a>, <a href="#CategoryTheory-Over-postComp_hom_app_left"><code>postComp_hom_app_left</code></a>, <a href="#CategoryTheory-Over-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-Limits-PreservesLimitsOfSize-overPost"><code>CategoryTheory.Limits.PreservesLimitsOfSize.overPost</code></a>, <a href="#CategoryTheory-Over-instFaithfulObjPost"><code>instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-Over-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a>, <a href="#CategoryTheory-WithTerminal-liftFromOverComp_inv_app"><code>CategoryTheory.WithTerminal.liftFromOverComp_inv_app</code></a>, <a href="#CategoryTheory-Limits-Cone-overPost_œÄ_app"><code>CategoryTheory.Limits.Cone.overPost_œÄ_app</code></a>, <a href="#CategoryTheory-Over-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-MonoOver-congr_counitIso"><code>CategoryTheory.MonoOver.congr_counitIso</code></a>, <a href="#CategoryTheory-Functor-essImage_overPost"><code>CategoryTheory.Functor.essImage_overPost</code></a>, <a href="#CategoryTheory-Over-postEquiv_functor"><code>postEquiv_functor</code></a>, <a href="#CategoryTheory-Over-isLeftAdjoint_post"><code>isLeftAdjoint_post</code></a>, <a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_counit_app_left"><code>postAdjunctionLeft_counit_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L465" id="CategoryTheory-Over-postAdjunctionRight"><code>postAdjunctionRight</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postAdjunctionRight" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a>, <a href="#CategoryTheory-Over-postAdjunctionLeft_counit_app_left"><code>postAdjunctionLeft_counit_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L416" id="CategoryTheory-Over-postComp"><code>postComp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postComp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-postComp_inv_app_left"><code>postComp_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postComp_hom_app_left"><code>postComp_hom_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L429" id="CategoryTheory-Over-postCongr"><code>postCongr</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postCongr" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-postCongr_inv_app_left"><code>postCongr_inv_app_left</code></a>, <a href="#CategoryTheory-Over-postCongr_hom_app_left"><code>postCongr_hom_app_left</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L477" id="CategoryTheory-Over-postEquiv"><code>postEquiv</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postEquiv" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Over-postEquiv_functor"><code>postEquiv_functor</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L423" id="CategoryTheory-Over-postMap"><code>postMap</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postMap" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Over-postMap_app"><code>postMap_app</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L91" id="CategoryTheory-Over-coe_hom"><code>coe_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.coe_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L70" id="CategoryTheory-Over-comp_left"><code>comp_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.comp_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L69" id="CategoryTheory-Over-comp_left_assoc"><code>comp_left_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.comp_left_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Over-comp_left"><code>comp_left</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L310" id="CategoryTheory-Over-epi_homMk"><code>epi_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.epi_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L307" id="CategoryTheory-Over-epi_of_epi_left"><code>epi_of_epi_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.epi_of_epi_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L241" id="CategoryTheory-Over-eqToHom_left"><code>eqToHom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.eqToHom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L494" id="CategoryTheory-Over-equivalenceOfIsTerminal_counitIso"><code>equivalenceOfIsTerminal_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L494" id="CategoryTheory-Over-equivalenceOfIsTerminal_functor"><code>equivalenceOfIsTerminal_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L494" id="CategoryTheory-Over-equivalenceOfIsTerminal_inverse_map"><code>equivalenceOfIsTerminal_inverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal_inverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L494" id="CategoryTheory-Over-equivalenceOfIsTerminal_inverse_obj"><code>equivalenceOfIsTerminal_inverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal_inverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L494" id="CategoryTheory-Over-equivalenceOfIsTerminal_unitIso"><code>equivalenceOfIsTerminal_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.equivalenceOfIsTerminal_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-equivalenceOfIsTerminal"><code>equivalenceOfIsTerminal</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L131" id="CategoryTheory-Over-forall_iff"><code>forall_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forall_iff" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L166" id="CategoryTheory-Over-forgetCocone_pt"><code>forgetCocone_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forgetCocone_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-Cocone-pt"><code>CategoryTheory.Limits.Cocone.pt</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Over-forgetCocone"><code>forgetCocone</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L166" id="CategoryTheory-Over-forgetCocone_Œπ_app"><code>forgetCocone_Œπ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forgetCocone_Œπ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cocone-Œπ"><code>CategoryTheory.Limits.Cocone.Œπ</code></a><br><a href="#CategoryTheory-Over-forgetCocone"><code>forgetCocone</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L298" id="CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forget_faithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L161" id="CategoryTheory-Over-forget_map"><code>forget_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forget_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L157" id="CategoryTheory-Over-forget_obj"><code>forget_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forget_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L281" id="CategoryTheory-Over-forget_reflects_iso"><code>forget_reflects_iso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.forget_reflects_iso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ReflectsIsomorphisms"><code>CategoryTheory.Functor.ReflectsIsomorphisms</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-inv_comp_eq"><code>CategoryTheory.Iso.inv_comp_eq</code></a><br><a href="#CategoryTheory-Over-w"><code>w</code></a><br><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a><br><a href="#CategoryTheory-IsIso-hom_inv_id"><code>CategoryTheory.IsIso.hom_inv_id</code></a><br><a href="#CategoryTheory-IsIso-inv_hom_id"><code>CategoryTheory.IsIso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L108" id="CategoryTheory-Over-homMk_comp"><code>homMk_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.homMk_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L103" id="CategoryTheory-Over-homMk_eta"><code>homMk_eta</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.homMk_eta" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L98" id="CategoryTheory-Over-homMk_left"><code>homMk_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.homMk_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L140" id="CategoryTheory-Over-homMk_surjective"><code>homMk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.homMk_surjective" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L122" id="CategoryTheory-Over-hom_left_inv_left"><code>hom_left_inv_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.hom_left_inv_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-hom_inv_id"><code>CategoryTheory.Iso.hom_inv_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L121" id="CategoryTheory-Over-hom_left_inv_left_assoc"><code>hom_left_inv_left_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.hom_left_inv_left_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Over-hom_left_inv_left"><code>hom_left_inv_left</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L66" id="CategoryTheory-Over-id_left"><code>id_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.id_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L446" id="CategoryTheory-Over-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.instEssSurjObjPostOfFull" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj-mem_essImage"><code>CategoryTheory.Functor.EssSurj.mem_essImage</code></a><br><a href="#CategoryTheory-Functor-map_surjective"><code>CategoryTheory.Functor.map_surjective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L434" id="CategoryTheory-Over-instFaithfulObjPost"><code>instFaithfulObjPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.instFaithfulObjPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a><br><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L440" id="CategoryTheory-Over-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.instFullObjPostOfFaithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_surjective"><code>CategoryTheory.Functor.map_surjective</code></a><br><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a><br><a href="#CategoryTheory-Functor-map_comp"><code>CategoryTheory.Functor.map_comp</code></a><br><a href="#CategoryTheory-Over-w"><code>w</code></a><br><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L199" id="CategoryTheory-Over-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.instIsEquivalenceMapOfIsIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-isEquivalence_functor"><code>CategoryTheory.Equivalence.isEquivalence_functor</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L452" id="CategoryTheory-Over-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.instIsEquivalenceObjPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-instFaithfulObjPost"><code>instFaithfulObjPost</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-faithful"><code>CategoryTheory.Functor.IsEquivalence.faithful</code></a><br><a href="#CategoryTheory-Over-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-full"><code>CategoryTheory.Functor.IsEquivalence.full</code></a><br><a href="#CategoryTheory-Over-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-essSurj"><code>CategoryTheory.Functor.IsEquivalence.essSurj</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L127" id="CategoryTheory-Over-inv_left_hom_left"><code>inv_left_hom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.inv_left_hom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-inv_hom_id"><code>CategoryTheory.Iso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L126" id="CategoryTheory-Over-inv_left_hom_left_assoc"><code>inv_left_hom_left_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.inv_left_hom_left_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Over-inv_left_hom_left"><code>inv_left_hom_left</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L470" id="CategoryTheory-Over-isRightAdjoint_post"><code>isRightAdjoint_post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.isRightAdjoint_post" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsRightAdjoint"><code>CategoryTheory.Functor.IsRightAdjoint</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L116" id="CategoryTheory-Over-isoMk_hom_left"><code>isoMk_hom_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.isoMk_hom_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L116" id="CategoryTheory-Over-isoMk_inv_left"><code>isoMk_inv_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.isoMk_inv_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L357" id="CategoryTheory-Over-iteratedSliceBackward_forget"><code>iteratedSliceBackward_forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceBackward_forget" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L374" id="CategoryTheory-Over-iteratedSliceBackward_forget_forget"><code>iteratedSliceBackward_forget_forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceBackward_forget_forget" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L352" id="CategoryTheory-Over-iteratedSliceBackward_map"><code>iteratedSliceBackward_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceBackward_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L352" id="CategoryTheory-Over-iteratedSliceBackward_obj"><code>iteratedSliceBackward_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceBackward_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L394" id="CategoryTheory-Over-iteratedSliceEquivOverMapIso_hom_app_left_left"><code>iteratedSliceEquivOverMapIso_hom_app_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquivOverMapIso_hom_app_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso"><code>iteratedSliceEquivOverMapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L394" id="CategoryTheory-Over-iteratedSliceEquivOverMapIso_inv_app_left_left"><code>iteratedSliceEquivOverMapIso_inv_app_left_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquivOverMapIso_inv_app_left_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquivOverMapIso"><code>iteratedSliceEquivOverMapIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L363" id="CategoryTheory-Over-iteratedSliceEquiv_counitIso"><code>iteratedSliceEquiv_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquiv_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L363" id="CategoryTheory-Over-iteratedSliceEquiv_functor"><code>iteratedSliceEquiv_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquiv_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L363" id="CategoryTheory-Over-iteratedSliceEquiv_inverse"><code>iteratedSliceEquiv_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquiv_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L363" id="CategoryTheory-Over-iteratedSliceEquiv_unitIso"><code>iteratedSliceEquiv_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceEquiv_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceEquiv"><code>iteratedSliceEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-iteratedSliceBackward"><code>iteratedSliceBackward</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L485" id="CategoryTheory-Over-iteratedSliceForwardIsoPost_hom_app"><code>iteratedSliceForwardIsoPost_hom_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardIsoPost_hom_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost"><code>iteratedSliceForwardIsoPost</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L485" id="CategoryTheory-Over-iteratedSliceForwardIsoPost_inv_app"><code>iteratedSliceForwardIsoPost_inv_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardIsoPost_inv_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForwardIsoPost"><code>iteratedSliceForwardIsoPost</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L381" id="CategoryTheory-Over-iteratedSliceForwardNaturalityIso_hom_app"><code>iteratedSliceForwardNaturalityIso_hom_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardNaturalityIso_hom_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso"><code>iteratedSliceForwardNaturalityIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L381" id="CategoryTheory-Over-iteratedSliceForwardNaturalityIso_inv_app"><code>iteratedSliceForwardNaturalityIso_inv_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForwardNaturalityIso_inv_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForwardNaturalityIso"><code>iteratedSliceForwardNaturalityIso</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L370" id="CategoryTheory-Over-iteratedSliceForward_forget"><code>iteratedSliceForward_forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForward_forget" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L346" id="CategoryTheory-Over-iteratedSliceForward_map"><code>iteratedSliceForward_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForward_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L346" id="CategoryTheory-Over-iteratedSliceForward_obj"><code>iteratedSliceForward_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.iteratedSliceForward_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Over-iteratedSliceForward"><code>iteratedSliceForward</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L512" id="CategoryTheory-Over-liftCone_pt"><code>liftCone_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.liftCone_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cone-pt"><code>CategoryTheory.Limits.Cone.pt</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cone-œÄ"><code>CategoryTheory.Limits.Cone.œÄ</code></a></td><td><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-lift"><code>lift</code></a><br><a href="#CategoryTheory-Over-liftCone"><code>liftCone</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L512" id="CategoryTheory-Over-liftCone_œÄ_app"><code>liftCone_œÄ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.liftCone_œÄ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cone-pt"><code>CategoryTheory.Limits.Cone.pt</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cone-œÄ"><code>CategoryTheory.Limits.Cone.œÄ</code></a></td><td><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-lift"><code>lift</code></a><br><a href="#CategoryTheory-Over-liftCone"><code>liftCone</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L504" id="CategoryTheory-Over-lift_map"><code>lift_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.lift_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-lift"><code>lift</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L504" id="CategoryTheory-Over-lift_obj"><code>lift_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.lift_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-lift"><code>lift</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L246" id="CategoryTheory-Over-mapComp_eq"><code>mapComp_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapComp_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ext"><code>CategoryTheory.Functor.ext</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a><br><a href="#CategoryTheory-Over-eqToHom_left"><code>eqToHom_left</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L255" id="CategoryTheory-Over-mapComp_hom_app_left"><code>mapComp_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapComp_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapComp"><code>mapComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L255" id="CategoryTheory-Over-mapComp_inv_app_left"><code>mapComp_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapComp_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapComp"><code>mapComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L261" id="CategoryTheory-Over-mapCongr_hom_app_left"><code>mapCongr_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapCongr_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapCongr"><code>mapCongr</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L261" id="CategoryTheory-Over-mapCongr_inv_app_left"><code>mapCongr_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapCongr_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapCongr"><code>mapCongr</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L267" id="CategoryTheory-Over-mapCongr_rfl"><code>mapCongr_rfl</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapCongr_rfl" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Over-mapCongr"><code>mapCongr</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L233" id="CategoryTheory-Over-mapForget_eq"><code>mapForget_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapForget_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Over-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L272" id="CategoryTheory-Over-mapFunctor_map"><code>mapFunctor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapFunctor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Cat"><code>CategoryTheory.Cat</code></a><br><a href="#CategoryTheory-Cat-category"><code>CategoryTheory.Cat.category</code></a><br><a href="#CategoryTheory-Over-mapFunctor"><code>mapFunctor</code></a><br><a href="#CategoryTheory-Functor-toCatHom"><code>CategoryTheory.Functor.toCatHom</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L272" id="CategoryTheory-Over-mapFunctor_obj"><code>mapFunctor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapFunctor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Cat"><code>CategoryTheory.Cat</code></a><br><a href="#CategoryTheory-Cat-category"><code>CategoryTheory.Cat.category</code></a><br><a href="#CategoryTheory-Over-mapFunctor"><code>mapFunctor</code></a><br><a href="#CategoryTheory-Cat-of"><code>CategoryTheory.Cat.of</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L217" id="CategoryTheory-Over-mapId_eq"><code>mapId_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapId_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ext"><code>CategoryTheory.Functor.ext</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-CostructuredArrow-eqToHom_left"><code>CategoryTheory.CostructuredArrow.eqToHom_left</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L228" id="CategoryTheory-Over-mapId_hom_app_left"><code>mapId_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapId_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapId"><code>mapId</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L228" id="CategoryTheory-Over-mapId_inv_app_left"><code>mapId_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapId_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-mapId"><code>mapId</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L196" id="CategoryTheory-Over-mapIso_functor"><code>mapIso_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapIso_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L197" id="CategoryTheory-Over-mapIso_inverse"><code>mapIso_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mapIso_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L189" id="CategoryTheory-Over-map_map_left"><code>map_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.map_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L185" id="CategoryTheory-Over-map_obj_hom"><code>map_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.map_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L181" id="CategoryTheory-Over-map_obj_left"><code>map_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.map_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L294" id="CategoryTheory-Over-mkIdTerminal_from_left"><code>mkIdTerminal_from_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mkIdTerminal_from_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-from"><code>CategoryTheory.Limits.IsTerminal.from</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-mkIdTerminal"><code>mkIdTerminal</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-Limits-IsTerminal-hom_ext"><code>CategoryTheory.Limits.IsTerminal.hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L77" id="CategoryTheory-Over-mk_hom"><code>mk_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mk_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L77" id="CategoryTheory-Over-mk_left"><code>mk_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mk_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L135" id="CategoryTheory-Over-mk_surjective"><code>mk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mk_surjective" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L323" id="CategoryTheory-Over-mono_homMk"><code>mono_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mono_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L332" id="CategoryTheory-Over-mono_left_of_mono"><code>mono_left_of_mono</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mono_left_of_mono" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-w"><code>w</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-cancel_mono"><code>CategoryTheory.cancel_mono</code></a><br><a href="#CategoryTheory-Over-OverMorphism-ext"><code>OverMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L320" id="CategoryTheory-Over-mono_of_mono_left"><code>mono_of_mono_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.mono_of_mono_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Over-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_counitIso"><code>opEquivOpUnder_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-Under-homMk"><code>CategoryTheory.Under.homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_functor_map"><code>opEquivOpUnder_functor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_functor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Under-homMk"><code>CategoryTheory.Under.homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_functor_obj"><code>opEquivOpUnder_functor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_functor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_inverse_map"><code>opEquivOpUnder_inverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_inverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_inverse_obj"><code>opEquivOpUnder_inverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_inverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1333" id="CategoryTheory-Over-opEquivOpUnder_unitIso"><code>opEquivOpUnder_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.opEquivOpUnder_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over-opEquivOpUnder"><code>opEquivOpUnder</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L63" id="CategoryTheory-Over-over_right"><code>over_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.over_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L464" id="CategoryTheory-Over-postAdjunctionRight_counit_app"><code>postAdjunctionRight_counit_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postAdjunctionRight_counit_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Adjunction-counit"><code>CategoryTheory.Adjunction.counit</code></a><br><a href="#CategoryTheory-Over-postAdjunctionRight"><code>postAdjunctionRight</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L464" id="CategoryTheory-Over-postAdjunctionRight_unit_app"><code>postAdjunctionRight_unit_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postAdjunctionRight_unit_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Adjunction-counit"><code>CategoryTheory.Adjunction.counit</code></a><br><a href="#CategoryTheory-Adjunction-unit"><code>CategoryTheory.Adjunction.unit</code></a><br><a href="#CategoryTheory-Over-postAdjunctionRight"><code>postAdjunctionRight</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L415" id="CategoryTheory-Over-postComp_hom_app_left"><code>postComp_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postComp_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-postComp"><code>postComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L415" id="CategoryTheory-Over-postComp_inv_app_left"><code>postComp_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postComp_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-postComp"><code>postComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L428" id="CategoryTheory-Over-postCongr_hom_app_left"><code>postCongr_hom_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postCongr_hom_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-postCongr"><code>postCongr</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L428" id="CategoryTheory-Over-postCongr_inv_app_left"><code>postCongr_inv_app_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postCongr_inv_app_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Over-postCongr"><code>postCongr</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L476" id="CategoryTheory-Over-postEquiv_counitIso"><code>postEquiv_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postEquiv_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Iso-app"><code>CategoryTheory.Iso.app</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L476" id="CategoryTheory-Over-postEquiv_functor"><code>postEquiv_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postEquiv_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L476" id="CategoryTheory-Over-postEquiv_inverse"><code>postEquiv_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postEquiv_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L476" id="CategoryTheory-Over-postEquiv_unitIso"><code>postEquiv_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postEquiv_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Over-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Iso-app"><code>CategoryTheory.Iso.app</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L422" id="CategoryTheory-Over-postMap_app"><code>postMap_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.postMap_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-map"><code>map</code></a><br><a href="#CategoryTheory-Over-postMap"><code>postMap</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L409" id="CategoryTheory-Over-post_comp"><code>post_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.post_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L403" id="CategoryTheory-Over-post_map"><code>post_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.post_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Over-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L403" id="CategoryTheory-Over-post_obj"><code>post_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.post_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Over-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L74" id="CategoryTheory-Over-w"><code>w</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.w" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L73" id="CategoryTheory-Over-w_assoc"><code>w_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.w_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Over-w"><code>w</code></a></td></tr>
</table>
<h2>CategoryTheory.Over.OverMorphism</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L56" id="CategoryTheory-Over-OverMorphism-ext"><code>ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.OverMorphism.ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L55" id="CategoryTheory-Over-OverMorphism-ext_iff"><code>ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over.OverMorphism.ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Over-OverMorphism-ext"><code>ext</code></a></td></tr>
</table>
<h2>CategoryTheory.StructuredArrow</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1211" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>ofCommaSndEquivalence_inverse</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1194" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>8 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>ofCommaSndEquivalenceFunctor_obj_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1202" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>10 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>ofCommaSndEquivalenceInverse_obj_right_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1172" id="CategoryTheory-StructuredArrow-ofDiagEquivalence"><code>ofDiagEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1182" id="CategoryTheory-StructuredArrow-ofDiagEquivalence'"><code>ofDiagEquivalence'</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence'" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1146" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence"><code>ofStructuredArrowProjEquivalence</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1035" id="CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>16 math</summary><strong>math:</strong> <a href="#CategoryTheory-Limits-Cone-toUnder_pt"><code>CategoryTheory.Limits.Cone.toUnder_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>instFullUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_left"><code>toUnder_obj_left</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>CategoryTheory.Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>isEquivalence_toUnder</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>CategoryTheory.Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_right"><code>toUnder_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>instFaithfulUnderToUnder</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>toUnder_obj_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>CategoryTheory.Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>CategoryTheory.Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_map_left"><code>toUnder_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>instEssSurjUnderToUnder</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-StructuredArrow-toUnder_obj_right"><code>toUnder_obj_right</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1044" id="CategoryTheory-StructuredArrow-instEssSurjUnderToUnder"><code>instEssSurjUnderToUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.instEssSurjUnderToUnder" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-instEssSurjCompPre"><code>instEssSurjCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1038" id="CategoryTheory-StructuredArrow-instFaithfulUnderToUnder"><code>instFaithfulUnderToUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.instFaithfulUnderToUnder" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-instFaithfulCompPre"><code>instFaithfulCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1041" id="CategoryTheory-StructuredArrow-instFullUnderToUnder"><code>instFullUnderToUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.instFullUnderToUnder" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-instFullCompPre"><code>instFullCompPre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1048" id="CategoryTheory-StructuredArrow-isEquivalence_toUnder"><code>isEquivalence_toUnder</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.isEquivalence_toUnder" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-StructuredArrow-isEquivalence_pre"><code>isEquivalence_pre</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1193" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>ofCommaSndEquivalenceFunctor_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Under-homMk"><code>CategoryTheory.Under.homMk</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1193" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>ofCommaSndEquivalenceFunctor_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1193" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>ofCommaSndEquivalenceFunctor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1193" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>ofCommaSndEquivalenceFunctor_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1193" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>ofCommaSndEquivalenceFunctor_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>ofCommaSndEquivalenceInverse_map_right_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-preLeft"><code>CategoryTheory.Comma.preLeft</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>ofCommaSndEquivalenceInverse_map_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-preLeft"><code>CategoryTheory.Comma.preLeft</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>ofCommaSndEquivalenceInverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>ofCommaSndEquivalenceInverse_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>ofCommaSndEquivalenceInverse_obj_right_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>ofCommaSndEquivalenceInverse_obj_right_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1201" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>ofCommaSndEquivalenceInverse_obj_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1210" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>ofCommaSndEquivalence_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalence_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1210" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>ofCommaSndEquivalence_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalence_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1210" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>ofCommaSndEquivalence_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalence_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1210" id="CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>ofCommaSndEquivalence_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofCommaSndEquivalence_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Comma"><code>CategoryTheory.Comma</code></a><br><a href="#CategoryTheory-commaCategory"><code>CategoryTheory.commaCategory</code></a><br><a href="#CategoryTheory-Comma-fst"><code>CategoryTheory.Comma.fst</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence"><code>ofCommaSndEquivalence</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor"><code>ofCommaSndEquivalenceFunctor</code></a><br><a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse"><code>ofCommaSndEquivalenceInverse</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1034" id="CategoryTheory-StructuredArrow-toUnder_map_left"><code>toUnder_map_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder_map_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1034" id="CategoryTheory-StructuredArrow-toUnder_map_right"><code>toUnder_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1034" id="CategoryTheory-StructuredArrow-toUnder_obj_hom"><code>toUnder_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1034" id="CategoryTheory-StructuredArrow-toUnder_obj_left"><code>toUnder_obj_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder_obj_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1034" id="CategoryTheory-StructuredArrow-toUnder_obj_right"><code>toUnder_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.toUnder_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-toUnder"><code>toUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.StructuredArrow.ofDiagEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1156" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1166" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>inverse_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-toUnder"><code>CategoryTheory.Functor.toUnder</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1155" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1165" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>inverse_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1165" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1165" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1165" id="CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>inverse_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-uniformProd"><code>CategoryTheory.uniformProd</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-diag"><code>CategoryTheory.Functor.diag</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1127" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1137" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>inverse_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>inverse_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>inverse_obj_right_hom</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>functor_map_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-toUnder"><code>CategoryTheory.Functor.toUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>functor_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>functor_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>functor_obj_right_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>functor_obj_right_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1126" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>functor_obj_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor"><code>functor</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>inverse_map_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-toStructuredArrow"><code>CategoryTheory.Functor.toStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>inverse_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>inverse_obj_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>inverse_obj_right_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>inverse_obj_right_left_as</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-as"><code>CategoryTheory.Discrete.as</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1136" id="CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>inverse_obj_right_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-StructuredArrow"><code>CategoryTheory.StructuredArrow</code></a><br><a href="#CategoryTheory-instCategoryStructuredArrow"><code>CategoryTheory.instCategoryStructuredArrow</code></a><br><a href="#CategoryTheory-StructuredArrow-proj"><code>CategoryTheory.StructuredArrow.proj</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>CategoryTheory.Under.forget</code></a><br><a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse"><code>inverse</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
</table>
<h2>CategoryTheory.Under</h2>
<h3>Definitions</h3>
<table class="verification-table">
<tr><th>Name</th><th>Category</th><th>Theorems</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L977" id="CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>7 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-forgetMapInitial_inv_app"><code>forgetMapInitial_inv_app</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>equivalenceOfIsInitial_functor</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_hom_app"><code>forgetMapInitial_hom_app</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>equivalenceOfIsInitial_inverse_map</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_obj"><code>equivalenceOfIsInitial_inverse_obj</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L716" id="CategoryTheory-Under-forget"><code>forget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forget" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>78 math</summary><strong>math:</strong> <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_left"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_right"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_obj"><code>CategoryTheory.IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_obj</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_map_right"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_functor"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalence_functor</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_inv_app"><code>forgetMapInitial_inv_app</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_left_as"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-g_app"><code>CategoryTheory.IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.g_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_right"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>equivalenceOfIsInitial_functor</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_right"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_left_as"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_unitIso"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalence_unitIso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_counitIso"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalence_counitIso</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_hom_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_hom"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_hom"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_left"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-coneFunctorEnrichedHom_œÄ_app"><code>CategoryTheory.Enriched.FunctorCategory.coneFunctorEnrichedHom_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_map_right_right"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_left_as"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Presheaf-functorEnrichedHomCoyonedaObjEquiv_naturality"><code>CategoryTheory.Presheaf.functorEnrichedHomCoyonedaObjEquiv_naturality</code></a>, <a href="#CategoryTheory-MorphismProperty-under_eq_inverseImage"><code>CategoryTheory.MorphismProperty.under_eq_inverseImage</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_left"><code>CategoryTheory.WithInitial.commaFromUnder_map_left</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrow_comp_toUnder_comp_forget"><code>CategoryTheory.Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_map_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right</code></a>, <a href="#CategoryTheory-Under-forgetCone_pt"><code>forgetCone_pt</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_right"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_right_left_as"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_hom"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_inv_hom"><code>CategoryTheory.Limits.Cone.mapConeToUnder_inv_hom</code></a>, <a href="#CategoryTheory-Under-instIsRightAdjointForget"><code>instIsRightAdjointForget</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-F_map"><code>CategoryTheory.IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.F_map</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_hom_app"><code>forgetMapInitial_hom_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_hom"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_hom_app"><code>CategoryTheory.WithInitial.commaFromUnder_obj_hom_app</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_obj_right"><code>CategoryTheory.WithInitial.commaFromUnder_obj_right</code></a>, <a href="#CategoryTheory-Under-forget_map"><code>forget_map</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Functor-toUnder_comp_forget"><code>CategoryTheory.Functor.toUnder_comp_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_map_right_right"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedComp_app"><code>CategoryTheory.Enriched.FunctorCategory.functorEnrichedComp_app</code></a>, <a href="#CategoryTheory-WithInitial-commaFromUnder_map_right"><code>CategoryTheory.WithInitial.commaFromUnder_map_right</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_hom"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_obj"><code>CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom_obj</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-instHasEnrichedHomUnderCompMapForget"><code>CategoryTheory.Enriched.FunctorCategory.instHasEnrichedHomUnderCompMapForget</code></a>, <a href="#CategoryTheory-MorphismProperty-Under-forget_comp_forget_map"><code>CategoryTheory.MorphismProperty.Under.forget_comp_forget_map</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_map_right_right"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right</code></a>, <a href="#CategoryTheory-Under-forget_obj"><code>forget_obj</code></a>, <a href="#CategoryTheory-Under-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-Under-final_forget"><code>final_forget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_left"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_hom"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-inverse_obj_left_as"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as</code></a>, <a href="#CategoryTheory-Limits-Cone-mapConeToUnder_hom_hom"><code>CategoryTheory.Limits.Cone.mapConeToUnder_hom_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalence_inverse"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalence_inverse</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorHomEquiv_apply_app"><code>CategoryTheory.Enriched.FunctorCategory.functorHomEquiv_apply_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_right_left_as"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_hom"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom</code></a>, <a href="#CategoryTheory-Limits-Cone-toStructuredArrowCompToUnderCompForget_inv_app"><code>CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-hf"><code>CategoryTheory.IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.hf</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_left_as"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as</code></a>, <a href="#CategoryTheory-Limits-instPreservesFilteredColimitsOfSizeUnderForget"><code>CategoryTheory.Limits.instPreservesFilteredColimitsOfSizeUnderForget</code></a>, <a href="#CategoryTheory-StructuredArrow-ofDiagEquivalence-functor_obj_left_as"><code>CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_map"><code>CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom_map</code></a>, <a href="#CategoryTheory-Under-forgetCone_œÄ_app"><code>forgetCone_œÄ_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-inverse_obj_right_hom"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom</code></a>, <a href="#CategoryTheory-IsGrothendieckAbelian-IsPresentable-injectivity‚ÇÄ-epi_f"><code>CategoryTheory.IsGrothendieckAbelian.IsPresentable.injectivity‚ÇÄ.epi_f</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_obj_hom"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom</code></a>, <a href="#CategoryTheory-Under-forget_reflects_iso"><code>forget_reflects_iso</code></a>, <a href="#CategoryTheory-StructuredArrow-ofStructuredArrowProjEquivalence-functor_obj_hom"><code>CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceInverse_obj_right_right"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedId_app"><code>CategoryTheory.Enriched.FunctorCategory.functorEnrichedId_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L732" id="CategoryTheory-Under-forgetCone"><code>forgetCone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forgetCone" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-forgetCone_pt"><code>forgetCone_pt</code></a>, <a href="#CategoryTheory-Under-forgetCone_œÄ_app"><code>forgetCone_œÄ_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L655" id="CategoryTheory-Under-homMk"><code>homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.homMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>34 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>equivalenceOfIsInitial_counitIso</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_obj"><code>CategoryTheory.Limits.pushoutCoconeEquivBinaryCofan_functor_obj</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_unitIso"><code>CategoryTheory.Limits.pushoutCoconeEquivBinaryCofan_unitIso</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>CategoryTheory.Limits.Cocone.underPost_Œπ_app</code></a>, <a href="#CategoryTheory-Under-homMk_eta"><code>homMk_eta</code></a>, <a href="#CategoryTheory-Under-homMk_right"><code>homMk_right</code></a>, <a href="#CategoryTheory-Under-pushout_map"><code>pushout_map</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_unit_app"><code>mapPushoutAdj_unit_app</code></a>, <a href="#CategoryTheory-StructuredArrow-ofCommaSndEquivalenceFunctor_map_left"><code>CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_left</code></a>, <a href="#CategoryTheory-Under-liftCocone_Œπ_app"><code>liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Under-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-MorphismProperty-Under-homMk_hom"><code>CategoryTheory.MorphismProperty.Under.homMk_hom</code></a>, <a href="#CategoryTheory-Under-homMk_surjective"><code>homMk_surjective</code></a>, <a href="#CategoryTheory-Under-liftCone_œÄ_app"><code>liftCone_œÄ_app</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_functor_map_hom"><code>CategoryTheory.Limits.pushoutCoconeEquivBinaryCofan_functor_map_hom</code></a>, <a href="#CommRingCat-monoidAlgebra_map"><code>CommRingCat.monoidAlgebra_map</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_counitIso"><code>CategoryTheory.Over.opEquivOpUnder_counitIso</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_counit_app"><code>mapPushoutAdj_counit_app</code></a>, <a href="#CategoryTheory-Limits-Cone-toUnder_œÄ_app"><code>CategoryTheory.Limits.Cone.toUnder_œÄ_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>equivalenceOfIsInitial_inverse_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-Under-mono_homMk"><code>mono_homMk</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_counitIso"><code>CategoryTheory.Limits.pushoutCoconeEquivBinaryCofan_counitIso</code></a>, <a href="#CategoryTheory-Over-opEquivOpUnder_functor_map"><code>CategoryTheory.Over.opEquivOpUnder_functor_map</code></a>, <a href="#CategoryTheory-Under-lift_map"><code>lift_map</code></a>, <a href="#CategoryTheory-Under-epi_homMk"><code>epi_homMk</code></a>, <a href="#CategoryTheory-algebraToUnder_map"><code>CategoryTheory.algebraToUnder_map</code></a>, <a href="#CategoryTheory-Under-homMk_comp"><code>homMk_comp</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>opEquivOpOver_inverse_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L617" id="CategoryTheory-Under-inhabited"><code>inhabited</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.inhabited" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1002" id="CategoryTheory-Under-isColimitLiftCocone"><code>isColimitLiftCocone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.isColimitLiftCocone" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L673" id="CategoryTheory-Under-isoMk"><code>isoMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.isoMk" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>8 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-isoMk_inv_right"><code>isoMk_inv_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-isoMk_hom_right"><code>isoMk_hom_right</code></a>, <a href="#CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a>, <a href="#CategoryTheory-algebraEquivUnder_counitIso"><code>CategoryTheory.algebraEquivUnder_counitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Limits-pushoutCoconeEquivBinaryCofan_counitIso"><code>CategoryTheory.Limits.pushoutCoconeEquivBinaryCofan_counitIso</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L993" id="CategoryTheory-Under-liftCocone"><code>liftCocone</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.liftCocone" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-liftCocone_Œπ_app"><code>liftCocone_Œπ_app</code></a>, <a href="#CategoryTheory-Under-liftCocone_pt"><code>liftCocone_pt</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L737" id="CategoryTheory-Under-map"><code>map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.map" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>34 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-forgetMapInitial_inv_app"><code>forgetMapInitial_inv_app</code></a>, <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-Under-mapIso_functor"><code>mapIso_functor</code></a>, <a href="#CategoryTheory-Under-mapCongr_inv_app"><code>mapCongr_inv_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_unit_app_right"><code>postAdjunctionRight_unit_app_right</code></a>, <a href="#CategoryTheory-Under-map_map_right"><code>map_map_right</code></a>, <a href="#CategoryTheory-Under-map_obj_right"><code>map_obj_right</code></a>, <a href="#CategoryTheory-Under-mapId_inv"><code>mapId_inv</code></a>, <a href="#CategoryTheory-Presheaf-functorEnrichedHomCoyonedaObjEquiv_naturality"><code>CategoryTheory.Presheaf.functorEnrichedHomCoyonedaObjEquiv_naturality</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_unit_app"><code>mapPushoutAdj_unit_app</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a>, <a href="#CategoryTheory-Under-map_obj_hom"><code>map_obj_hom</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-mapCongr_hom_app"><code>mapCongr_hom_app</code></a>, <a href="#CategoryTheory-Under-mapFunctor_map"><code>mapFunctor_map</code></a>, <a href="#CategoryTheory-Under-forgetMapInitial_hom_app"><code>forgetMapInitial_hom_app</code></a>, <a href="#CategoryTheory-Under-mapComp_hom"><code>mapComp_hom</code></a>, <a href="#CategoryTheory-Under-mapIso_inverse"><code>mapIso_inverse</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-Under-mapId_hom"><code>mapId_hom</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>postCongr_hom_app_right</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-instHasEnrichedHomUnderCompMapForget"><code>CategoryTheory.Enriched.FunctorCategory.instHasEnrichedHomUnderCompMapForget</code></a>, <a href="#CategoryTheory-Under-mapId_eq"><code>mapId_eq</code></a>, <a href="#CategoryTheory-Under-mapForget_eq"><code>mapForget_eq</code></a>, <a href="#CategoryTheory-Under-mapPushoutAdj_counit_app"><code>mapPushoutAdj_counit_app</code></a>, <a href="#CategoryTheory-Under-mapComp_eq"><code>mapComp_eq</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-mapComp_inv"><code>mapComp_inv</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-Enriched-FunctorCategory-functorEnrichedHom_map"><code>CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom_map</code></a>, <a href="#CategoryTheory-Under-preservesLimitsOfSize_map"><code>preservesLimitsOfSize_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L813" id="CategoryTheory-Under-mapComp"><code>mapComp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapComp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mapComp_hom"><code>mapComp_hom</code></a>, <a href="#CategoryTheory-Under-mapComp_inv"><code>mapComp_inv</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L818" id="CategoryTheory-Under-mapCongr"><code>mapCongr</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapCongr" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mapCongr_inv_app"><code>mapCongr_inv_app</code></a>, <a href="#CategoryTheory-Under-mapCongr_hom_app"><code>mapCongr_hom_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L794" id="CategoryTheory-Under-mapForget"><code>mapForget</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapForget" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L824" id="CategoryTheory-Under-mapFunctor"><code>mapFunctor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapFunctor" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mapFunctor_obj"><code>mapFunctor_obj</code></a>, <a href="#CategoryTheory-Under-mapFunctor_map"><code>mapFunctor_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L787" id="CategoryTheory-Under-mapId"><code>mapId</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapId" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mapId_inv"><code>mapId_inv</code></a>, <a href="#CategoryTheory-Under-mapId_hom"><code>mapId_hom</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L757" id="CategoryTheory-Under-mapIso"><code>mapIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapIso" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mapIso_functor"><code>mapIso_functor</code></a>, <a href="#CategoryTheory-Under-mapIso_inverse"><code>mapIso_inverse</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L649" id="CategoryTheory-Under-mk"><code>mk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mk" title="API Documentation">üìñ</a></td><td>CompOp</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L842" id="CategoryTheory-Under-mkIdInitial"><code>mkIdInitial</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mkIdInitial" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-mkIdInitial_to_right"><code>mkIdInitial_to_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1345" id="CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>6 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-opEquivOpOver_functor_obj"><code>opEquivOpOver_functor_obj</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>opEquivOpOver_inverse_obj</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_counitIso"><code>opEquivOpOver_counitIso</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_unitIso"><code>opEquivOpOver_unitIso</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_functor_map"><code>opEquivOpOver_functor_map</code></a>, <a href="#CategoryTheory-Under-opEquivOpOver_inverse_map"><code>opEquivOpOver_inverse_map</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L893" id="CategoryTheory-Under-post"><code>post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.post" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>30 math</summary><strong>math:</strong> <a href="#CategoryTheory-Limits-PreservesColimitsOfSize-underPost"><code>CategoryTheory.Limits.PreservesColimitsOfSize.underPost</code></a>, <a href="#CategoryTheory-Under-postComp_inv_app_right"><code>postComp_inv_app_right</code></a>, <a href="#CategoryTheory-Under-post_comp"><code>post_comp</code></a>, <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_Œπ_app"><code>CategoryTheory.Limits.Cocone.underPost_Œπ_app</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_inv_app"><code>CategoryTheory.WithInitial.liftFromUnderComp_inv_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_unit_app_right"><code>postAdjunctionRight_unit_app_right</code></a>, <a href="#CategoryTheory-Under-post_obj"><code>post_obj</code></a>, <a href="#CategoryTheory-Under-post_map"><code>post_map</code></a>, <a href="#CategoryTheory-Functor-essImage_underPost"><code>CategoryTheory.Functor.essImage_underPost</code></a>, <a href="#CategoryTheory-Under-instFaithfulObjPost"><code>instFaithfulObjPost</code></a>, <a href="#CategoryTheory-Under-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a>, <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-postComp_hom_app_right"><code>postComp_hom_app_right</code></a>, <a href="#CategoryTheory-Limits-PreservesFiniteColimits-underPost"><code>CategoryTheory.Limits.PreservesFiniteColimits.underPost</code></a>, <a href="#CategoryTheory-Under-isLeftAdjoint_post"><code>isLeftAdjoint_post</code></a>, <a href="#CategoryTheory-Under-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a>, <a href="#CategoryTheory-Under-postMap_app"><code>postMap_app</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>postCongr_hom_app_right</code></a>, <a href="#CategoryTheory-Under-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a>, <a href="#CategoryTheory-WithInitial-liftFromUnderComp_hom_app"><code>CategoryTheory.WithInitial.liftFromUnderComp_hom_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Limits-PreservesColimitsOfShape-underPost"><code>CategoryTheory.Limits.PreservesColimitsOfShape.underPost</code></a>, <a href="#CategoryTheory-Under-postAdjunctionRight_counit_app_right"><code>postAdjunctionRight_counit_app_right</code></a>, <a href="#CategoryTheory-Under-postEquiv_functor"><code>postEquiv_functor</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a>, <a href="#CategoryTheory-Under-isRightAdjoint_post"><code>isRightAdjoint_post</code></a>, <a href="#CategoryTheory-Limits-Cocone-underPost_pt"><code>CategoryTheory.Limits.Cocone.underPost_pt</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L955" id="CategoryTheory-Under-postAdjunctionLeft"><code>postAdjunctionLeft</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postAdjunctionLeft" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>3 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-postAdjunctionRight_unit_app_right"><code>postAdjunctionRight_unit_app_right</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a>, <a href="#CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L905" id="CategoryTheory-Under-postComp"><code>postComp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postComp" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-postComp_inv_app_right"><code>postComp_inv_app_right</code></a>, <a href="#CategoryTheory-Under-postComp_hom_app_right"><code>postComp_hom_app_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L918" id="CategoryTheory-Under-postCongr"><code>postCongr</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postCongr" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>2 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-postCongr_inv_app_right"><code>postCongr_inv_app_right</code></a>, <a href="#CategoryTheory-Under-postCongr_hom_app_right"><code>postCongr_hom_app_right</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L966" id="CategoryTheory-Under-postEquiv"><code>postEquiv</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postEquiv" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>4 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a>, <a href="#CategoryTheory-Under-postEquiv_inverse"><code>postEquiv_inverse</code></a>, <a href="#CategoryTheory-Under-postEquiv_functor"><code>postEquiv_functor</code></a>, <a href="#CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a><br></details></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L912" id="CategoryTheory-Under-postMap"><code>postMap</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postMap" title="API Documentation">üìñ</a></td><td>CompOp</td><td><details><summary>1 math</summary><strong>math:</strong> <a href="#CategoryTheory-Under-postMap_app"><code>postMap_app</code></a><br></details></td></tr>
</table>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L641" id="CategoryTheory-Under-comp_right"><code>comp_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.comp_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L874" id="CategoryTheory-Under-epi_homMk"><code>epi_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.epi_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L871" id="CategoryTheory-Under-epi_of_epi_right"><code>epi_of_epi_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.epi_of_epi_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-epi_of_epi_map"><code>CategoryTheory.Functor.epi_of_epi_map</code></a><br><a href="#CategoryTheory-Functor-reflectsEpimorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsEpimorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L883" id="CategoryTheory-Under-epi_right_of_epi"><code>epi_right_of_epi</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.epi_right_of_epi" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Epi"><code>CategoryTheory.Epi</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-w"><code>w</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-cancel_epi"><code>CategoryTheory.cancel_epi</code></a><br><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L798" id="CategoryTheory-Under-eqToHom_right"><code>eqToHom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.eqToHom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L976" id="CategoryTheory-Under-equivalenceOfIsInitial_counitIso"><code>equivalenceOfIsInitial_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L976" id="CategoryTheory-Under-equivalenceOfIsInitial_functor"><code>equivalenceOfIsInitial_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L976" id="CategoryTheory-Under-equivalenceOfIsInitial_inverse_map"><code>equivalenceOfIsInitial_inverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial_inverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L976" id="CategoryTheory-Under-equivalenceOfIsInitial_inverse_obj"><code>equivalenceOfIsInitial_inverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial_inverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a><br><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L976" id="CategoryTheory-Under-equivalenceOfIsInitial_unitIso"><code>equivalenceOfIsInitial_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.equivalenceOfIsInitial_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-equivalenceOfIsInitial"><code>equivalenceOfIsInitial</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L697" id="CategoryTheory-Under-forall_iff"><code>forall_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forall_iff" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L731" id="CategoryTheory-Under-forgetCone_pt"><code>forgetCone_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forgetCone_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Limits-Cone-pt"><code>CategoryTheory.Limits.Cone.pt</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-Under-forgetCone"><code>forgetCone</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L731" id="CategoryTheory-Under-forgetCone_œÄ_app"><code>forgetCone_œÄ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forgetCone_œÄ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-Limits-Cone-œÄ"><code>CategoryTheory.Limits.Cone.œÄ</code></a><br><a href="#CategoryTheory-Under-forgetCone"><code>forgetCone</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L850" id="CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forget_faithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L726" id="CategoryTheory-Under-forget_map"><code>forget_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forget_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L722" id="CategoryTheory-Under-forget_obj"><code>forget_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forget_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L833" id="CategoryTheory-Under-forget_reflects_iso"><code>forget_reflects_iso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.forget_reflects_iso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ReflectsIsomorphisms"><code>CategoryTheory.Functor.ReflectsIsomorphisms</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-IsIso-comp_inv_eq"><code>CategoryTheory.IsIso.comp_inv_eq</code></a><br><a href="#CategoryTheory-Under-w"><code>w</code></a><br><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a><br><a href="#CategoryTheory-IsIso-hom_inv_id"><code>CategoryTheory.IsIso.hom_inv_id</code></a><br><a href="#CategoryTheory-IsIso-inv_hom_id"><code>CategoryTheory.IsIso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L665" id="CategoryTheory-Under-homMk_comp"><code>homMk_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.homMk_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L659" id="CategoryTheory-Under-homMk_eta"><code>homMk_eta</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.homMk_eta" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L654" id="CategoryTheory-Under-homMk_right"><code>homMk_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.homMk_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L706" id="CategoryTheory-Under-homMk_surjective"><code>homMk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.homMk_surjective" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-w"><code>w</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L688" id="CategoryTheory-Under-hom_right_inv_right"><code>hom_right_inv_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.hom_right_inv_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-hom_inv_id"><code>CategoryTheory.Iso.hom_inv_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L687" id="CategoryTheory-Under-hom_right_inv_right_assoc"><code>hom_right_inv_right_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.hom_right_inv_right_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Under-hom_right_inv_right"><code>hom_right_inv_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L637" id="CategoryTheory-Under-id_right"><code>id_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.id_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L936" id="CategoryTheory-Under-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.instEssSurjObjPostOfFull" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj"><code>CategoryTheory.Functor.EssSurj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-EssSurj-mem_essImage"><code>CategoryTheory.Functor.EssSurj.mem_essImage</code></a><br><a href="#CategoryTheory-Functor-map_surjective"><code>CategoryTheory.Functor.map_surjective</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Iso-inv_hom_id"><code>CategoryTheory.Iso.inv_hom_id</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L923" id="CategoryTheory-Under-instFaithfulObjPost"><code>instFaithfulObjPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.instFaithfulObjPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Faithful"><code>CategoryTheory.Functor.Faithful</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a><br><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L929" id="CategoryTheory-Under-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.instFullObjPostOfFaithful" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-Full"><code>CategoryTheory.Functor.Full</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map_surjective"><code>CategoryTheory.Functor.map_surjective</code></a><br><a href="#CategoryTheory-Functor-map_injective"><code>CategoryTheory.Functor.map_injective</code></a><br><a href="#CategoryTheory-Functor-map_comp"><code>CategoryTheory.Functor.map_comp</code></a><br><a href="#CategoryTheory-Under-w"><code>w</code></a><br><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L763" id="CategoryTheory-Under-instIsEquivalenceMapOfIsIso"><code>instIsEquivalenceMapOfIsIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.instIsEquivalenceMapOfIsIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-isEquivalence_functor"><code>CategoryTheory.Equivalence.isEquivalence_functor</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L942" id="CategoryTheory-Under-instIsEquivalenceObjPost"><code>instIsEquivalenceObjPost</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.instIsEquivalenceObjPost" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsEquivalence"><code>CategoryTheory.Functor.IsEquivalence</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-instFaithfulObjPost"><code>instFaithfulObjPost</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-faithful"><code>CategoryTheory.Functor.IsEquivalence.faithful</code></a><br><a href="#CategoryTheory-Under-instFullObjPostOfFaithful"><code>instFullObjPostOfFaithful</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-full"><code>CategoryTheory.Functor.IsEquivalence.full</code></a><br><a href="#CategoryTheory-Under-instEssSurjObjPostOfFull"><code>instEssSurjObjPostOfFull</code></a><br><a href="#CategoryTheory-Functor-IsEquivalence-essSurj"><code>CategoryTheory.Functor.IsEquivalence.essSurj</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L693" id="CategoryTheory-Under-inv_right_hom_right"><code>inv_right_hom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.inv_right_hom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-inv_hom_id"><code>CategoryTheory.Iso.inv_hom_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L692" id="CategoryTheory-Under-inv_right_hom_right_assoc"><code>inv_right_hom_right_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.inv_right_hom_right_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Under-inv_right_hom_right"><code>inv_right_hom_right</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L960" id="CategoryTheory-Under-isLeftAdjoint_post"><code>isLeftAdjoint_post</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.isLeftAdjoint_post" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-IsLeftAdjoint"><code>CategoryTheory.Functor.IsLeftAdjoint</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L678" id="CategoryTheory-Under-isoMk_hom_right"><code>isoMk_hom_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.isoMk_hom_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L683" id="CategoryTheory-Under-isoMk_inv_right"><code>isoMk_inv_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.isoMk_inv_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L992" id="CategoryTheory-Under-liftCocone_pt"><code>liftCocone_pt</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.liftCocone_pt" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cocone-pt"><code>CategoryTheory.Limits.Cocone.pt</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cocone-Œπ"><code>CategoryTheory.Limits.Cocone.Œπ</code></a></td><td><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-lift"><code>lift</code></a><br><a href="#CategoryTheory-Under-liftCocone"><code>liftCocone</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L992" id="CategoryTheory-Under-liftCocone_Œπ_app"><code>liftCocone_Œπ_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.liftCocone_Œπ_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a><br><a href="#CategoryTheory-Limits-Cocone-pt"><code>CategoryTheory.Limits.Cocone.pt</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Limits-Cocone-Œπ"><code>CategoryTheory.Limits.Cocone.Œπ</code></a></td><td><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-lift"><code>lift</code></a><br><a href="#CategoryTheory-Under-liftCocone"><code>liftCocone</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L984" id="CategoryTheory-Under-lift_map"><code>lift_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.lift_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-lift"><code>lift</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L984" id="CategoryTheory-Under-lift_obj"><code>lift_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.lift_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-lift"><code>lift</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-const"><code>CategoryTheory.Functor.const</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L803" id="CategoryTheory-Under-mapComp_eq"><code>mapComp_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapComp_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ext"><code>CategoryTheory.Functor.ext</code></a><br><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>UnderMorphism.ext</code></a><br><a href="#CategoryTheory-Under-eqToHom_right"><code>eqToHom_right</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L812" id="CategoryTheory-Under-mapComp_hom"><code>mapComp_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapComp_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-mapComp"><code>mapComp</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Under-mapComp_eq"><code>mapComp_eq</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L812" id="CategoryTheory-Under-mapComp_inv"><code>mapComp_inv</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapComp_inv" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-mapComp"><code>mapComp</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Under-mapComp_eq"><code>mapComp_eq</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L817" id="CategoryTheory-Under-mapCongr_hom_app"><code>mapCongr_hom_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapCongr_hom_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-mapCongr"><code>mapCongr</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L817" id="CategoryTheory-Under-mapCongr_inv_app"><code>mapCongr_inv_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapCongr_inv_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-mapCongr"><code>mapCongr</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L790" id="CategoryTheory-Under-mapForget_eq"><code>mapForget_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapForget_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Under-forget"><code>forget</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L824" id="CategoryTheory-Under-mapFunctor_map"><code>mapFunctor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapFunctor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-Cat"><code>CategoryTheory.Cat</code></a><br><a href="#CategoryTheory-Cat-category"><code>CategoryTheory.Cat.category</code></a><br><a href="#CategoryTheory-Under-mapFunctor"><code>mapFunctor</code></a><br><a href="#CategoryTheory-Functor-toCatHom"><code>CategoryTheory.Functor.toCatHom</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L824" id="CategoryTheory-Under-mapFunctor_obj"><code>mapFunctor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapFunctor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-Cat"><code>CategoryTheory.Cat</code></a><br><a href="#CategoryTheory-Cat-category"><code>CategoryTheory.Cat.category</code></a><br><a href="#CategoryTheory-Under-mapFunctor"><code>mapFunctor</code></a><br><a href="#CategoryTheory-Cat-of"><code>CategoryTheory.Cat.of</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L775" id="CategoryTheory-Under-mapId_eq"><code>mapId_eq</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapId_eq" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-ext"><code>CategoryTheory.Functor.ext</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#CategoryTheory-StructuredArrow-eqToHom_right"><code>CategoryTheory.StructuredArrow.eqToHom_right</code></a><br><a href="#CategoryTheory-Category-comp_id"><code>CategoryTheory.Category.comp_id</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L786" id="CategoryTheory-Under-mapId_hom"><code>mapId_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapId_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under-mapId"><code>mapId</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Under-mapId_eq"><code>mapId_eq</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L786" id="CategoryTheory-Under-mapId_inv"><code>mapId_inv</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapId_inv" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under-mapId"><code>mapId</code></a><br><a href="#CategoryTheory-eqToHom"><code>CategoryTheory.eqToHom</code></a><br><a href="#CategoryTheory-Under-mapId_eq"><code>mapId_eq</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L760" id="CategoryTheory-Under-mapIso_functor"><code>mapIso_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapIso_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L761" id="CategoryTheory-Under-mapIso_inverse"><code>mapIso_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mapIso_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-mapIso"><code>mapIso</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L753" id="CategoryTheory-Under-map_map_right"><code>map_map_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.map_map_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L749" id="CategoryTheory-Under-map_obj_hom"><code>map_obj_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.map_obj_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L745" id="CategoryTheory-Under-map_obj_right"><code>map_obj_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.map_obj_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L846" id="CategoryTheory-Under-mkIdInitial_to_right"><code>mkIdInitial_to_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mkIdInitial_to_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Limits-IsInitial-to"><code>CategoryTheory.Limits.IsInitial.to</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-mkIdInitial"><code>mkIdInitial</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a><br><a href="#CategoryTheory-Limits-IsInitial-hom_ext"><code>CategoryTheory.Limits.IsInitial.hom_ext</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L648" id="CategoryTheory-Under-mk_hom"><code>mk_hom</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mk_hom" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L648" id="CategoryTheory-Under-mk_right"><code>mk_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mk_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L701" id="CategoryTheory-Under-mk_surjective"><code>mk_surjective</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mk_surjective" title="API Documentation">üìñ</a></td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L861" id="CategoryTheory-Under-mono_homMk"><code>mono_homMk</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mono_homMk" title="API Documentation">üìñ</a></td><td>mathematical</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L858" id="CategoryTheory-Under-mono_of_mono_right"><code>mono_of_mono_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.mono_of_mono_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Mono"><code>CategoryTheory.Mono</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-mono_of_mono_map"><code>CategoryTheory.Functor.mono_of_mono_map</code></a><br><a href="#CategoryTheory-Functor-reflectsMonomorphisms_of_faithful"><code>CategoryTheory.Functor.reflectsMonomorphisms_of_faithful</code></a><br><a href="#CategoryTheory-Under-forget_faithful"><code>forget_faithful</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_counitIso"><code>opEquivOpOver_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_functor_map"><code>opEquivOpOver_functor_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_functor_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#Quiver-Hom"><code>Quiver.Hom</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-Over-homMk"><code>CategoryTheory.Over.homMk</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_functor_obj"><code>opEquivOpOver_functor_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_functor_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_inverse_map"><code>opEquivOpOver_inverse_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_inverse_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-left"><code>CategoryTheory.CommaMorphism.left</code></a><br><a href="#Quiver-Hom-unop"><code>Quiver.Hom.unop</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_inverse_obj"><code>opEquivOpOver_inverse_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_inverse_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#Opposite-unop"><code>Opposite.unop</code></a><br><a href="#Quiver-Hom-op"><code>Quiver.Hom.op</code></a><br><a href="#CategoryTheory-CategoryStruct-toQuiver"><code>CategoryTheory.CategoryStruct.toQuiver</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L1344" id="CategoryTheory-Under-opEquivOpOver_unitIso"><code>opEquivOpOver_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.opEquivOpOver_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#Opposite"><code>Opposite</code></a><br><a href="#CategoryTheory-Category-opposite"><code>CategoryTheory.Category.opposite</code></a><br><a href="#Opposite-op"><code>Opposite.op</code></a><br><a href="#CategoryTheory-Over"><code>CategoryTheory.Over</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-instCategoryOver"><code>CategoryTheory.instCategoryOver</code></a><br><a href="#CategoryTheory-Under-opEquivOpOver"><code>opEquivOpOver</code></a><br><a href="#CategoryTheory-Iso-refl"><code>CategoryTheory.Iso.refl</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L954" id="CategoryTheory-Under-postAdjunctionLeft_counit_app"><code>postAdjunctionLeft_counit_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postAdjunctionLeft_counit_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Adjunction-unit"><code>CategoryTheory.Adjunction.unit</code></a><br><a href="#CategoryTheory-Adjunction-counit"><code>CategoryTheory.Adjunction.counit</code></a><br><a href="#CategoryTheory-Under-postAdjunctionLeft"><code>postAdjunctionLeft</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L954" id="CategoryTheory-Under-postAdjunctionLeft_unit_app"><code>postAdjunctionLeft_unit_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postAdjunctionLeft_unit_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Adjunction-unit"><code>CategoryTheory.Adjunction.unit</code></a><br><a href="#CategoryTheory-Under-postAdjunctionLeft"><code>postAdjunctionLeft</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L904" id="CategoryTheory-Under-postComp_hom_app_right"><code>postComp_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postComp_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-postComp"><code>postComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L904" id="CategoryTheory-Under-postComp_inv_app_right"><code>postComp_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postComp_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-postComp"><code>postComp</code></a><br><a href="#CategoryTheory-CategoryStruct-id"><code>CategoryTheory.CategoryStruct.id</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L917" id="CategoryTheory-Under-postCongr_hom_app_right"><code>postCongr_hom_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postCongr_hom_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-postCongr"><code>postCongr</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L917" id="CategoryTheory-Under-postCongr_inv_app_right"><code>postCongr_inv_app_right</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postCongr_inv_app_right" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Iso-inv"><code>CategoryTheory.Iso.inv</code></a><br><a href="#CategoryTheory-Under-postCongr"><code>postCongr</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L965" id="CategoryTheory-Under-postEquiv_counitIso"><code>postEquiv_counitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postEquiv_counitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-counitIso"><code>CategoryTheory.Equivalence.counitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Iso-app"><code>CategoryTheory.Iso.app</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L965" id="CategoryTheory-Under-postEquiv_functor"><code>postEquiv_functor</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postEquiv_functor" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L965" id="CategoryTheory-Under-postEquiv_inverse"><code>postEquiv_inverse</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postEquiv_inverse" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L965" id="CategoryTheory-Under-postEquiv_unitIso"><code>postEquiv_unitIso</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postEquiv_unitIso" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Equivalence-unitIso"><code>CategoryTheory.Equivalence.unitIso</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Equivalence-functor"><code>CategoryTheory.Equivalence.functor</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-postEquiv"><code>postEquiv</code></a><br><a href="#CategoryTheory-NatIso-ofComponents"><code>CategoryTheory.NatIso.ofComponents</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Equivalence-inverse"><code>CategoryTheory.Equivalence.inverse</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Iso-hom"><code>CategoryTheory.Iso.hom</code></a><br><a href="#CategoryTheory-Functor"><code>CategoryTheory.Functor</code></a><br><a href="#CategoryTheory-Functor-category"><code>CategoryTheory.Functor.category</code></a><br><a href="#CategoryTheory-Under-isoMk"><code>isoMk</code></a><br><a href="#CategoryTheory-Iso-app"><code>CategoryTheory.Iso.app</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L911" id="CategoryTheory-Under-postMap_app"><code>postMap_app</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.postMap_app" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-NatTrans-app"><code>CategoryTheory.NatTrans.app</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under-map"><code>map</code></a><br><a href="#CategoryTheory-Under-postMap"><code>postMap</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L898" id="CategoryTheory-Under-post_comp"><code>post_comp</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.post_comp" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-comp"><code>CategoryTheory.Functor.comp</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L892" id="CategoryTheory-Under-post_map"><code>post_map</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.post_map" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Under-homMk"><code>homMk</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L892" id="CategoryTheory-Under-post_obj"><code>post_obj</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.post_obj" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Under"><code>CategoryTheory.Under</code></a><br><a href="#CategoryTheory-instCategoryUnder"><code>CategoryTheory.instCategoryUnder</code></a><br><a href="#CategoryTheory-Under-post"><code>post</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-map"><code>CategoryTheory.Functor.map</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L634" id="CategoryTheory-Under-under_left"><code>under_left</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.under_left" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L645" id="CategoryTheory-Under-w"><code>w</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.w" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-w"><code>CategoryTheory.CommaMorphism.w</code></a><br><a href="#CategoryTheory-Category-id_comp"><code>CategoryTheory.Category.id_comp</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L644" id="CategoryTheory-Under-w_assoc"><code>w_assoc</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.w_assoc" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CategoryStruct-comp"><code>CategoryTheory.CategoryStruct.comp</code></a><br><a href="#CategoryTheory-Category-toCategoryStruct"><code>CategoryTheory.Category.toCategoryStruct</code></a><br><a href="#CategoryTheory-Functor-obj"><code>CategoryTheory.Functor.obj</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Comma-left"><code>CategoryTheory.Comma.left</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a><br><a href="#CategoryTheory-Comma-right"><code>CategoryTheory.Comma.right</code></a><br><a href="#CategoryTheory-Comma-hom"><code>CategoryTheory.Comma.hom</code></a><br><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Category-assoc"><code>CategoryTheory.Category.assoc</code></a><br><a href="#Mathlib-Tactic-Reassoc-eq_whisker'"><code>Mathlib.Tactic.Reassoc.eq_whisker'</code></a><br><a href="#CategoryTheory-Under-w"><code>w</code></a></td></tr>
</table>
<h2>CategoryTheory.Under.UnderMorphism</h2>
<h3>Theorems</h3>
<table class="verification-table">
<tr><th>Name</th><th>Kind</th><th>Assumes</th><th>Proves</th><th>Validates</th><th>Depends On</th></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L628" id="CategoryTheory-Under-UnderMorphism-ext"><code>ext</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.UnderMorphism.ext" title="API Documentation">üìñ</a></td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td>‚Äî</td><td><a href="#CategoryTheory-Discrete-instSubsingletonDiscreteHom"><code>CategoryTheory.Discrete.instSubsingletonDiscreteHom</code></a></td></tr>
<tr><td><a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/CategoryTheory/Comma/Over/Basic.lean#L627" id="CategoryTheory-Under-UnderMorphism-ext_iff"><code>ext_iff</code></a> <a href="../api/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Under.UnderMorphism.ext_iff" title="API Documentation">üìñ</a></td><td>mathematical</td><td>‚Äî</td><td><a href="#CategoryTheory-CommaMorphism-right"><code>CategoryTheory.CommaMorphism.right</code></a><br><a href="#CategoryTheory-Discrete"><code>CategoryTheory.Discrete</code></a><br><a href="#CategoryTheory-discreteCategory"><code>CategoryTheory.discreteCategory</code></a><br><a href="#CategoryTheory-Functor-fromPUnit"><code>CategoryTheory.Functor.fromPUnit</code></a><br><a href="#CategoryTheory-Functor-id"><code>CategoryTheory.Functor.id</code></a></td><td>‚Äî</td><td><a href="#CategoryTheory-Under-UnderMorphism-ext"><code>ext</code></a></td></tr>
</table>
<p>---</p>
<p><a href="index.html">‚Üê Back to Index</a></p>
    </div>
  </main>
</body>
</html>